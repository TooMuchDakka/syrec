{
  "testRemovalOfUnusedInParameter": {
    "circuit": "module main(in a(16), out b(16)) b += 2",
    "expectedCircuit": "module main(out b(16)) b += 2"
  },
  "testRemovalOfUnusedOutParameter": {
    "circuit": "module main(out a(16), out b(16)) b += 2",
    "expectedCircuit": "module main(out b(16)) b += 2"
  },
  "testRemovalOfUnusedInoutParameter": {
    "circuit": "module main(inout a(16), out b(16)) b += 2",
    "expectedCircuit": "module main(out b(16)) b += 2"
  },
  "testRemovalOfUnusedWireLocal": {
    "circuit": "module main(out b(16)) wire a(16) b += 2",
    "expectedCircuit": "module main(out b(16)) b += 2"
  },
  "testRemovalOfUnusedStateLocal": {
    "circuit": "module main(out b(16)) state a(16) b += 2",
    "expectedCircuit": "module main(out b(16)) b += 2"
  },
  "testRemovalOfUnusedModule": {
    "circuit": "module double(in a(16), out b(16)) b += (a << 1) module main(out b(16)) b += 1",
    "expectedCircuit": "module main(out b(16)) b += 1"
  },
  "testRemovalOfUnusedModuleParametersAlsoDeletesModule": {
    "circuit": "module double(in a(16), out b(16)) skip module main(out b(16)) b += 1",
    "expectedCircuit": "module main(out b(16)) b += 1"
  },
  "testAttemptedRemovalOfTopLevelModuleWillNotBeDone": {
    "circuit": "module double(in a(16)) skip",
    "expectedCircuit": "module double() skip"
  },
  "testAttemptedRemovalOfTopLevelModuleWillNotBeDoneWhenDeclaringMultipleModules": {
    "circuit": "module main(out b(16)) b += 1 module test(in a(16)) skip",
    "expectedCircuit": "module main(out b(16)) b += 1"
  },
  "testElseBranchRemovedIfGuardConditionEvaluatesToValueLargerThanZero": {
    "circuit": "module main(out b(16), in a(16), in c(16)) if (#b = #a) then b += 10; b += c else b += a; b += 2 fi (#b = #a)",
    "expectedCircuit": "module main(out b(16), in c(16)) b += 10; b += c"
  },
  "testVariablesOnlyUsedInFalseBranchOfIfStatementWillBeRemovedIfFalseBranchIsDeleted": {
    "circuit": "module main(out b(16), in a(16), out c(16), out d(16)) if (#b != #a) then c += a; skip else d += a; skip fi (#b != #a)",
    "expectedCircuit": "module main(in a(16), out d(16)) d += a; skip"
  },
  "testIfBranchRemovedIfGuardConditionEvaluatesToValueSmallerOrEqualToZero": {
    "circuit": "module main(out b(16), in a(16), in c(16)) if (#b != #a) then b += 10; b += c else b += a; b += 2 fi (#b != #a)",
    "expectedCircuit": "module main(out b(16), in a(16)) b += a; b += 2"
  },
  "testVariablesOnlyUsedInTrueBranchOfIfStatementWillBeRemovedIfTrueBranchIsDeleted": {
    "circuit": "module main(out b(16), in a(16), out c(16), out d(16)) if (#b = #a) then c += a; skip else d += a; skip fi (#b = #a)",
    "expectedCircuit": "module main(in a(16), out c(16)) c += a; skip"
  },
  "testVariablesOnlyUsedForSignalWidthAreRemoved": {
    "circuit": "module main(out b(16), in a(10), inout c(16), out result(16), in other(16)) wire w1(8), w2(8) result += (#b + (#other - #w1)); w2 -= (other - #a)",
    "expectedCircuit": "module main(out result(16), in other(16)) wire w2(8) result += 24; w2 -= (other - 10)"
  },

  "testChangesDueToAssignmentsMadeInOmittedFalseBranchAreIgnoredIfGuardExpressionEvaluatesToConstantLargerThanZero": {
    "circuit": "module main(out b[2][2](4), in a[2](4)) wire test[2](4), output(4) if (b[0][0] >= 0) then b[0] += a; b[1][0] += 5; b[1][1] += 10; test[0] += b[0][0]; test[1] += b[1][0] else b[1] += a; b[0][1] += 5; b[0][0] += 10; test[1] += b[0][0]; test[0] += b[0][1] fi (b[0][0] >= 0); output.0 += b[0][0].0; output.1 += b[0][0].1; output.2 += b[0][0].2; output.3 += b[0][0].3; output.0 += b[0][1].0; output.1 += b[0][1].1; output.2 += b[0][1].2; output.3 += b[0][1].3; output.0 += b[1][0].0; output.1 += b[1][0].1; output.2 += b[1][0].2; output.3 += b[1][0].3; output.0 += b[1][1].0; output.1 += b[1][1].1; output.2 += b[1][1].2; output.3 += b[1][1].3; output.0 += test[0].0; output.1 += test[0].1; output.2 += test[0].2; output.3 += test[0].3; output.0 += test[1].0; output.1 += test[1].1; output.2 += test[1].2; output.3 += test[1].3",
    "expectedCircuit": "module main(out b[2][2](4), in a[2](4)) wire test[2](4), output(4) b[0] += a; b[1][0] += 5; b[1][1] += 10; test[0] += b[0][0]; test[1] += 5; output.0 += b[0][0].0; output.1 += b[0][0].1; output.2 += b[0][0].2; output.3 += b[0][0].3; output.0 += b[0][1].0; output.1 += b[0][1].1; output.2 += b[0][1].2; output.3 += b[0][1].3; output.0 += 1; output.2 += 1; output.1 += 1; output.3 += 1; output.0 += test[0].0; output.1 += test[0].1; output.2 += test[0].2; output.3 += test[0].3; output.0 += 1; output.2 += 1"
  },
  "testChangesDueToSwapsMadeInOmittedFalseBranchAreIgnoredIfGuardExpressionEvaluatesToConstantLargerThanZero": {
    "circuit": "module main(out b[2][2](4), out c[2][2](4), inout d[2](4), out output(4)) b[0][0] += 8; b[0][1] += 10; b[1][0] += 2; b[1][1] += 5; if (b[0][0] < b[0][1]) then b <=> c; d <=> b[0]; d[1] <=> c[0][1] else c <=> b; b[0] <=> d; c[0][0] <=> d[1] fi (b[0][0] < b[0][1]); output.0 += b[0][0].0; output.1 += b[0][0].1; output.2 += b[0][0].2; output.3 += b[0][0].3; output.0 += b[0][1].0; output.1 += b[0][1].1; output.2 += b[0][1].2; output.3 += b[0][1].3; output.0 += b[1][0].0; output.1 += b[1][0].1; output.2 += b[1][0].2; output.3 += b[1][0].3; output.0 += b[1][1].0; output.1 += b[1][1].1; output.2 += b[1][1].2; output.3 += b[1][1].3; output.0 += c[0][0].0; output.1 += c[0][0].1; output.2 += c[0][0].2; output.3 += c[0][0].3; output.0 += c[0][1].0; output.1 += c[0][1].1; output.2 += c[0][1].2; output.3 += c[0][1].3; output.0 += c[1][0].0; output.1 += c[1][0].1; output.2 += c[1][0].2; output.3 += c[1][0].3; output.0 += c[1][1].0; output.1 += c[1][1].1; output.2 += c[1][1].2; output.3 += c[1][1].3; output.0 += d[0].0; output.1 += d[0].1; output.2 += d[0].2; output.3 += d[0].3; output.0 += d[1].0; output.1 += d[1].1; output.2 += d[1].2; output.3 += d[1].3",
    "expectedCircuit": "module main(out b[2][2](4), out c[2][2](4), inout d[2](4), out output(4)) b[0][0] += 8; b[0][1] += 10; b[1][0] += 2; b[1][1] += 5; b <=> c; d <=> b[0]; d[1] <=> c[0][1]; output.0 += b[0][0].0; output.1 += b[0][0].1; output.2 += b[0][0].2; output.3 += b[0][0].3; output.0 += b[0][1].0; output.1 += b[0][1].1; output.2 += b[0][1].2; output.3 += b[0][1].3; output.3 += 1; output.1 += 1; output.0 += 1; output.2 += 1; output.1 += 1; output.3 += 1"
  },
  "testChangesDueToModuleCallsMadeInOmittedFalseBranchAreIgnoredIfGuardExpressionEvaluatesToConstantLargerThanZero": {
    "circuit": "module add(in a(4), in b(4), out c(4)) c += (a + b) module main(out a(4), out b(4), out c(4), out d[3](4)) if (#a = #b) then call add(a, b, c); uncall add(a, b, c); call add(a, b, a); uncall add(a, b, a) else call add(a, b, b); uncall add(a, b, b); call add(a, a, a); uncall add(a, a, a) fi (#a = #b); d[0].0 += a.0; d[0].1 += a.1; d[0].2 += a.2; d[0].3 += a.3; d[1].0 += b.0; d[1].1 += b.1; d[1].2 += b.2; d[1].3 += b.3; d[2].0 += c.0; d[2].1 += c.1; d[2].2 += c.2; d[2].3 += c.3",
    "expectedCircuit": "module add(in a(4), in b(4), out c(4)) c += (a + b) module main(out a(4), out b(4), out c(4), out d[3](4)) call add(a, b, c); uncall add(a, b, c); call add(a, b, a); uncall add(a, b, a); d[0].0 += a.0; d[0].1 += a.1; d[0].2 += a.2; d[0].3 += a.3; d[2].0 += c.0; d[2].1 += c.1; d[2].2 += c.2; d[2].3 += c.3"
  },
  "testChangesDueToUnaryStatementMadeInOmitedFalseBranchAreIgnoredIfGuardExpressionEvaluatesToConstantLargerThanToZero": {
    "circuit": "module main(out a(4), out b(4), out c(4), out d[3](4)) a += 2; b += 4; c += 3; if (#a = #b) then ++= a; --= b; ~= c else --= a; ++= b; ~= c fi (#a = #b); d[0].0 += a.0; d[0].1 += a.1; d[0].2 += a.2; d[0].3 += a.3; d[1].0 += b.0; d[1].1 += b.1; d[1].2 += b.2; d[1].3 += b.3; d[2].0 += c.0; d[2].1 += c.1; d[2].2 += c.2; d[2].3 += c.3",
    "expectedCircuit": "module main(out a(4), out b(4), out c(4), out d[3](4)) a += 2; b += 4; c += 3; ++= a; --= b; ~= c; d[0].0 += 1; d[0].1 += 1; d[1].0 += 1; d[1].1 += 1; d[2].2 += 1; d[2].3 += 1"
  },
  "testChangesDueToAssignmentsMadeInOmittedTrueBranchAreIgnoredIfGuardExpressionEvaluatesToConstantLessOrEqualToZero": {
    "circuit": "module main(out b[2][2](4), in a[2](4)) wire test[2](4), output(4) if (b[0][0] < 0) then b[0] += a; b[1][0] += 5; b[1][1] += 10; test[0] += b[0][0]; test[1] += b[1][0] else b[1] += a; b[0][1] += 5; b[0][0] += 10; test[1] += b[0][0]; test[0] += b[0][1] fi (b[0][0] < 0); output.0 += b[0][0].0; output.1 += b[0][0].1; output.2 += b[0][0].2; output.3 += b[0][0].3; output.0 += b[0][1].0; output.1 += b[0][1].1; output.2 += b[0][1].2; output.3 += b[0][1].3; output.0 += b[1][0].0; output.1 += b[1][0].1; output.2 += b[1][0].2; output.3 += b[1][0].3; output.0 += b[1][1].0; output.1 += b[1][1].1; output.2 += b[1][1].2; output.3 += b[1][1].3; output.0 += test[0].0; output.1 += test[0].1; output.2 += test[0].2; output.3 += test[0].3; output.0 += test[1].0; output.1 += test[1].1; output.2 += test[1].2; output.3 += test[1].3",
    "expectedCircuit": "module main(out b[2][2](4), in a[2](4)) wire test[2](4), output(4) b[1] += a; b[0][1] += 5; b[0][0] += 10; test[1] += 10; test[0] += 5; output.1 += 1; output.3 += 1; output.0 += 1; output.2 += 1; output.0 += b[1][0].0; output.1 += b[1][0].1; output.2 += b[1][0].2; output.3 += b[1][0].3; output.0 += b[1][1].0; output.1 += b[1][1].1; output.2 += b[1][1].2; output.3 += b[1][1].3; output.0 += 1; output.2 += 1; output.1 += 1; output.3 += 1"
  },
  "testChangesDueToSwapsMadeInOmittedTrueBranchAreIgnoredIfGuardExpressionEvaluatesToConstantLessOrEqualToZero": {
    "circuit": "module main(out b[2][2](4), out c[2][2](4), inout d[2](4), out output(4)) b[0][0] += 2; b[0][1] += 10; b[1][0] += 5; b[1][1] += 8; if (b[0][0] > b[0][1]) then b <=> c; d <=> b[0]; d[1] <=> c[0][1] else c <=> b; b[0] <=> d; c[0][0] <=> d[1] fi (b[0][0] > b[0][1]); output.0 += b[0][0].0; output.1 += b[0][0].1; output.2 += b[0][0].2; output.3 += b[0][0].3; output.0 += b[0][1].0; output.1 += b[0][1].1; output.2 += b[0][1].2; output.3 += b[0][1].3; output.0 += b[1][0].0; output.1 += b[1][0].1; output.2 += b[1][0].2; output.3 += b[1][0].3; output.0 += b[1][1].0; output.1 += b[1][1].1; output.2 += b[1][1].2; output.3 += b[1][1].3; output.0 += c[0][0].0; output.1 += c[0][0].1; output.2 += c[0][0].2; output.3 += c[0][0].3; output.0 += c[0][1].0; output.1 += c[0][1].1; output.2 += c[0][1].2; output.3 += c[0][1].3; output.0 += c[1][0].0; output.1 += c[1][0].1; output.2 += c[1][0].2; output.3 += c[1][0].3; output.0 += c[1][1].0; output.1 += c[1][1].1; output.2 += c[1][1].2; output.3 += c[1][1].3; output.0 += d[0].0; output.1 += d[0].1; output.2 += d[0].2; output.3 += d[0].3; output.0 += d[1].0; output.1 += d[1].1; output.2 += d[1].2; output.3 += d[1].3",
    "expectedCircuit": "module main(out b[2][2](4), out c[2][2](4), inout d[2](4), out output(4)) b[0][0] += 2; b[0][1] += 10; b[1][0] += 5; b[1][1] += 8; c <=> b; b[0] <=> d; c[0][0] <=> d[1]; output.0 += b[0][0].0; output.1 += b[0][0].1; output.2 += b[0][0].2; output.3 += b[0][0].3; output.0 += b[0][1].0; output.1 += b[0][1].1; output.2 += b[0][1].2; output.3 += b[0][1].3; output.1 += 1; output.3 += 1; output.0 += 1; output.2 += 1; output.3 += 1; output.1 += 1"
  },
  "testChangesDueToModuleCallsMadeInOmittedTrueBranchAreIgnoredIfGuardExpressionEvaluatesToConstantLessOrEqualToZero": {
    "circuit": "module add(in a(4), in b(4), out c(4)) c += (a + b) module main(out a(4), out b(4), out c(4), out d[3](4)) if (#a != #b) then call add(a, b, c); uncall add(a, b, c); call add(a, b, a); uncall add(a, b, a) else call add(a, b, b); uncall add(a, b, b); call add(a, a, a); uncall add(a, a, a) fi (#a != #b); d[0].0 += a.0; d[0].1 += a.1; d[0].2 += a.2; d[0].3 += a.3; d[1].0 += b.0; d[1].1 += b.1; d[1].2 += b.2; d[1].3 += b.3; d[2].0 += c.0; d[2].1 += c.1; d[2].2 += c.2; d[2].3 += c.3",
    "expectedCircuit": "module add(in a(4), in b(4), out c(4)) c += (a + b) module main(out a(4), out b(4), out c(4), out d[3](4)) call add(a, b, b); uncall add(a, b, b); call add(a, a, a); uncall add(a, a, a); d[0].0 += a.0; d[0].1 += a.1; d[0].2 += a.2; d[0].3 += a.3; d[1].0 += b.0; d[1].1 += b.1; d[1].2 += b.2; d[1].3 += b.3"
  },
  "testChangedDueToUnaryStatementMadeInOmittedTrueBranchAreIgnoredIfGuardExpressionEvaluatesToConstantLessOrEqualToZero": {
    "circuit": "module main(out a(4), out b(4), out c(4), out d[3](4)) a += 2; b += 4; c += 3; if (#a != #b) then ++= a; --= b; ~= c else --= a; ++= b; ~= c fi (#a != #b); d[0].0 += a.0; d[0].1 += a.1; d[0].2 += a.2; d[0].3 += a.3; d[1].0 += b.0; d[1].1 += b.1; d[1].2 += b.2; d[1].3 += b.3; d[2].0 += c.0; d[2].1 += c.1; d[2].2 += c.2; d[2].3 += c.3",
    "expectedCircuit": "module main(out a(4), out b(4), out c(4), out d[3](4)) a += 2; b += 4; c += 3; --= a; ++= b; ~= c; d[0].0 += 1; d[1].0 += 1; d[1].2 += 1; d[2].2 += 1; d[2].3 += 1"
  },

  "testNestedIfStatementInTrueBranchOfParentIsOptimizedByOmittingTrueBranchWhenGuardConditionOfNestedIfStatementAllowsItWhenParentCannotBeOptimized": {
    "circuit": "module main(out a[2](4), out b[2](4), in c[2](4), in d[2](4), out o(4)) if (a = b) then a[0] += 2; b[1] += 4; if (#a != #b) then a[0] += 2 else b[1] += 2 fi (#a != #b) else a[0] += 4; a[1] += 2 fi (a = b); o.0 += a[0].0; o.1 += a[0].1; o.2 += a[0].2; o.3 += a[0].3; o.0 += a[1].0; o.1 += a[1].1; o.2 += a[1].2; o.3 += a[1].3; o.0 += b[0].0; o.1 += b[0].1; o.2 += b[0].2; o.3 += b[0].3; o.0 += b[1].0; o.1 += b[1].1; o.2 += b[1].2; o.3 += b[1].3",
    "expectedCircuit": "module main(out a[2](4), out b[2](4), out o(4)) if (a = b) then a[0] += 2; b[1] += 4; b[1] += 2 else a[0] += 4; a[1] += 2 fi (a = b); o.1 += a[0].1; o.2 += a[0].2; o.1 += a[1].1; o.1 += b[1].1; o.2 += b[1].2"
  },
  "testNestedIfStatementInTrueBranchOfParentIsOptimizedByOmittingFalseBranchWhenGuardConditionOfNestedIfStatementAllowsItWhenParentCannotBeOptimized": {
    "circuit": "module main(out a[2](4), out b[2](4), in c[2](4), in d[2](4), out o(4)) if (a = b) then a[0] += 2; b[1] += 4; if (#a = #b) then a[0] += 2 else b[1] += 2 fi (#a = #b) else a[0] += 4; a[1] += 2 fi (a = b); o.0 += a[0].0; o.1 += a[0].1; o.2 += a[0].2; o.3 += a[0].3; o.0 += a[1].0; o.1 += a[1].1; o.2 += a[1].2; o.3 += a[1].3; o.0 += b[0].0; o.1 += b[0].1; o.2 += b[0].2; o.3 += b[0].3; o.0 += b[1].0; o.1 += b[1].1; o.2 += b[1].2; o.3 += b[1].3",
    "expectedCircuit": "module main(out a[2](4), out b[2](4), out o(4)) if (a = b) then a[0] += 2; b[1] += 4; a[0] += 2 else a[0] += 4; a[1] += 2 fi (a = b); o.2 += a[0].2; o.1 += a[1].1; o.2 += b[1].2"
  },
  "testNestedIfStatementInFalseBranchOfParentIsOptimizedByOmittingTrueBranchWhenGuardConditionOfNestedIfStatementAllowsItWhenParentCannotBeOptimized": {
    "circuit": "module main(out a[2](4), out b[2](4), in c[2](4), in d[2](4), out o(4)) if (a = b) then a[0] += 4; a[1] += 2 else a[0] += 2; b[1] += 4; if (#a != #b) then a[0] += 2 else b[1] += 2 fi (#a != #b) fi (a = b); o.0 += a[0].0; o.1 += a[0].1; o.2 += a[0].2; o.3 += a[0].3; o.0 += a[1].0; o.1 += a[1].1; o.2 += a[1].2; o.3 += a[1].3; o.0 += b[0].0; o.1 += b[0].1; o.2 += b[0].2; o.3 += b[0].3; o.0 += b[1].0; o.1 += b[1].1; o.2 += b[1].2; o.3 += b[1].3",
    "expectedCircuit": "module main(out a[2](4), out b[2](4), out o(4)) if (a = b) then a[0] += 4; a[1] += 2 else a[0] += 2; b[1] += 4; b[1] += 2 fi (a = b); o.1 += a[0].1; o.2 += a[0].2; o.1 += a[1].1; o.1 += b[1].1; o.2 += b[1].2"
  },
  "testNestedIfStatementInFalseBranchOfParentIsOptimizedByOmittingFalseBranchWhenGuardConditionOfNestedIfStatementAllowsItWhenParentCannotBeOptimized": {
    "circuit": "module main(out a[2](4), out b[2](4), in c[2](4), in d[2](4), out o(4)) if (a = b) then a[0] += 4; a[1] += 2 else a[0] += 2; b[1] += 4; if (#a = #b) then a[0] += 2 else b[1] += 2 fi (#a = #b) fi (a = b); o.0 += a[0].0; o.1 += a[0].1; o.2 += a[0].2; o.3 += a[0].3; o.0 += a[1].0; o.1 += a[1].1; o.2 += a[1].2; o.3 += a[1].3; o.0 += b[0].0; o.1 += b[0].1; o.2 += b[0].2; o.3 += b[0].3; o.0 += b[1].0; o.1 += b[1].1; o.2 += b[1].2; o.3 += b[1].3",
    "expectedCircuit": "module main(out a[2](4), out b[2](4), out o(4)) if (a = b) then a[0] += 4; a[1] += 2 else a[0] += 2; b[1] += 4; a[0] += 2 fi (a = b); o.2 += a[0].2; o.1 += a[1].1; o.2 += b[1].2"
  },

  "testNestedIfStatementInTrueBranchOfParentIsOptimizedByOmittingTrueBranchWhenGuardConditionOfNestedIfStatementAllowsItWhenParentCanBeOptimizedByOmittingFalseBranch": {
    "circuit": "module main(out a[2](4), out b[2](4), in c[2](4), in d[2](4), out o(4)) if (#a = #b) then a[0] += 2; b[1] += 4; if (#a != #b) then a[0] += 2 else b[1] += 2 fi (#a != #b) else a[0] += 4; a[1] += 2 fi (#a = #b); o.0 += a[0].0; o.1 += a[0].1; o.2 += a[0].2; o.3 += a[0].3; o.0 += a[1].0; o.1 += a[1].1; o.2 += a[1].2; o.3 += a[1].3; o.0 += b[0].0; o.1 += b[0].1; o.2 += b[0].2; o.3 += b[0].3; o.0 += b[1].0; o.1 += b[1].1; o.2 += b[1].2; o.3 += b[1].3",
    "expectedCircuit": "module main(out a[2](4), out b[2](4), out o(4)) a[0] += 2; b[1] += 4; b[1] += 2; o.1 += 1; o.1 += 1; o.2 += 1"
  },
  "testNestedIfStatementInTrueBranchOfParentIsOptimizedByOmittingFalseBranchWhenGuardConditionOfNestedIfStatementAllowsItWhenParentCanBeOptimizedByOmittingFalseBranch": {
    "circuit": "module main(out a[2](4), out b[2](4), in c[2](4), in d[2](4), out o(4)) if (#a = #b) then a[0] += 2; b[1] += 4; if (#a = #b) then a[0] += 2 else b[1] += 2 fi (#a = #b) else a[0] += 4; a[1] += 2 fi (#a = #b); o.0 += a[0].0; o.1 += a[0].1; o.2 += a[0].2; o.3 += a[0].3; o.0 += a[1].0; o.1 += a[1].1; o.2 += a[1].2; o.3 += a[1].3; o.0 += b[0].0; o.1 += b[0].1; o.2 += b[0].2; o.3 += b[0].3; o.0 += b[1].0; o.1 += b[1].1; o.2 += b[1].2; o.3 += b[1].3",
    "expectedCircuit": "module main(out a[2](4), out b[2](4), out o(4)) a[0] += 2; b[1] += 4; a[0] += 2; o.2 += 1; o.2 += 1"
  },
  "testNestedIfStatementInFalseBranchOfParentIsOptimizedByOmittingTrueBranchWhenGuardConditionOfNestedIfStatementAllowsItWhenParentCanBeOptimizedByOmittingTrueBranch": {
    "circuit": "module main(out a[2](4), out b[2](4), in c[2](4), in d[2](4), out o(4)) if (#a != #b) then a[0] += 4; a[1] += 2 else a[0] += 2; b[1] += 4; if (#a != #b) then a[0] += 2 else b[1] += 2 fi (#a != #b) fi (#a != #b); o.0 += a[0].0; o.1 += a[0].1; o.2 += a[0].2; o.3 += a[0].3; o.0 += a[1].0; o.1 += a[1].1; o.2 += a[1].2; o.3 += a[1].3; o.0 += b[0].0; o.1 += b[0].1; o.2 += b[0].2; o.3 += b[0].3; o.0 += b[1].0; o.1 += b[1].1; o.2 += b[1].2; o.3 += b[1].3",
    "expectedCircuit": "module main(out a[2](4), out b[2](4), out o(4)) a[0] += 2; b[1] += 4; b[1] += 2; o.1 += 1; o.1 += 1; o.2 += 1"
  },
  "testNestedIfStatementInFalseBranchOfParentIsOptimizedByOmittingFalseBranchWhenGuardConditionOfNestedIfStatementAllowsItWhenParentCanBeOptimizedByOmittingTrueBranch": {
    "circuit": "module main(out a[2](4), out b[2](4), in c[2](4), in d[2](4), out o(4)) if (#a != #b) then a[0] += 4; a[1] += 2 else a[0] += 2; b[1] += 4; if (#a = #b) then a[0] += 2 else b[1] += 2 fi (#a = #b) fi (#a != #b); o.0 += a[0].0; o.1 += a[0].1; o.2 += a[0].2; o.3 += a[0].3; o.0 += a[1].0; o.1 += a[1].1; o.2 += a[1].2; o.3 += a[1].3; o.0 += b[0].0; o.1 += b[0].1; o.2 += b[0].2; o.3 += b[0].3; o.0 += b[1].0; o.1 += b[1].1; o.2 += b[1].2; o.3 += b[1].3",
    "expectedCircuit": "module main(out a[2](4), out b[2](4), out o(4)) a[0] += 2; b[1] += 4; a[0] += 2; o.2 += 1; o.2 += 1"
  },

  "testIfStatementWithEmptyFalseBranchAndTrueBranchMadeEmptyDueToOptimizationsIsRemovedCompletely": {
    "circuit": "module main(out a(4), in c(1), in d(1), out b(4)) if (c = d) then b += (a - (2 + (a - 2))); a -= (b * (0 + b)) else a += 0 fi (c = d)",
    "expectedCircuit": "module main() skip"
  },
  "testIfStatementWithEmptyTrueBranchAndFalseBranchMadeEmptyDueToOptimizationsIsRemovedCompletely": {
    "circuit": "module main(out a(4), in c(1), in d(1), out b(4)) if (c = d) then a += 0 else b += (a - (2 + (a - 2))); a -= (b * (0 + b)) fi (c = d)",
    "expectedCircuit": "module main() skip"
  },
  "testIfStatementWithEmptyTrueBranchThatCannotBeOmittedDueToGuardConditionWillGetSkipStatementAdded": {
    "circuit": "module main(out a(4), in c(1), in d(1)) if (c = d) then a += 0 else a.0 += c; a.1 += d fi (c = d)",
    "expectedCircuit": "module main(out a(4), in c(1), in d(1)) if (c = d) then skip else a.0 += c; a.1 += d fi (c = d)"
  },
  "testIfStatementWithEmptyFalseBranchThatCannotBeOmittedDueToGuardConditionWillGetSkipStatementAdded": {
    "circuit": "module main(out a(4), in c(1), in d(1)) if (c = d) then a.0 += c; a.1 += d else a += 0 fi (c = d)",
    "expectedCircuit": "module main(out a(4), in c(1), in d(1)) if (c = d) then a.0 += c; a.1 += d else skip fi (c = d)"
  },

  "testRemovalOfUnusedParametersOfModuleDoesNotInvalidateCallOfUnoptimizedModuleVersion": {
    "circuit": "module add(in a(4), in b(4), out c(4), out d(4), in e(4)) c += (a + b) module main(out f(4), inout e(4), in a(4), in b(4), out c(4), out d(4)) call add(a, b, c, d, e); uncall add(a, b, c, d, e)",
    "expectedCircuit": "module add(in a(4), in b(4), out c(4)) c += (a + b) module main(in a(4), in b(4), out c(4)) call add(a, b, c); uncall add(a, b, c)"
  },
  "testRemovalOfUnusedParametersOfModuleDoesNotInvalidateCallOfUnoptimizedModuleVersionAndDoesNotInvalidateValueOfParameter": {
    "circuit": "module add(in a(4), in b(4), out c(4), out d(4), in e(4)) c += (a + b) module main(in a(4), in b(4), out c(4), out d(4), inout e(4), out f[3](4)) d += 10; e += 4; call add(a, b, c, d, e); uncall add(a, b, c, d, e); f[0].0 += c.0; f[0].1 += c.1; f[0].2 += c.2; f[0].3 += c.3; f[1].0 += d.0; f[1].1 += d.1; f[1].2 += d.2; f[1].3 += d.3; f[2].0 += e.0; f[2].1 += e.1; f[2].2 += e.2; f[2].3 += e.3",
    "expectedCircuit": "module add(in a(4), in b(4), out c(4)) c += (a + b) module main(in a(4), in b(4), out c(4), out d(4), inout e(4), out f[3](4)) d += 10; e += 4; call add(a, b, c); uncall add(a, b, c); f[0].0 += c.0; f[0].1 += c.1; f[0].2 += c.2; f[0].3 += c.3; f[1].1 += 1; f[1].3 += 1; f[2].2 += 1"
  },
  "testRemovalOfUnusedParametersLeavesCallWithNoParametersAndWillBeRemoved": {
    "circuit": "module test(out a(4)) skip module main(inout a(4), out b(4)) a += 10; call test(a); uncall test(a); b.0 += a.0; b.1 += a.1; b.2 += a.2; b.3 += a.3",
    "expectedCircuit": "module main(inout a(4), out b(4)) a += 10; b.1 += 1; b.3 += 1"
  },

  "testLoopWithOnlyOneIterationAndAnExplicitLoopVariableDefinedWithoutNestedLoopsIsUnrolledAndOccurrencesOfLoopVariableCorrectlyReplaced": {
    "circuit": "module test(out a(4), out b(4), out c[3](4)) for $i = 0 to 10 step 10 do ++= a; if ($i = b) then ++= b; ++= c[$i] else skip fi ($i = b); ++= b rof; c[0].0 += a.0; c[0].1 += a.1; c[0].2 += a.2; c[0].3 += a.3; c[1].0 += b.0; c[1].1 += b.1; c[1].2 += b.2; c[1].3 += b.3; c[1] += c[2]",
    "expectedCircuit": "module test(out a(4), out b(4), out c[3](4)) ++= a; ++= b; ++= c[0]; ++= b; c[0].0 += 1; c[1].1 += 1"
  },
  "testLoopWithOnlyOneIterationAndNoLoopVariableDefinedWithoutNestedLoopsIsUnrolledAndOccurrencesOfLoopVariableCorrectlyReplaced": {
    "circuit": "module test(out a(4), out b(4), out c[2](4)) for 0 to 10 step 10 do ++= a; if (a = b) then ++= b else skip fi (a = b); ++= b rof; c[0].0 += a.0; c[0].1 += a.1; c[0].2 += a.2; c[0].3 += a.3; c[1].0 += b.0; c[1].1 += b.1; c[1].2 += b.2; c[1].3 += b.3",
    "expectedCircuit": "module test(out a(4), out b(4), out c[2](4)) ++= a; skip; ++= b; c[0].0 += 1; c[1].0 += 1"
  },
  "testNestedLoopWithOnlyOneIterationAndAnExplicitLoopVariableDefinedIsUnrolledCorrectlyWithParentLoopNotBeingUnrolled": {
    "circuit": "module test(out a(4), out b(4), out c[2](4)) for 0 to 5 step 1 do for $i = 0 to 10 step 10 do ++= a; if ($i = b) then ++= b else skip fi ($i = b); ++= b rof rof; c[0].0 += a.0; c[0].1 += a.1; c[0].2 += a.2; c[0].3 += a.3; c[1].0 += b.0; c[1].1 += b.1; c[1].2 += b.2; c[1].3 += b.3",
    "expectedCircuit": "module test(out a(4), out b(4), out c[2](4)) for 0 to 5 step 1 do ++= a; if (0 = b) then ++= b else skip fi (0 = b); ++= b rof; c[0].0 += a.0; c[0].1 += a.1; c[0].2 += a.2; c[0].3 += a.3; c[1].0 += b.0; c[1].1 += b.1; c[1].2 += b.2; c[1].3 += b.3",
    "optimizations": {
      "loopUnrollMaxUnrollCnt": "1",
      "loopUnrollAllowRemainderON": "0"
    }
  },
  "testNestedLoopWithOnlyOneIterationAndNoLoopVariableDefinedIsUnrolledCorrectlyWithParentLoopNotBeingUnrolled": {
    "circuit": "module test(out a(4), out b(4), out c[2](4)) for $j = 0 to 5 step 1 do for 0 to 10 step 10 do ++= a; if (a = b) then ++= b else skip fi (a = b); ++= b rof rof; c[0].0 += a.0; c[0].1 += a.1; c[0].2 += a.2; c[0].3 += a.3; c[1].0 += b.0; c[1].1 += b.1; c[1].2 += b.2; c[1].3 += b.3",
    "expectedCircuit": "module test(out a(4), out b(4), out c[2](4)) for $j = 0 to 5 step 1 do ++= a; if (a = b) then ++= b else skip fi (a = b); ++= b rof; c[0].0 += a.0; c[0].1 += a.1; c[0].2 += a.2; c[0].3 += a.3; c[1].0 += b.0; c[1].1 += b.1; c[1].2 += b.2; c[1].3 += b.3",
    "optimizations": {
      "loopUnrollMaxUnrollCnt": "1",
      "loopUnrollAllowRemainderON": "0"
    }
  },
  "testNestedLoopWithOnlyOneIterationWithoutLopVariableCorrectlyUnrolledIfParentIsAlsoUnrolledWithParentDefiningLoopVariable": {
    "circuit": "module test(out a(4), out b(4), out c[2](4)) for $j = 0 to 5 step 5 do for 0 to 10 step 10 do ++= a; if ($j = b) then ++= b else skip fi ($j = b); ++= b rof rof; c[0].0 += a.0; c[0].1 += a.1; c[0].2 += a.2; c[0].3 += a.3; c[1].0 += b.0; c[1].1 += b.1; c[1].2 += b.2; c[1].3 += b.3",
    "expectedCircuit": "module test(out a(4), out b(4), out c[2](4)) ++= a; ++= b; ++= b; c[0].0 += 1; c[1].1 += 1"
  },
  "testNestedLoopWithOnlyOneIterationAndLoopVariableCorrectlyUnrolledIfParentIsAlsoUnrolledWithParentDefiningNoVariable": {
    "circuit": "module test(out a(4), out b(4), out c[2](4)) for 0 to 5 step 5 do for $j = 0 to 10 step 10 do ++= a; if ($j = b) then ++= b else skip fi ($j = b); ++= b rof rof; c[0].0 += a.0; c[0].1 += a.1; c[0].2 += a.2; c[0].3 += a.3; c[1].0 += b.0; c[1].1 += b.1; c[1].2 += b.2; c[1].3 += b.3",
    "expectedCircuit": "module test(out a(4), out b(4), out c[2](4)) ++= a; ++= b; ++= b; c[0].0 += 1; c[1].1 += 1"
  },
  "testNestedLoopWithOnlyOneIterationAndLoopVariableCorrectlyUnrolledIfParentIsAlsoUnrolledWithBothDefiningALoopVariable": {
    "circuit": "module test(out a(4), out b(4), out c[2](4)) for $i = 0 to 5 step 5 do for $j = 0 to 10 step 10 do ++= a; if ($j = $i) then ++= b else skip fi ($j = $i); ++= b rof rof; c[0].0 += a.0; c[0].1 += a.1; c[0].2 += a.2; c[0].3 += a.3; c[1].0 += b.0; c[1].1 += b.1; c[1].2 += b.2; c[1].3 += b.3",
    "expectedCircuit": "module test(out a(4), out b(4), out c[2](4)) ++= a; ++= b; ++= b; c[0].0 += 1; c[1].1 += 1"
  },
  "testLoopVariableOccurrencesCorrectlyReplacedInAssignmentStatementIfLoopIsUnrolled": {
    "circuit": "module forloop(in op(1), out c[2](4), inout a[2](4), inout b[2](4)) for $i = 0 to 1 do c[$i] ^= (a[$i] + b[$i]) rof",
    "expectedCircuit": "module forloop(in op(1), out c[2](4), inout a[2](4), inout b[2](4)) c[0] ^= (a[0] + b[0])"
  },
  "testLoopUnrollIsRevertedIfConstantPropagationIsDisabledWhenUnrollingNestedLoopThatDefinesLoopVariable": {
    "circuit": "module test(out a(4), out b(4), out c[2](4)) for $j = 0 to 5 step 1 do for $i = 0 to 10 step 10 do ++= a; if (a = b) then ++= b else skip fi (a = b); ++= b rof rof; c[0].0 += a.0; c[0].1 += a.1; c[0].2 += a.2; c[0].3 += a.3; c[1].0 += b.0; c[1].1 += b.1; c[1].2 += b.2; c[1].3 += b.3",
    "optimizations": {
      "constantPropON": "0",
      "loopUnrollMaxUnrollCnt": "1",
      "loopUnrollAllowRemainderON": "0"
    }
  },
  "testLoopUnrollIsRevertedIfConstantPropagationIsDisabledWhenUnrollingParentLoopThatDefinesLoopVariable": {
    "circuit": "module test(out a(4), out b(4), out c[2](4)) for $j = 0 to 5 step 5 do for 0 to 10 step 1 do ++= a; if (a = b) then ++= b else skip fi (a = b); ++= b rof rof; c[0].0 += a.0; c[0].1 += a.1; c[0].2 += a.2; c[0].3 += a.3; c[1].0 += b.0; c[1].1 += b.1; c[1].2 += b.2; c[1].3 += b.3",
    "optimizations": {
      "constantPropON": "0",
      "loopUnrollMaxUnrollCnt": "1",
      "loopUnrollAllowRemainderON": "0"
    }
  },
  "testLoopUnrollingIsNotReveredIfConstantPropagationIsDisabledWhenUnrollingNestedAndParentLoopWithoutLoopVariables": {
    "circuit": "module test(out a(4), out b(4), out c[2](4)) for $j = 0 to 5 step 5 do for 0 to 10 step 1 do ++= a; if (a = b) then ++= b else skip fi (a = b); ++= b rof rof; c[0].0 += a.0; c[0].1 += a.1; c[0].2 += a.2; c[0].3 += a.3; c[1].0 += b.0; c[1].1 += b.1; c[1].2 += b.2; c[1].3 += b.3",
    "optimizations": {
      "constantPropON": "0",
      "loopUnrollMaxUnrollCnt": "1",
      "loopUnrollAllowRemainderON": "0"
    }
  },
  "testLoopUnrollingIsNotReveredIfConstantPropagationIsDisabledWhenUnrollingParentLoopThatDoesNotDefinedLoopVariable": {
    "circuit":          "module test(out a(4), out b(4), out c[2](4)) for 5 step 5 do for $i = 0 to 10 step 1 do ++= a; if ($j = $i) then ++= b else skip fi ($j = $i); ++= b rof rof; c[0].0 += a.0; c[0].1 += a.1; c[0].2 += a.2; c[0].3 += a.3; c[1].0 += b.0; c[1].1 += b.1; c[1].2 += b.2; c[1].3 += b.3",
    "expectedCircuit":  "module test(out a(4), out b(4), out c[2](4)) for $i = 0 to 10 step 1 do ++= a; if ($j = $i) then ++= b else skip fi ($j = $i); ++= b rof; c[0].0 += a.0; c[0].1 += a.1; c[0].2 += a.2; c[0].3 += a.3; c[1].0 += b.0; c[1].1 += b.1; c[1].2 += b.2; c[1].3 += b.3",
    "optimizations": {
      "constantPropON": "0",
      "loopUnrollMaxUnrollCnt": "1",
      "loopUnrollAllowRemainderON": "0"
    }
  },
  "testLoopUnrollingIsNotReveredIfConstantPropagationIsDisabledWhenUnrollingNestedLoopThatDoesNotDefinedLoopVariable": {
    "circuit": "module test(out a(4), out b(4), out c[2](4)) for $j = 0 to 5 step 1 do for 0 to 10 step 10 do ++= a; if (a = b) then ++= b else skip fi (a = b); ++= b rof rof; c[0].0 += a.0; c[0].1 += a.1; c[0].2 += a.2; c[0].3 += a.3; c[1].0 += b.0; c[1].1 += b.1; c[1].2 += b.2; c[1].3 += b.3",
    "expectedCircuit": "module test(out a(4), out b(4), out c[2](4)) for $j = 0 to 5 step 1 do ++= a; if (a = b) then ++= b else skip fi (a = b); ++= b rof; c[0].0 += a.0; c[0].1 += a.1; c[0].2 += a.2; c[0].3 += a.3; c[1].0 += b.0; c[1].1 += b.1; c[1].2 += b.2; c[1].3 += b.3",
    "optimizations": {
      "constantPropON": "0",
      "loopUnrollMaxUnrollCnt": "1",
      "loopUnrollAllowRemainderON": "0"
    }
  },
  "moduleWithReadonlyParametersAsWellAsCallsRemoved": {
    "circuit": "module add(in a(4), in b(4)) wire c(4) c += (a + b) module main(in a(4), in b(4), out c(4)) call add(a, b); uncall add(a, b)",
    "expectedCircuit": "module main() skip",
    "optimizations": {
      "deadCodeElimON": "1",
      "deadStoreElimON": "1"
    }
  },
  "moduleConsistingOnlyOfSkipStatementRemoved": {
    "circuit": "module add(in a(4), in b(4)) skip module main(in a(4), in b(4), out c(4)) call add(a, b); uncall add(a, b)",
    "expectedCircuit": "module main() skip",
    "optimizations": {
      "deadCodeElimON": "1",
      "deadStoreElimON": "1"
    }
  },
  "moduleOptimizedToHaveNoSideEffectsButDeclaredOtherwiseRemoved": {
    "circuit": "module add(in a(4), in b(4), out c(4)) wire d(4) d += (a + b) module main(in a(4), in b(4), out c(4)) call add(a, b, c); uncall add(a, b, c)",
    "expectedCircuit": "module main() skip",
    "optimizations": {
      "deadCodeElimON": "1",
      "deadStoreElimON": "1"
    }
  }
}