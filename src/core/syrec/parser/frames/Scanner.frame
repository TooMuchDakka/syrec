/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/

/*----------------------------------------------------------------------
Scanner.h Specification
-----------------------------------------------------------------------*/

-->begin

#if !defined(-->prefixCOCO_SCANNER_H__)
#define -->prefixCOCO_SCANNER_H__

#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <memory>
#include <string>
#include <string_view>
#include <vector>

// io.h and fcntl are used to ensure binary read from streams on windows
#if _MSC_VER >= 1300
#include <io.h>
#include <fcntl.h>
#endif

#if _MSC_VER >= 1400
#define coco_swprintf swprintf_s
#elif _MSC_VER >= 1300
#define coco_swprintf _snwprintf
#elif defined __MINGW32__
#define coco_swprintf _snwprintf
#else
// assume every other compiler knows swprintf
#define coco_swprintf swprintf
#endif

#define COCO_WCHAR_MAX 65535
#define COCO_MIN_BUFFER_LENGTH 1024
#define COCO_MAX_BUFFER_LENGTH (64*COCO_MIN_BUFFER_LENGTH)
#define COCO_CPP_NAMESPACE_SEPARATOR L':'

-->namespace_open

unsigned int hashString(const std::string_view& stringToHash);

std::string createFrom(const wchar_t *value);
wchar_t* coco_string_create(const std::string& data, size_t startPositionInData, size_t numBytesToCopy);
std::string coco_string_create(const wchar_t *value);

void coco_string_delete(wchar_t* &value);

// TODO:
/*
#if _MSC_VER
std::wstring widen(const std::string& str) {
	return L"";
}
#endif
*/

// TODO: Check where shared pointers can be replaced with unique ones 

class Token  
{
public:
	int kind;     // token kind
	size_t pos;      // token position in bytes in the source text (starting at 0)
	size_t charPos;  // token position in characters in the source text (starting at 0)
	size_t col;      // token column (starting at 1)
	size_t line;     // token line (starting at 1)
	std::string val; // token value

	// TODO: Can be unique ptr ?
	std::shared_ptr<Token> next;  // ML 2005-03-11 Peek peekedTokens are kept in linked list

	Token();
	~Token() = default;
};

class Buffer {
// This Buffer supports the following cases:
// 1) seekable stream (file)
//    a) whole stream in buffer
//    b) part of stream in buffer
// 2) non seekable stream (network, console)
private:
	std::vector<unsigned char> buf; // input buffer
	size_t bufStart;       // position of first byte in buffer relative to input stream
	size_t fileLen;        // length of input stream (may change if the stream is no file)
	size_t bufPos;         // current position in buffer
	FILE* stream;       // input stream (seekable)
	bool isUserStream;  // was the stream opened by the user?
	
	int ReadNextStreamChunk();
	bool CanSeek();     // true if stream can be seeked otherwise false
	
public:
	static const int EoF = COCO_WCHAR_MAX + 1;

	Buffer(FILE* s, bool isUserStream);
	Buffer(const unsigned char* buf, size_t len);
	Buffer(Buffer* buffer);
	virtual ~Buffer();
	
	virtual void Close();
	virtual int Read();
	virtual int Peek();
	virtual size_t GetPos();
	virtual void SetPos(size_t position);
};

class UTF8Buffer : public Buffer {
public:
	UTF8Buffer(Buffer* buffer) : Buffer(buffer) {};
	virtual int Read();
};

//-----------------------------------------------------------------------------------
// StartStates  -- maps characters to start states of peekedTokens
//-----------------------------------------------------------------------------------
class StartStates {
private:
	class Elem {
	public:
		int key, val;
		std::shared_ptr<Elem> next;

		Elem(int key, int val) { 
			this->key = key;
			this->val = val;
			next = nullptr; 
		}
	};

	const size_t numBuckets = 128;
	std::vector<std::shared_ptr<Elem>> tab;

	size_t getBucketForKey(int key) const {
		return ((unsigned int) key) % numBuckets;
	}

public:
	StartStates() : tab(numBuckets, nullptr) { }
	~StartStates() = default;

	void set(int key, int val) {
		const size_t bucketKey = getBucketForKey(key);
		std::shared_ptr<Elem> newTabEntry = std::make_shared<Elem>(key, val);
		newTabEntry->next = tab[bucketKey];
		tab[bucketKey] = newTabEntry;
	}

	int state(int key) {
		std::shared_ptr<Elem> tabEntry = tab[getBucketForKey(key)];
		while (tabEntry != nullptr && tabEntry->key != key) {
			tabEntry = tabEntry->next;
		}

		return tabEntry == nullptr ? 0 : tabEntry->val;
	}
};

//-------------------------------------------------------------------------------------------
// KeywordMap  -- maps strings to integers (identifiers to keyword kinds)
//-------------------------------------------------------------------------------------------
class KeywordMap {
private:
	class Elem {
	public:
		std::string key;
		int val;
		Elem *next;
		Elem(const std::string& key, int val) { this->key = key; this->val = val; next = NULL; }
		virtual ~Elem() {}
	};

	Elem **tab;

public:
	KeywordMap() { tab = new Elem*[128]; memset(tab, 0, 128 * sizeof(Elem*)); }
	virtual ~KeywordMap() {
		for (int i = 0; i < 128; ++i) {
			Elem *e = tab[i];
			while (e != NULL) {
				Elem *next = e->next;
				delete e;
				e = next;
			}
		}
		delete [] tab;
	}

	void set(const wchar_t *key, int val) {
		Elem *e = new Elem(coco_string_create(key), val);
		int k = hashString(coco_string_create(key)) % 128;
		e->next = tab[k]; tab[k] = e;
	}

	int get(const wchar_t *key, int defaultVal) {
		Elem *e = tab[hashString(coco_string_create(key)) % 128];
		// TODO: 
		while (e != NULL && !(std::wstring(e->key.begin(), e->key.end()) == key)) e = e->next;
		return e == NULL ? defaultVal : e->val;
	}
};

class Scanner {
private:
	unsigned char EOL;
	int eofSym;
	int noSym;
	int maxT;
	int charSetSize;
	StartStates start;
	KeywordMap keywords;

	std::shared_ptr<Token> t;         // current token
	std::string tval; // text of current token
	std::size_t tvalLength;   // length of text of current token
	std::size_t tlen;         // length of current token

	std::shared_ptr<Token> peekedTokens;    // list of peekedTokens already peeked (first token is a dummy)
	std::shared_ptr<Token> currPeekedToken;        // current peek token

	int ch;           // current input character
-->casing0
	size_t pos;          // byte position of current character
	size_t charPos;      // position by unicode characters starting with 0
	size_t line;         // line number of current character
	size_t col;          // column number of current character
	int oldEols;      // EOLs that appeared in a comment;

	std::shared_ptr<Token> CreateToken() const;
	void SetScannerBehindT();

	void Init();
	void NextCh();
	void AddCh();
-->commentsheader
	std::shared_ptr<Token> NextToken();

public:
	std::unique_ptr<Buffer> buffer; // Scanner buffer
	
	Scanner(const unsigned char* buf, size_t bufferSize);
	Scanner(const std::string& fileName);
	Scanner(FILE* s);
	~Scanner() = default;
	std::shared_ptr<Token> Scan();
	std::shared_ptr<Token> Peek();
	void ResetPeek();

}; // end Scanner

-->namespace_close

#endif

-->implementation

/*----------------------------------------------------------------------
Scanner.cpp Specification
-----------------------------------------------------------------------*/

-->begin

#include <memory.h>
#include <string.h>
#include "core/syrec/parser/Scanner.h"

-->namespace_open


// string handling, wide character

// TODO:
static unsigned int hashString(const std::string_view& stringToHash) {
	if (stringToHash.empty()) {
        return 0;   
    }

	unsigned int h = 0;
	for (const char& character: stringToHash) {
        if (character == 0) {
            break;
        }
        h = (h * 7) ^ character;
	}
    return h;
}

// TODO:
static std::string coco_string_create(const wchar_t* data) {
	const std::wstring wide_text_as_string(data);
    const std::size_t        size_of_wide_text = wide_text_as_string.size();

    if (size_of_wide_text == 0 || size_of_wide_text == SIZE_MAX) {
        return "";
    }

    char*             test_1 = new char[size_of_wide_text + 1];
    std::size_t       num_characters_converted;
        
    if (!wcstombs_s(&num_characters_converted, test_1, size_of_wide_text + 1, data, size_of_wide_text)) {
        return test_1;
    } else {
        return "";
    }
	return "";
}

// TODO:
wchar_t* coco_string_create(const std::string& data, size_t startPositionInData, size_t numBytesToCopy) {
    std::wstring wString   = std::wstring(data.begin(), data.end());
    wchar_t*     wideStringBuffer = new wchar_t[data.size()];

    wcsncpy(wideStringBuffer, &wString[startPositionInData], numBytesToCopy);
    return wideStringBuffer;
}

void coco_string_delete(wchar_t* &data) {
	delete [] data;
	data = NULL;
}

Token::Token() {
	kind = 0;
	pos  = 0;
	col  = 0;
	line = 0;
	val  = "";
	next = nullptr;
}

Buffer::Buffer(FILE* s, bool isUserStream) {
// ensure binary read on windows
#if _MSC_VER >= 1300
	_setmode(_fileno(s), _O_BINARY);
#endif
	stream = s; 
	this->isUserStream = isUserStream;
	size_t initialBufferLength = COCO_MIN_BUFFER_LENGTH;
	bufStart = 0;
	fileLen = 0;

	if (CanSeek()) {
		fseek(s, 0, SEEK_END);
		fileLen = ftell(s);
		fseek(s, 0, SEEK_SET);
		initialBufferLength = (fileLen < COCO_MAX_BUFFER_LENGTH) ? fileLen : COCO_MAX_BUFFER_LENGTH;
		bufStart = INT_MAX; // nothing in the buffer so far
	}

	buf.resize(initialBufferLength);
	if (fileLen > 0) 
		SetPos(0);          // setup  buffer to position 0 (start)
	else 
		bufPos = 0; // index 0 is already after the file, thus Pos = 0 is invalid

	if (initialBufferLength == fileLen && CanSeek()) 
		Close();
}

Buffer::Buffer(Buffer* buffer) {
	buf = buffer->buf;
	bufStart = buffer->bufStart;
	fileLen = buffer->fileLen;
	bufPos = buffer->bufPos;
	stream = buffer->stream;
	buffer->stream = nullptr;
	isUserStream = buffer->isUserStream;
}

Buffer::Buffer(const unsigned char* buf, size_t len) {
	this->buf.insert(this->buf.end(), buf, buf+len);
	bufStart = 0;
	fileLen = len;
	bufPos = 0;
	stream = nullptr;
}

Buffer::~Buffer() {
	Close(); 
}

void Buffer::Close() {
	if (!isUserStream && stream != NULL) {
		fclose(stream);
		stream = NULL;
	}
}

int Buffer::Read() {
	if (bufPos < this->buf.size()) {
		return buf[bufPos++];
	} else if (GetPos() < fileLen) {
		SetPos(GetPos()); // shift buffer start to Pos
		return buf[bufPos++];
	} else if ((stream != NULL) && !CanSeek() && (ReadNextStreamChunk() > 0)) {
		return buf[bufPos++];
	} else {
		return EoF;
	}
}

int Buffer::Peek() {
	size_t curPos = GetPos();
	int ch = Read();
	SetPos(curPos);
	return ch;
}

size_t Buffer::GetPos() {
	return bufPos + bufStart;
}

void Buffer::SetPos(size_t position) {
	if ((position >= fileLen) && (stream != NULL) && !CanSeek()) {
		// Wanted position is after buffer and the stream
		// is not seek-able e.g. network or console,
		// thus we have to read the stream manually till
		// the wanted position is in sight.
		while ((position >= fileLen) && (ReadNextStreamChunk() > 0));
	}

	if ((position < 0) || (position > fileLen)) {
		wprintf(L"--- buffer out of bounds access, position: %d\n", position);
		exit(1);
	}

	if ((position >= bufStart) && (position < (bufStart + this->buf.size()))) { // already in buffer
		bufPos = position - bufStart;
	} else if (stream != NULL) { // must be swapped in
		if (std::fseek(stream, position ,SEEK_SET)){
			wprintf(L"--- coult not seek to position %d\n", position);
			exit(1);
		}

		std::fread(&this->buf, sizeof this->buf[0], this->buf.capacity(), stream);
		bufStart = position;
		bufPos = 0;
	} else {
		bufPos = fileLen - bufStart; // make Pos return fileLen
	}
}

// Read the next chunk of bytes from the stream, increases the buffer
// if needed and updates the fields fileLen and bufLen.
// Returns the number of bytes read.
int Buffer::ReadNextStreamChunk() {
	size_t free = this->buf.capacity() - this->buf.size();
	if (free == 0) {
		// in the case of a growing input stream
		// we can neither seek in the stream, nor can we
		// foresee the maximum length, thus we must adapt
		// the buffer size on demand.
		this->buf.reserve(this->buf.size() * 2);
		free = this->buf.size() >> 1;
	}

	size_t numBytesRead = std::fread(&this->buf + this->buf.size(), sizeof this->buf[0], free, stream);
	if (numBytesRead > 0) 
		fileLen = this->buf.size();

	return numBytesRead;
}

bool Buffer::CanSeek() {
	return (stream != NULL) && (ftell(stream) != -1);
}

int UTF8Buffer::Read() {
	int ch;
	do {
		ch = Buffer::Read();
		// until we find a utf8 start (0xxxxxxx or 11xxxxxx)
	} while ((ch >= 128) && ((ch & 0xC0) != 0xC0) && (ch != EoF));
	if (ch < 128 || ch == EoF) {
		// nothing to do, first 127 chars are the same in ascii and utf8
		// 0xxxxxxx or end of file character
	} else if ((ch & 0xF0) == 0xF0) {
		// 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
		int c1 = ch & 0x07; ch = Buffer::Read();
		int c2 = ch & 0x3F; ch = Buffer::Read();
		int c3 = ch & 0x3F; ch = Buffer::Read();
		int c4 = ch & 0x3F;
		ch = (((((c1 << 6) | c2) << 6) | c3) << 6) | c4;
	} else if ((ch & 0xE0) == 0xE0) {
		// 1110xxxx 10xxxxxx 10xxxxxx
		int c1 = ch & 0x0F; ch = Buffer::Read();
		int c2 = ch & 0x3F; ch = Buffer::Read();
		int c3 = ch & 0x3F;
		ch = (((c1 << 6) | c2) << 6) | c3;
	} else if ((ch & 0xC0) == 0xC0) {
		// 110xxxxx 10xxxxxx
		int c1 = ch & 0x1F; ch = Buffer::Read();
		int c2 = ch & 0x3F;
		ch = (c1 << 6) | c2;
	}
	return ch;
}

Scanner::Scanner(const unsigned char* buf, size_t len) {
	buffer = std::make_unique<Buffer>(buf, len);
	Init();
}

Scanner::Scanner(const std::string& fileName) {
	/*
	FILE* stream;
	// TODO: https://stackoverflow.com/questions/5850358/is-there-a-preprocessor-define-that-is-defined-if-the-compiler-is-msvc
	#if _MSC_VER
		stream = fopen(widen(fileName, "rb"));
	#else
		stream = fopen(fileName, "rb");
	#endif
	*/

	FILE* stream = fopen(fileName.c_str(), "rb");
	if (!stream) {
		// TODO:
		//wprintf(L"--- Cannot open file %s\n", fileName);
		exit(1);
	}
	buffer = std::make_unique<Buffer>(stream, false);
	Init();
}

Scanner::Scanner(FILE* s) {
	buffer = std::make_unique<Buffer>(s, true);
	Init();
}

void Scanner::Init() {
	EOL    = '\n';
	eofSym = 0;
-->declarations

	tvalLength = 128;
	tval.assign("", tvalLength);

	// TODO:
	//pos = -1; line = 1; col = 0; charPos = -1;
	pos = 0; 
	line = 1;
	col = 0;
	charPos = 0;

	oldEols = 0;
	NextCh();
	if (ch == 0xEF) { // check optional byte order mark for UTF-8
		NextCh(); int ch1 = ch;
		NextCh(); int ch2 = ch;
		if (ch1 != 0xBB || ch2 != 0xBF) {
			wprintf(L"Illegal byte order mark at start of file");
			exit(1);
		}

		// TODO: Rework ugly &* parameter
		buffer = std::make_unique<UTF8Buffer>(&*buffer);
		col = 0;

		// TODO:
		//charPos = -1;
		charPos = 0;
		NextCh();
	}

-->initialization
	currPeekedToken = peekedTokens = CreateToken(); // first token is a dummy
}

void Scanner::NextCh() {
	if (oldEols > 0) { ch = EOL; oldEols--; }
	else {
		pos = buffer->GetPos();
		// buffer reads unicode chars, if UTF8 has been detected
		ch = buffer->Read(); col++; charPos++;
		// replace isolated '\r' by '\n' in order to make
		// eol handling uniform across Windows, Unix and Mac
		if (ch == L'\r' && buffer->Peek() != L'\n') ch = EOL;
		if (ch == EOL) { line++; col = 0; }
	}
-->casing1
}

void Scanner::AddCh() {
	if (tlen >= tvalLength) {
		tvalLength *= 2;
		tval.resize(tvalLength);
	}
	if (ch != Buffer::EoF) {
		/*
-->casing2
		*/
		// TODO:
		tval[tlen++] = static_cast<char>(ch);
		NextCh();
	}
}

-->comments

std::shared_ptr<Token> Scanner::CreateToken() const {
	auto token = std::make_shared<Token>();
	token->val = "";
	token->next = nullptr;
	return token;
}

std::shared_ptr<Token> Scanner::NextToken() {
	while (ch == ' ' ||
-->scan1
	) NextCh();
-->scan2
	int recKind = noSym;
	int recEnd = pos;

	t = CreateToken();
	t->pos = pos; t->col = col; t->line = line; t->charPos = charPos;
	int state = start.state(ch);
	tlen = 0; AddCh();

	switch (state) {
		case -1: { t->kind = eofSym; break; } // NextCh already done
		case 0: {
			case_0:
			if (recKind != noSym) {
				tlen = recEnd - t->pos;
				SetScannerBehindT();
			}
			t->kind = recKind; break;
		} // NextCh already done
-->scan3
	}

	t->val.append(tval);
	return t;
}

void Scanner::SetScannerBehindT() {
	buffer->SetPos(t->pos);
	NextCh();
	line = t->line; col = t->col; charPos = t->charPos;
	for (int i = 0; i < tlen; i++) NextCh();
}

// get the next token (possibly a token already seen during peeking)
std::shared_ptr<Token> Scanner::Scan() {
	if (peekedTokens->next == nullptr) {
		return currPeekedToken = peekedTokens = NextToken();
	} else {
		currPeekedToken = peekedTokens = peekedTokens->next;
		return peekedTokens;
	}
}

// peek for the next token, ignore pragmas
std::shared_ptr<Token> Scanner::Peek() {
	do {
		if (currPeekedToken->next == nullptr) {
			currPeekedToken->next = NextToken();
		}
		currPeekedToken = currPeekedToken->next;
	} while (currPeekedToken->kind > maxT); // skip pragmas

	return currPeekedToken;
}

// make sure that peeking starts at the current scan position
void Scanner::ResetPeek() {
	currPeekedToken = peekedTokens;
}

-->namespace_close
