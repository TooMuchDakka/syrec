#include "core/syrec/parser/optimizations/noAdditionalLineSynthesis/assignment_without_additional_lines_simplifier.hpp"
#include "core/syrec/parser/utils/copy_utils.hpp"
#include "core/syrec/parser/utils/signal_access_utils.hpp"

#ifndef NDEBUG
#include "fmt/format.h"
#endif


/*
 * TODO: IMPORTANT (testcase simplificationWithOnlyReversibleOpsAndUniqueSignalAccessesWithTopmostAssignmentBeingXorCorrectlyHandlesMixedOperationsInRhsExpr) is missing required inversion of assignments
 *
 * TODO: Add as a precondition that no signal accesses overlapping the lhs operand of the initial assignment exists on the rhs which should already be done by the caller but a safety to prevent invalid assignments generated by this simplifier
 * TODO: When inverting all active assignments during processing of operation node, we should not "deactivated" active assignments that operate on the same signal as the chosen one in the operation node - IMPORTANT
 * TODO: Are active assignments added to set determining conflicts
 * TODO: If a decision was prevented by learned conflict the generated expr could be further simplified in the parent operation node (i.e. b += (d - 2) was created when the learned conflict was d and could be simplified to b += d; b -= 2)
 *
 * TODO: If original rhs expr does only consist of invertible operations (with xor only defined for leaf nodes) fallback to expression split
 * TODO: Shift expressions are currently not handled since the shift amount is a number::ptr instead of an expression::ptr
 *
 *
 * TODO: When we are trying to create an assignment in an operation node with either only one leaf node or no leaf nodes (we need to check for the choosen assigned to signal whether the rhs expression does not contain said signal [same semantic check is perform for assignments that are passed into this function])
 *
 * TODO: Currently we have a problem to fine a correct metric to decide whether we should perform our "simple" or "complex" simplification algorithm if the assignment only contains reversible operations (its a problem since the "complex" algorithm leads to a larger code size due to a larger number of assignments being created)
 * TODO: IMPORTANT: When a conflict arises we should only remember the conflict at the earliest node to not prevent the reuse of assignment that could lead to conflicts but are "defused" by an assignment higher in the traversal queue
 * TODO: NICE-TO-HAVE: Try to perform constant propagation and further optimizations if value of any signal changes during simplifications
 *
 * TODO: Reordering sequences of assignment statements could lead to further optimization potential, see test case simplificationWithOnlyReversibleOpsAndUniqueSignalAccessHandlesRhsCorrectlyIfRhsCreatesNoAssignmentAndAssignmentOperationIsXorAndTopmostOperationOfRhsIsMinusAndAssignedtoSignalValueIsNotZero
 * TODO: Could the simplification (a - (b + c)) = (a - (c - b)) lead to further optimizations?
 *
 * TODO: Some cases could offer new optimizations: module main(out a(16), inout b(16), in c(16), in d(16)) a += (((b - c) + b) * d) [see simplification of previous point])
 *
 * TODO: IMPORTANT - When processing a rhs of an expression we cannot use any operand use in the lhs expr (how can we do this efficiently, does this check need to be done everytime)
 * TODO: IMPORTANT - Check whether we need to add additional tests for the the tie breaker flag is not specified and the simplified assignments of the original assignment cost less than the simplified ones
 * TODO: IMPORTANT - Check the metric chosen for the weighting, if our topmost expression has a nesting level of two but the simplified ones only have a nesting level of 1 but the latter is inverted once
 * (i.e.) a += ((b + c) + d) being the topmost assignment while the simplified ones are d += (b + c); a ^= d; d -= (b + c). [Also add tests for this]
 * TODO: IMPORTANT - The split of an simplified assignment (i.e. a -= (b + 2)) at the topmost level leads to the sequence a -= b; a -= 2 ... a += b; a += 2
 *  if the split would take place immediately after the creation of the assignment would lead to the sequence a += b; a += 2 ... a -= b; a -= 2
 *
 * TODO: Testcase 'simplifyWithOnlyReversibleOpsButNonUniqueSignalAccessWithAssignOperationBeingAdditionWithDegeneratedLhsSubASTOfLhsOfAssignmentExpr' is an example where the heuristic optimization of - (<subExpr_1> - <subExpr_2>) leads to a worse result
 */

// TODO: CHECK TEST simplificationWithNoneReversibleOperationWithXorAssignOperationAndTopmostOperationOfRhsBeingAdditionOperationWithLhsGeneratingAssignmentAndRhsGeneratingAssignmentCreatesCorrectAssignment FOR FAILED ROLLBACK
noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::SimplificationResultReference noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::simplify(const syrec::AssignStatement& assignmentStatement, const SignalValueLookupCallback& signalValueLookupCallback) {
    resetInternals();
    // TODO: For a binary expression with no nested expressions as operands, should we prefer that a signal access is always the lhs operand
    const std::shared_ptr<syrec::AssignStatement> transformedAssignmentStmt = transformAssignmentPriorToSimplification(assignmentStatement, true);
    if (!transformedAssignmentStmt) {
        SimplificationResultReference simplificationResult = std::make_unique<SimplificationResult>(SimplificationResult{generatedAssignmentsContainer->getAssignments()});
        return simplificationResult;
    }

    expressionTraversalHelper->buildTraversalQueue(transformedAssignmentStmt->rhs, *symbolTableReference);
    disableValueLookup();
    
    bool                                                               continueProcessingOperationNode = true;
    std::optional<OwningOperationOperandSimplificationResultReference> simplificationResultOfTopmostOperationNode;
    while (continueProcessingOperationNode) {
        std::optional<ExpressionTraversalHelper::OperationNodeReference> topMostOperationNode = expressionTraversalHelper->getNextOperationNode();

        // TODO: If an expression is created for the rhs we can still try to split it if a binary operation with an assignment counterpart exists
        simplificationResultOfTopmostOperationNode = topMostOperationNode.has_value() ? handleOperationNode(*topMostOperationNode, signalValueLookupCallback) : std::nullopt;
        if (shouldBacktrackDueToConflict()) {
            markSourceOfConflictReached();
            backtrack(topMostOperationNode->get()->id, false);
        } else {
            continueProcessingOperationNode = !simplificationResultOfTopmostOperationNode.has_value();
        }
    }

    if (simplificationResultOfTopmostOperationNode.has_value()) {
        const auto& generatedExprForTopmostOperationRhsExpr = simplificationResultOfTopmostOperationNode->get()->getGeneratedExpr();
        const auto& generatedLastAssignedToSignalOfRhsExpr  = simplificationResultOfTopmostOperationNode->get()->getAssignedToSignalOfAssignment();

        syrec::VariableAccess::ptr generatedAssignmentAssignedToSignal = transformedAssignmentStmt->lhs;
        syrec::expression::ptr     generatedAssignmentRhsExpr;
        if (generatedLastAssignedToSignalOfRhsExpr.has_value()) {
            generatedAssignmentRhsExpr = std::make_shared<syrec::VariableExpression>(*generatedLastAssignedToSignalOfRhsExpr);
        } else {
            generatedAssignmentRhsExpr = *generatedExprForTopmostOperationRhsExpr;
        }

        const syrec::AssignStatement::ptr generatedAssignment = std::make_shared<syrec::AssignStatement>(
                generatedAssignmentAssignedToSignal,
                transformedAssignmentStmt->op,
                generatedAssignmentRhsExpr);
        const std::size_t currentNumberOfExistingAssignments = generatedAssignmentsContainer->getNumberOfAssignments();
        generatedAssignmentsContainer->storeActiveAssignment(generatedAssignment);
        const std::size_t numberOfAssignmentsToNotInvertStartingFromLastCreatedOne = generatedAssignmentsContainer->getNumberOfAssignments() - currentNumberOfExistingAssignments;
        generatedAssignmentsContainer->invertAllAssignmentsUpToLastCutoff(numberOfAssignmentsToNotInvertStartingFromLastCreatedOne, nullptr);
    }

    bool                        wasAnyAssignmentGeneratedDuringProcessing = true;
    syrec::AssignStatement::vec generatedAssignments;
    if (!generatedAssignmentsContainer->getNumberOfAssignments()) {
        if (const std::shared_ptr<syrec::AssignStatement> topMostAssignmentStmtIfNoOptimizationTookPlace = transformedAssignmentStmt ? transformedAssignmentStmt : std::make_shared<syrec::AssignStatement>(assignmentStatement); topMostAssignmentStmtIfNoOptimizationTookPlace) {
            generatedAssignments.emplace_back(topMostAssignmentStmtIfNoOptimizationTookPlace);
            wasAnyAssignmentGeneratedDuringProcessing = false;
        }
    } else {
        generatedAssignments = generatedAssignmentsContainer->getAssignments();
    }

    /*
     * If any assignments where generated by our more "complex" algorithm, try to determine the more viable alternative by comparing the cost of the simplified assignments generated
     * by the more "simple" algorithm (if applicable) to the ones generated by the "complex" one.
     */
    generatedAssignments = assignmentTransformer->simplify(generatedAssignments, signalValueLookupCallback);
    if (wasAnyAssignmentGeneratedDuringProcessing) {
        if (const std::shared_ptr<syrec::AssignStatement>& transformedAssignmentStmtWithoutAppliedHeuristicsForSubassignmentGeneration = transformAssignmentPriorToSimplification(assignmentStatement, false); transformedAssignmentStmtWithoutAppliedHeuristicsForSubassignmentGeneration) {
            generatedAssignments = determineMostViableAlternativeBasedOnCost(generatedAssignments, transformedAssignmentStmtWithoutAppliedHeuristicsForSubassignmentGeneration, signalValueLookupCallback);        
        }
    }
    return std::make_unique<SimplificationResult>(SimplificationResult{generatedAssignments});
}

// START OF NON-PUBLIC FUNCTION IMPLEMENTATIONS
std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OwningOperationOperandSimplificationResultReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleOperationNode(const ExpressionTraversalHelper::OperationNodeReference& operationNode, const SignalValueLookupCallback& signalValueLookupCallback) {
    logStartOfProcessingOfOperationNode(operationNode->id);
    std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OwningOperationOperandSimplificationResultReference> simplificationResult;
    if (!operationNode->hasAnyLeafOperandNodes()) {
        simplificationResult = handleOperationNodeWithNoLeafNodes(operationNode, signalValueLookupCallback);
    }
    else if (operationNode->areBothOperandsLeafNodes()) {
        simplificationResult = handleOperationNodeWithOnlyLeafNodes(operationNode);
    } else {
        simplificationResult = handleOperationNodeWithOneLeafNode(operationNode, signalValueLookupCallback);
    }
    logEndOfProcessingOfOperationNode(operationNode->id);
    return simplificationResult;
}

// TODO: If the simplification of any non-leaf node did result in a conflict check whether another decision at a previous position is possible, see other functions handling operation node with one leaf node
std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OwningOperationOperandSimplificationResultReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleOperationNodeWithNoLeafNodes(const ExpressionTraversalHelper::OperationNodeReference& operationNode, const SignalValueLookupCallback& signalValueLookupCallback) {
    //const std::size_t numExistingAssignmentsPriorToAnyOperandHandled = generatedAssignmentsContainer->getNumberOfAssignments();
    //generatedAssignmentsContainer->markCutoffForInvertibleAssignments();
    //expressionTraversalHelper->markOperationNodeAsPotentialBacktrackOption(operationNode->id);

    //std::optional<ExpressionTraversalHelper::OperationNodeReference>   firstOperandOperationNode;
    //std::optional<OwningOperationOperandSimplificationResultReference> firstOperandSimplificationResult;
    //bool                                                               continueProcessingOfNonLeafNode = true;
    //while (continueProcessingOfNonLeafNode) {
    //    firstOperandOperationNode        = expressionTraversalHelper->getNextOperationNode();
    //    firstOperandSimplificationResult = handleOperationNode(*firstOperandOperationNode, signalValueLookupCallback);
    //    if (shouldBacktrackDueToConflict()) {
    //        if (!isOperationNodeSourceOfConflict(operationNode->id)) {
    //            generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
    //            backtrack(operationNode->id, false);
    //            return std::nullopt;
    //        }
    //        markSourceOfConflictReached();
    //        generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(false);
    //        backtrack(operationNode->id, true);
    //        /*expressionTraversalHelper->markOperationNodeAsPotentialBacktrackOption(operationNode->id);
    //        generatedAssignmentsContainer->markCutoffForInvertibleAssignments();*/
    //    } else {
    //        continueProcessingOfNonLeafNode = false;
    //    }
    //}

    //// TODO: Check me if implemented correctly
    //if (!firstOperandSimplificationResult.has_value()) {
    //    if (couldAnotherChoiceBeMadeAtPreviousDecision(operationNode->id)) {
    //        generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
    //        backtrack(operationNode->id, false);
    //        return std::nullopt;   
    //    }
    //    const std::size_t            operationNodeIdOfFirstOperand = *expressionTraversalHelper->getOperandNodeIdOfNestedOperation(*firstOperandOperationNode->get()->parentNodeId, firstOperandOperationNode->get()->id);
    //    const syrec::expression::ptr firstOperandDataAsExpr        = *expressionTraversalHelper->getOperandAsExpr(operationNodeIdOfFirstOperand);
    //    firstOperandSimplificationResult                           = std::make_unique<OperationOperandSimplificationResult>(OperationOperandSimplificationResult::createManuallyFrom(firstOperandDataAsExpr));
    //}

    ///*
    // * If the first non-leaf node created an expression instead of an assignment, we need also need to take this generated expression as well as all active assignments into consideration
    // * when processing the second non-leaf-node
    // */
    //const syrec::expression::ptr& expressionToConsiderForDecisionInSecondNode = firstOperandSimplificationResult.has_value()
    //    ? firstOperandSimplificationResult->get()->getGeneratedExpr().value_or(nullptr)
    //    : nullptr;
    //considerExpressionInFutureDecisions(expressionToConsiderForDecisionInSecondNode);

    //std::optional<ExpressionTraversalHelper::OperationNodeReference>   secondOperandOperationNode;
    //std::optional<OwningOperationOperandSimplificationResultReference> secondOperandSimplificationResult;
    //continueProcessingOfNonLeafNode = true;

    //while (continueProcessingOfNonLeafNode) {
    //    secondOperandOperationNode        = expressionTraversalHelper->getNextOperationNode();
    //    secondOperandSimplificationResult = handleOperationNode(*secondOperandOperationNode, signalValueLookupCallback);
    //    if (shouldBacktrackDueToConflict()) {
    //        if (!isOperationNodeSourceOfConflict(operationNode->id)) {
    //            generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
    //            backtrack(operationNode->id, false);
    //            revokeConsiderationOfExpressionForFutureDecisions(expressionToConsiderForDecisionInSecondNode);
    //            return std::nullopt;
    //        }
    //        markSourceOfConflictReached();
    //        generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(false);
    //        backtrack(operationNode->id, true);
    //        /*expressionTraversalHelper->markOperationNodeAsPotentialBacktrackOption(operationNode->id);
    //        generatedAssignmentsContainer->markCutoffForInvertibleAssignments();*/
    //    } else {
    //        continueProcessingOfNonLeafNode = false;
    //    }
    //}
    //
    //// TODO: Check me if implemented correctly
    //if (!secondOperandSimplificationResult.has_value()) {
    //    if (couldAnotherChoiceBeMadeAtPreviousDecision(operationNode->id)) {
    //        generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
    //        backtrack(operationNode->id, false);
    //        revokeConsiderationOfExpressionForFutureDecisions(expressionToConsiderForDecisionInSecondNode);
    //        return std::nullopt;   
    //    }
    //    const std::size_t            operationNodeIdOfSecondOperand = *expressionTraversalHelper->getOperandNodeIdOfNestedOperation(*secondOperandOperationNode->get()->parentNodeId, secondOperandOperationNode->get()->id);
    //    const syrec::expression::ptr secondOperandDataAsExpr        = *expressionTraversalHelper->getOperandAsExpr(operationNodeIdOfSecondOperand);
    //    secondOperandSimplificationResult                           = std::make_unique<OperationOperandSimplificationResult>(OperationOperandSimplificationResult::createManuallyFrom(secondOperandDataAsExpr));
    //}

    //const DecisionReference madeDecision = makeDecision(operationNode, std::make_pair(**firstOperandSimplificationResult, **secondOperandSimplificationResult));
    ///*
    // * We need to revoke our consideration of the generated expression from the first non-leaf node of this operation node for any further decisions
    // */
    //revokeConsiderationOfExpressionForFutureDecisions(expressionToConsiderForDecisionInSecondNode);

    //std::variant<syrec::VariableAccess::ptr, syrec::expression::ptr> simplificationResultData;
    //if (madeDecision->choosenOperand != Decision::ChoosenOperand::None) {
    //    const std::optional<syrec::AssignStatement::ptr> generatedAssignment = tryCreateAssignmentFromOperands(madeDecision->choosenOperand, **firstOperandSimplificationResult, operationNode->operation, **secondOperandSimplificationResult);
    //    /*
    //     * At this point no overlapping signal accesses can be contained in the rhs of the generated assignment since this would have already triggered a conflict.
    //     */
    //    const std::size_t                 currentNumberOfExistingAssignments            = generatedAssignmentsContainer->getNumberOfAssignments();
    //    generatedAssignmentsContainer->storeActiveAssignment(*generatedAssignment);
    //    const std::size_t numberOfAssignmentsToNotInvertStartingFromLastCreatedOne = generatedAssignmentsContainer->getNumberOfAssignments() - currentNumberOfExistingAssignments;
    //    const auto&       assignedToSignalOfGeneratedAssignment                    = std::dynamic_pointer_cast<const syrec::AssignStatement>(*generatedAssignment)->lhs;
    //    generatedAssignmentsContainer->invertAllAssignmentsUpToLastCutoff(numberOfAssignmentsToNotInvertStartingFromLastCreatedOne, &assignedToSignalOfGeneratedAssignment);
    //    simplificationResultData = std::dynamic_pointer_cast<syrec::AssignStatement>(*generatedAssignment)->lhs;
    //}
    //else {
    //    const std::optional<syrec::expression::ptr> generatedExpr = tryCreateExpressionFromOperationNodeOperandSimplifications(**firstOperandSimplificationResult, operationNode->operation, **secondOperandSimplificationResult);
    //    simplificationResultData                                  = *generatedExpr;
    //}

    //// We should probably not remove any past decisions since this would clash with the check whether a different choice could be made at a previous decision
    ////removeDecisionFor(operationNode->id);

    //expressionTraversalHelper->removeOperationNodeAsPotentialBacktrackOperation(operationNode->id);
    //generatedAssignmentsContainer->popLastCutoffForInvertibleAssignments();

    //const std::size_t numExistingAssignmentsAfterOperationNodeWasHandled = generatedAssignmentsContainer->getNumberOfAssignments();
    //const std::size_t numGeneratedAssignmentsByHandlingOfOperationNode                     = numExistingAssignmentsAfterOperationNodeWasHandled - numExistingAssignmentsPriorToAnyOperandHandled;
    //return std::make_unique<OperationOperandSimplificationResult>(numGeneratedAssignmentsByHandlingOfOperationNode, simplificationResultData);

    const std::size_t numExistingAssignmentsPriorToAnyOperandHandled = generatedAssignmentsContainer->getNumberOfAssignments();
    generatedAssignmentsContainer->markCutoffForInvertibleAssignments();
    expressionTraversalHelper->markOperationNodeAsPotentialBacktrackOption(operationNode->id);

    std::optional<OwningOperationOperandSimplificationResultReference> firstOperandSimplificationResult;
    std::optional<OwningOperationOperandSimplificationResultReference> secondOperandSimplificationResult;
    syrec::expression::ptr                                             expressionToConsiderForDecisionInSecondNode;

    bool continueProcessing = true;
    while (continueProcessing) {
        OperationNodeProcessingResult firstOperandProcessingResult = processNextOperationNode(signalValueLookupCallback, false);
        if (firstOperandProcessingResult.derivedConflictInOtherNode) {
            return std::nullopt;
        }
        firstOperandSimplificationResult = std::move(firstOperandProcessingResult.simplificationResult);

        /*
         * If the first non-leaf node created an expression instead of an assignment, we need also need to take this generated expression as well as all active assignments into consideration
         * when processing the second non-leaf-node
         */
        expressionToConsiderForDecisionInSecondNode = firstOperandSimplificationResult->get()->getGeneratedExpr().value_or(nullptr);
        considerExpressionInFutureDecisions(expressionToConsiderForDecisionInSecondNode);

        OperationNodeProcessingResult secondOperandProcessingResult = processNextOperationNode(signalValueLookupCallback, true);
        if (secondOperandProcessingResult.derivedConflictInOtherNode) {
            return std::nullopt;
        }
        continueProcessing = secondOperandProcessingResult.derivedConflictInThisNode;
        if (!continueProcessing) {
            secondOperandSimplificationResult = std::move(secondOperandProcessingResult.simplificationResult);
        }
    }

    const DecisionReference madeDecision = makeDecision(operationNode, std::make_pair(**firstOperandSimplificationResult, **secondOperandSimplificationResult));
    /*
     * We need to revoke our consideration of the generated expression from the first non-leaf node of this operation node for any further decisions
     */
    revokeConsiderationOfExpressionForFutureDecisions(expressionToConsiderForDecisionInSecondNode);

    std::variant<syrec::VariableAccess::ptr, syrec::expression::ptr> simplificationResultData;
    if (madeDecision->choosenOperand != Decision::ChoosenOperand::None) {
        const std::optional<syrec::AssignStatement::ptr> generatedAssignment = tryCreateAssignmentFromOperands(madeDecision->choosenOperand, **firstOperandSimplificationResult, operationNode->operation, **secondOperandSimplificationResult);
        /*
         * At this point no overlapping signal accesses can be contained in the rhs of the generated assignment since this would have already triggered a conflict.
         */
        const std::size_t currentNumberOfExistingAssignments = generatedAssignmentsContainer->getNumberOfAssignments();
        generatedAssignmentsContainer->storeActiveAssignment(*generatedAssignment);
        const std::size_t numberOfAssignmentsToNotInvertStartingFromLastCreatedOne = generatedAssignmentsContainer->getNumberOfAssignments() - currentNumberOfExistingAssignments;
        const auto&       assignedToSignalOfGeneratedAssignment                    = std::dynamic_pointer_cast<const syrec::AssignStatement>(*generatedAssignment)->lhs;
        generatedAssignmentsContainer->invertAllAssignmentsUpToLastCutoff(numberOfAssignmentsToNotInvertStartingFromLastCreatedOne, &assignedToSignalOfGeneratedAssignment);
        simplificationResultData = std::dynamic_pointer_cast<syrec::AssignStatement>(*generatedAssignment)->lhs;
    } else {
        const std::optional<syrec::expression::ptr> generatedExpr = tryCreateExpressionFromOperationNodeOperandSimplifications(**firstOperandSimplificationResult, operationNode->operation, **secondOperandSimplificationResult);
        simplificationResultData                                  = *generatedExpr;
    }

    // We should probably not remove any past decisions since this would clash with the check whether a different choice could be made at a previous decision
    //removeDecisionFor(operationNode->id);

    expressionTraversalHelper->removeOperationNodeAsPotentialBacktrackOperation(operationNode->id);
    generatedAssignmentsContainer->popLastCutoffForInvertibleAssignments();

    const std::size_t numExistingAssignmentsAfterOperationNodeWasHandled = generatedAssignmentsContainer->getNumberOfAssignments();
    const std::size_t numGeneratedAssignmentsByHandlingOfOperationNode   = numExistingAssignmentsAfterOperationNodeWasHandled - numExistingAssignmentsPriorToAnyOperandHandled;
    return std::make_unique<OperationOperandSimplificationResult>(numGeneratedAssignmentsByHandlingOfOperationNode, simplificationResultData);
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OwningOperationOperandSimplificationResultReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleOperationNodeWithOneLeafNode(const ExpressionTraversalHelper::OperationNodeReference& operationNode, const SignalValueLookupCallback& signalValueLookupCallback) {
    expressionTraversalHelper->markOperationNodeAsPotentialBacktrackOption(operationNode->id);
    generatedAssignmentsContainer->markCutoffForInvertibleAssignments();
    const std::size_t numExistingAssignmentsPriorToHandlingOfOperationNode = generatedAssignmentsContainer->getNumberOfAssignments();

    const bool                                          wasLhsOperandLeafNode        = operationNode->getLeafNodeOperandId().value() == operationNode->lhsOperand.id;
    const std::optional<syrec::VariableExpression::ptr> dataOfLeafNodeAsVariableExpr = expressionTraversalHelper->getOperandAsVariableExpr(wasLhsOperandLeafNode ? operationNode->lhsOperand.id : operationNode->rhsOperand.id);

    if (dataOfLeafNodeAsVariableExpr.has_value()) {
        const auto& accessedSignalPartsOfLeafNode = std::dynamic_pointer_cast<syrec::VariableExpression>(*dataOfLeafNodeAsVariableExpr);
        if (wereAccessedSignalPartsModifiedByActiveAssignment(*accessedSignalPartsOfLeafNode->var)) {
            handleConflict(operationNode->id, *accessedSignalPartsOfLeafNode->var);
            generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
            backtrack(operationNode->id, false);
            return std::nullopt;
        }
    }

    std::optional<OwningOperationOperandSimplificationResultReference> simplificationResultOfOperationNodeOperand;
    bool continueProcessingOfNonLeafNode = true;
    while (continueProcessingOfNonLeafNode) {
        const ExpressionTraversalHelper::OperationNodeReference dataOfOperationNodeOperand = *expressionTraversalHelper->getNextOperationNode();
        simplificationResultOfOperationNodeOperand                                         = handleOperationNode(dataOfOperationNodeOperand, signalValueLookupCallback);
        if (shouldBacktrackDueToConflict()) {
            if (!isOperationNodeSourceOfConflict(operationNode->id)) {
                generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
                backtrack(operationNode->id, false);
                return std::nullopt;
            }
            markSourceOfConflictReached();
            generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(false);
            backtrack(operationNode->id, true);
        }
        else {
            /*
            * We need to perform our conflict check twice, once prior to the processing of the subexpression define in one of the operands of this operation and also
            * after we have processed said subexpression, to determine whether the value of the leaf node was not changed in any of the sub-assignments generated during the processing
            * of said subexpression
            */
            if (dataOfLeafNodeAsVariableExpr.has_value()) {
                const auto& accessedSignalPartsOfLeafNode = std::dynamic_pointer_cast<syrec::VariableExpression>(*dataOfLeafNodeAsVariableExpr);
                if (wereAccessedSignalPartsModifiedByActiveAssignment(*accessedSignalPartsOfLeafNode->var)) {
                    handleConflict(operationNode->id, *accessedSignalPartsOfLeafNode->var);
                    if (!isOperationNodeSourceOfConflict(operationNode->id)) {
                        generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
                        backtrack(operationNode->id, false);
                        return std::nullopt;
                    }
                    markSourceOfConflictReached();
                    generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(false);
                    continueProcessingOfNonLeafNode = true;
                    backtrack(operationNode->id, true);
                    continue;
                }
            }
            continueProcessingOfNonLeafNode = false;
        }
    }

    
    std::variant<syrec::VariableAccess::ptr, syrec::expression::ptr> simplificationResultData;
    DecisionReference                                                madeDecision             = nullptr;

    std::variant<syrec::VariableAccess::ptr, syrec::expression::ptr> simplificationResultDataOfLeafNode;
    if (dataOfLeafNodeAsVariableExpr.has_value()) {
        simplificationResultDataOfLeafNode = std::dynamic_pointer_cast<syrec::VariableExpression>(*dataOfLeafNodeAsVariableExpr)->var;
    } else {
        simplificationResultDataOfLeafNode = *expressionTraversalHelper->getOperandAsExpr(wasLhsOperandLeafNode ? operationNode->lhsOperand.id : operationNode->rhsOperand.id);
    }
    const auto simplificationResultOfLeafNode = OperationOperandSimplificationResult::createManuallyFrom(simplificationResultDataOfLeafNode);

    // TODO: Semantic check for prior to assingment generation
    if (simplificationResultOfOperationNodeOperand.has_value()) {
        const syrec::expression::ptr temporaryExpressionToConsiderForDecision = simplificationResultOfOperationNodeOperand->get()->getGeneratedExpr().value_or(nullptr);
        considerExpressionInFutureDecisions(temporaryExpressionToConsiderForDecision);
        if (wasLhsOperandLeafNode) {
            madeDecision = makeDecision(operationNode, std::make_pair(simplificationResultOfLeafNode, **simplificationResultOfOperationNodeOperand));
        } else {
            madeDecision = makeDecision(operationNode, std::make_pair(**simplificationResultOfOperationNodeOperand, simplificationResultOfLeafNode));
        }
        revokeConsiderationOfExpressionForFutureDecisions(temporaryExpressionToConsiderForDecision);
    } else {
        const std::size_t operandIdOfNonLeafNode   = wasLhsOperandLeafNode ? operationNode->rhsOperand.id : operationNode->lhsOperand.id;
        simplificationResultOfOperationNodeOperand = std::make_unique<OperationOperandSimplificationResult>(OperationOperandSimplificationResult::createManuallyFrom(*expressionTraversalHelper->getOperandAsExpr(operandIdOfNonLeafNode)));   
    }
    
    expressionTraversalHelper->removeOperationNodeAsPotentialBacktrackOperation(operationNode->id);
    if (madeDecision && madeDecision->choosenOperand != Decision::ChoosenOperand::None) {
        const std::optional<syrec::AssignStatement::ptr> generatedAssignment = wasLhsOperandLeafNode
            ? tryCreateAssignmentFromOperands(madeDecision->choosenOperand, simplificationResultOfLeafNode, operationNode->operation, **simplificationResultOfOperationNodeOperand)
            : tryCreateAssignmentFromOperands(madeDecision->choosenOperand, **simplificationResultOfOperationNodeOperand, operationNode->operation, simplificationResultOfLeafNode);

        /*
         * At this point no overlapping signal accesses can be contained in the rhs of the generated assignment since this would have already triggered a conflict.
         */
        const std::size_t currentNumberOfExistingAssignments = generatedAssignmentsContainer->getNumberOfAssignments();
        generatedAssignmentsContainer->storeActiveAssignment(*generatedAssignment);   
        const std::size_t numberOfAssignmentsToNotInvertStartingFromLastCreatedOne = generatedAssignmentsContainer->getNumberOfAssignments() - currentNumberOfExistingAssignments;
        const auto&       assignedToSignalOfGeneratedAssignment                    = std::dynamic_pointer_cast<const syrec::AssignStatement>(*generatedAssignment)->lhs;
        generatedAssignmentsContainer->invertAllAssignmentsUpToLastCutoff(numberOfAssignmentsToNotInvertStartingFromLastCreatedOne, &assignedToSignalOfGeneratedAssignment);
        simplificationResultData = std::dynamic_pointer_cast<syrec::AssignStatement>(*generatedAssignment)->lhs;
    } else {
        const std::optional<syrec::expression::ptr> generatedExpr = wasLhsOperandLeafNode
            ? tryCreateExpressionFromOperationNodeOperandSimplifications(simplificationResultOfLeafNode, operationNode->operation, **simplificationResultOfOperationNodeOperand)
            : tryCreateExpressionFromOperationNodeOperandSimplifications(**simplificationResultOfOperationNodeOperand, operationNode->operation, simplificationResultOfLeafNode);

        simplificationResultData = *generatedExpr;
        // Since we are not generating any assignments, we can also not invert any active ones as this would invalidate our propagated expression to the parent operation node
        //generatedAssignmentsContainer->invertAllAssignmentsUpToLastCutoff(0);   
    }
    generatedAssignmentsContainer->popLastCutoffForInvertibleAssignments();

    const std::size_t numExistingAssignmentsAfterHandlingOfOperationNode = generatedAssignmentsContainer->getNumberOfAssignments();
    const std::size_t numGeneratedAssignmentsByHandlingOfOperationNode   = numExistingAssignmentsAfterHandlingOfOperationNode - numExistingAssignmentsPriorToHandlingOfOperationNode;
    auto simplificationResult                                            = std::make_unique<OperationOperandSimplificationResult>(numGeneratedAssignmentsByHandlingOfOperationNode, simplificationResultData);
    return simplificationResult;
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OwningOperationOperandSimplificationResultReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleOperationNodeWithOnlyLeafNodes(const ExpressionTraversalHelper::OperationNodeReference& operationNode) {
    std::optional<std::shared_ptr<syrec::VariableAccess>> accessedSignalPartsOfFirstOperand;
    if (const auto& accessedSignalPartsExprOfFirstOperand = expressionTraversalHelper->getOperandAsVariableExpr(operationNode->lhsOperand.id); accessedSignalPartsExprOfFirstOperand.has_value()) {
        const auto accessedSignalPartsOfFirstOperandCasted = std::dynamic_pointer_cast<syrec::VariableExpression>(*accessedSignalPartsExprOfFirstOperand);
        accessedSignalPartsOfFirstOperand                  = accessedSignalPartsOfFirstOperandCasted->var;

        if (wereAccessedSignalPartsModifiedByActiveAssignment(**accessedSignalPartsOfFirstOperand)) {
            handleConflict(operationNode->id, **accessedSignalPartsOfFirstOperand);
            return std::nullopt;
        }
    }

    std::optional<std::shared_ptr<syrec::VariableAccess>> accessedSignalPartsOfSecondOperand;
    if (const auto& accessedSignalPartsExprOfSecondOperand = expressionTraversalHelper->getOperandAsVariableExpr(operationNode->rhsOperand.id); accessedSignalPartsExprOfSecondOperand.has_value()) {
        const auto accessedSignalPartsOfSecondOperandCasted = std::dynamic_pointer_cast<syrec::VariableExpression>(*accessedSignalPartsExprOfSecondOperand);
        accessedSignalPartsOfSecondOperand                  = accessedSignalPartsOfSecondOperandCasted->var;
        
        if (wereAccessedSignalPartsModifiedByActiveAssignment(**accessedSignalPartsOfSecondOperand)) {
            handleConflict(operationNode->id, **accessedSignalPartsOfSecondOperand);
            return std::nullopt;
        }
    }
    
    std::variant<syrec::VariableAccess::ptr, syrec::expression::ptr> simplificationResultDataOfFirstOperand;
    if (accessedSignalPartsOfFirstOperand.has_value()) {
        simplificationResultDataOfFirstOperand = *accessedSignalPartsOfFirstOperand;
    } else {
        simplificationResultDataOfFirstOperand = *expressionTraversalHelper->getOperandAsExpr(operationNode->lhsOperand.id);
    }
    const auto& simplificationResultOfFirstOperand = OperationOperandSimplificationResult::createManuallyFrom(simplificationResultDataOfFirstOperand);
    
    std::variant<syrec::VariableAccess::ptr, syrec::expression::ptr> simplificationResultDataOfSecondOperand;
    if (accessedSignalPartsOfSecondOperand.has_value()) {
        simplificationResultDataOfSecondOperand = *accessedSignalPartsOfSecondOperand;
    } else {
        simplificationResultDataOfSecondOperand = *expressionTraversalHelper->getOperandAsExpr(operationNode->rhsOperand.id);
    }
    const auto&             simplificationResultOfSecondOperand = OperationOperandSimplificationResult::createManuallyFrom(simplificationResultDataOfSecondOperand);
    const DecisionReference madeDecision                        = makeDecision(operationNode, std::make_pair(simplificationResultOfFirstOperand, simplificationResultOfSecondOperand));

    std::size_t                                                      numGeneratedAssignmentsByHandlingOfOperationNode = 0;
    std::variant<syrec::VariableAccess::ptr, syrec::expression::ptr> simplificationResultData;

    if (madeDecision->choosenOperand != Decision::ChoosenOperand::None) {
        const std::optional<syrec::AssignStatement::ptr> generatedAssignment = tryCreateAssignmentFromOperands(madeDecision->choosenOperand, simplificationResultOfFirstOperand, operationNode->operation, simplificationResultOfSecondOperand);
        generatedAssignmentsContainer->storeActiveAssignment(*generatedAssignment);
        simplificationResultData = std::dynamic_pointer_cast<syrec::AssignStatement>(*generatedAssignment)->lhs;
        ++numGeneratedAssignmentsByHandlingOfOperationNode;
        
    } else {
        const std::optional<syrec::expression::ptr> generatedExpr = tryCreateExpressionFromOperationNodeOperandSimplifications(simplificationResultOfFirstOperand, operationNode->operation, simplificationResultOfSecondOperand);
        simplificationResultData                                  = *generatedExpr;
    }
    // We should probably not remove any past decisions since this would clash with the check whether a different choice could be made at a previous decision
    //removeDecisionFor(operationNode->id);
    return std::make_unique<OperationOperandSimplificationResult>(numGeneratedAssignmentsByHandlingOfOperationNode, simplificationResultData);
}

inline bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesAssignmentToSignalLeadToConflict(const syrec::VariableAccess& assignedToSignal) const {
    return generatedAssignmentsContainer->existsOverlappingAssignmentFor(assignedToSignal, *symbolTableReference);
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryGetDecisionForOperationNode(const std::size_t& operationNodeId) const {
    const auto& matchingDecisionForOperationNode = std::find_if(
            pastDecisions.cbegin(),
            pastDecisions.cend(),
            [&operationNodeId](const DecisionReference& pastDecision) {
                return pastDecision->operationNodeId == operationNodeId;
            });
    if (matchingDecisionForOperationNode != pastDecisions.cend()) {
        return *matchingDecisionForOperationNode;
    }
    return std::nullopt;
}

noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::makeDecision(const ExpressionTraversalHelper::OperationNodeReference& operationNode, const std::pair<std::reference_wrapper<const OperationOperandSimplificationResult>, std::reference_wrapper<const OperationOperandSimplificationResult>>& potentialChoices) {
    const std::optional<DecisionReference>          previousDecisionForOperationNode = tryGetDecisionForOperationNode(operationNode->id);
    const bool                                      wasAssignmentGeneratedByLhsOperand = potentialChoices.first.get().getAssignedToSignalOfAssignment().has_value();
    const bool                                      wasAssignmentGeneratedByRhsOperand = potentialChoices.second.get().getAssignedToSignalOfAssignment().has_value();
    const std::optional<syrec_operation::operation> matchingAssignmentOperationForOperationNode = syrec_operation::getMatchingAssignmentOperationForOperation(operationNode->operation);
    const bool                                      isAnyChoiceBetweenOperandsPossible          = matchingAssignmentOperationForOperationNode.has_value() && (wasAssignmentGeneratedByLhsOperand || wasAssignmentGeneratedByRhsOperand);

    DecisionReference madeDecision;
    if (previousDecisionForOperationNode.has_value()) {
        madeDecision = *previousDecisionForOperationNode;
        madeDecision->numExistingAssignmentsPriorToDecision = generatedAssignmentsContainer->getNumberOfAssignments();
        if (madeDecision->shouldChoiceBeRepeatedFlag) {
            logDecision(madeDecision);
            madeDecision->shouldChoiceBeRepeatedFlag = false;
            return madeDecision;
        }
        madeDecision->choosenOperand                = Decision::ChoosenOperand::None;
        madeDecision->inheritedOperandDataForChoice = nullptr;
    }
    else {
        madeDecision = std::make_shared<Decision>(Decision{operationNode->id, Decision::ChoosenOperand::None, generatedAssignmentsContainer->getNumberOfAssignments(), nullptr, nullptr, false});
        recordDecision(madeDecision);
    }

    if (!isAnyChoiceBetweenOperandsPossible) {
        madeDecision->choosenOperand = Decision::ChoosenOperand::None;
        logDecision(madeDecision);
        return madeDecision;
    }

    std::optional<syrec::VariableAccess::ptr> firstOperandAsVariableAccess  = potentialChoices.first.get().getAssignedToSignalOfAssignment();
    std::optional<syrec::expression::ptr>     firstOperandAsExpr            = potentialChoices.first.get().getGeneratedExpr();
    std::optional<syrec::VariableAccess::ptr> secondOperandAsVariableAccess = potentialChoices.second.get().getAssignedToSignalOfAssignment();
    std::optional<syrec::expression::ptr>     secondOperandAsExpr           = potentialChoices.second.get().getGeneratedExpr();

    /*
     * We have a preference to start our decision process by choosing the lhs operand first, but in case that no assignment was generated only by the rhs operand, we would like
     * to reuse said assignment if the given operation is commutative.
     */
    const bool shouldOperandsBeSwappedDueToPreferenceForReuseOfExistingAssignmentOfRhs = (potentialChoices.first.get().wasResultManuallyCreated() || firstOperandAsExpr.has_value()) && !potentialChoices.second.get().wasResultManuallyCreated()
        && secondOperandAsVariableAccess.has_value() && syrec_operation::isCommutative(operationNode->operation);

    if (shouldOperandsBeSwappedDueToPreferenceForReuseOfExistingAssignmentOfRhs) {
        firstOperandAsVariableAccess.swap(secondOperandAsVariableAccess);
        firstOperandAsExpr.swap(secondOperandAsExpr);
    }

    /*
     * Our decision follows the pattern:
     * I.   Try to select one of the operands as a potential choice with a higher preference for the left operand as a first choice.
     * II.  Check whether the decision can actually be used on the left-hand side of an assignment and does not lead to a conflict (this includes a check if any previous conflicts were already learned for the selected choice at the given operation node and that no overlapping signal access is defined in the second alternative)
     * III. If our first choice failed, try to repeat the steps but choose the right operand if possible (i.e. the operation is commutative).
     * IV.  If no operand could be selected as a candidate, the whole expression will be selected as our final decision.
     *
     * We will also remember any conflicts that we derive during this check and will not reset them during our parsing of the further parts of the initial assignment
     * since these learned conflicts are valid for the whole duration of the assignment parsing.
     */
    if (firstOperandAsVariableAccess.has_value()) {
        constexpr Decision::ChoosenOperand toBeChosenOperand = Decision::ChoosenOperand::Left;
        if (secondOperandAsVariableAccess.has_value() && canAlternativeByChosenInOperationNode(operationNode->id, toBeChosenOperand, **firstOperandAsVariableAccess, **secondOperandAsVariableAccess, *symbolTableReference)) {
            madeDecision->choosenOperand = toBeChosenOperand;
        } else if (secondOperandAsExpr.has_value() && canAlternativeByChosenInOperationNode(operationNode->id, toBeChosenOperand, **firstOperandAsVariableAccess, **secondOperandAsExpr, *symbolTableReference)) {
            madeDecision->choosenOperand = toBeChosenOperand;
        }
    }
    
    if (madeDecision->choosenOperand == Decision::ChoosenOperand::None && syrec_operation::isCommutative(operationNode->operation) && secondOperandAsVariableAccess.has_value()) {
        constexpr Decision::ChoosenOperand toBeChosenOperand = Decision::ChoosenOperand::Right;
        if (firstOperandAsVariableAccess.has_value() && canAlternativeByChosenInOperationNode(operationNode->id, toBeChosenOperand, **secondOperandAsVariableAccess, **firstOperandAsVariableAccess, *symbolTableReference)) {
            madeDecision->choosenOperand = toBeChosenOperand;
        } else if (firstOperandAsExpr.has_value() && canAlternativeByChosenInOperationNode(operationNode->id, toBeChosenOperand, **secondOperandAsVariableAccess, **firstOperandAsExpr, *symbolTableReference)) {
            madeDecision->choosenOperand = toBeChosenOperand;
        }
    }

    if (madeDecision->choosenOperand != Decision::ChoosenOperand::None) {
        if (shouldOperandsBeSwappedDueToPreferenceForReuseOfExistingAssignmentOfRhs) {
            madeDecision->choosenOperand = madeDecision->choosenOperand == Decision::ChoosenOperand::Left ? Decision::ChoosenOperand::Right : Decision::ChoosenOperand::Left;
        }

        if (madeDecision->choosenOperand == Decision::ChoosenOperand::Left && !operationNode->lhsOperand.isLeafNode()) {
            madeDecision->inheritedOperandDataForChoice = shouldOperandsBeSwappedDueToPreferenceForReuseOfExistingAssignmentOfRhs ? *secondOperandAsVariableAccess : *firstOperandAsVariableAccess;
        } else if (madeDecision->choosenOperand == Decision::ChoosenOperand::Right && !operationNode->rhsOperand.isLeafNode()) {
            madeDecision->inheritedOperandDataForChoice = shouldOperandsBeSwappedDueToPreferenceForReuseOfExistingAssignmentOfRhs ? *firstOperandAsVariableAccess : *secondOperandAsVariableAccess;
        }
    }

    logDecision(madeDecision);
    return madeDecision;
}

std::optional<std::size_t> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineOperationNodeIdCausingConflict(const syrec::VariableAccess& choiceOfAssignedToSignalTriggeringSearchForCauseOfConflict) const {
    for (auto decisionIterator = pastDecisions.rbegin(); decisionIterator != pastDecisions.rend(); ++decisionIterator) {
        const DecisionReference& decision = *decisionIterator;
        if (decision->choosenOperand == Decision::ChoosenOperand::None || decision->inheritedOperandDataForChoice) {
            continue;
        }

        const auto& referenceOperationNode = expressionTraversalHelper->getOperationNodeById(decision->operationNodeId);
        if (!referenceOperationNode.has_value()) {
            continue;
        }

        /*syrec::VariableExpression::ptr selectedOperandData;
        if (decision->inheritedOperandDataForChoice) {
            selectedOperandData = std::make_shared<syrec::VariableExpression>(decision->inheritedOperandDataForChoice);
        } else {
            selectedOperandData = decision->choosenOperand == Decision::ChoosenOperand::Left ? expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->lhsOperand.id).value_or(nullptr) : expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->rhsOperand.id).value_or(nullptr);
        }*/

        syrec::VariableExpression::ptr selectedOperandData = decision->choosenOperand == Decision::ChoosenOperand::Left
            ? expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->lhsOperand.id).value_or(nullptr)
            : expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->rhsOperand.id).value_or(nullptr);

        if (!selectedOperandData) {
            return std::nullopt;
        }

        // TODO: if the made choice was inherited from an assignment, the call getOperandAsVariableExpr will not return anything (pastDecision needs to have additional field [inheritedOperand])
        if (const auto& operandAsSignalAccess = std::dynamic_pointer_cast<syrec::VariableExpression>(selectedOperandData); operandAsSignalAccess) {
            const auto& accessedSignalIdentOfDecision = operandAsSignalAccess->var->var->name;

            if (accessedSignalIdentOfDecision == choiceOfAssignedToSignalTriggeringSearchForCauseOfConflict.var->name) {
                const auto& equalityResult = SignalAccessUtils::areSignalAccessesEqual(
                        *operandAsSignalAccess->var, choiceOfAssignedToSignalTriggeringSearchForCauseOfConflict,
                        SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::DimensionAccess::Overlapping,
                        SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::BitRange::Overlapping,
                        *symbolTableReference);

                if (equalityResult.equality != SignalAccessUtils::SignalAccessEquivalenceResult::NotEqual) {
                    return decision->operationNodeId;
                }
            }
        }
    }
    return std::nullopt;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::isOperationNodeSourceOfConflict(std::size_t operationNodeId) const {
    return operationNodeCausingConflictAndBacktrack.has_value() && *operationNodeCausingConflictAndBacktrack == operationNodeId;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::markOperationNodeAsSourceOfConflict(std::size_t operationNodeId) {
    operationNodeCausingConflictAndBacktrack = operationNodeId;
    logMarkingOfOperationNodeAsSourceOfConflict(operationNodeId);
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::markSourceOfConflictReached() {
    operationNodeCausingConflictAndBacktrack.reset();
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::wereAccessedSignalPartsModifiedByActiveAssignment(const syrec::VariableAccess& accessedSignalParts) const {
    return generatedAssignmentsContainer->existsOverlappingAssignmentFor(accessedSignalParts, *symbolTableReference);
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineEarliestDecisionsOverlappingAccessedSignalPartsOmittingAlreadyRecordedOnes(const syrec::VariableAccess& accessedSignalParts) const {
    DecisionReference earliestDecisionOverlappingAccessedSignalParts;
    for (const DecisionReference& decision : pastDecisions) {
        if (decision->choosenOperand == Decision::ChoosenOperand::None || decision->inheritedOperandDataForChoice) {
            continue;
        }

        const auto& referenceOperationNode = expressionTraversalHelper->getOperationNodeById(decision->operationNodeId);
        if (!referenceOperationNode.has_value()) {
            continue;
        }

        /*syrec::VariableExpression::ptr selectedOperandData;
        if (decision->inheritedOperandDataForChoice) {
            selectedOperandData = std::make_shared<syrec::VariableExpression>(decision->inheritedOperandDataForChoice);
        } else {
            selectedOperandData = decision->choosenOperand == Decision::ChoosenOperand::Left
                ? expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->lhsOperand.id).value_or(nullptr)
                : expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->rhsOperand.id).value_or(nullptr);
        }*/

        const syrec::VariableExpression::ptr selectedOperandData = decision->choosenOperand == Decision::ChoosenOperand::Left
            ? expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->lhsOperand.id).value_or(nullptr)
            : expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->rhsOperand.id).value_or(nullptr);

        if (selectedOperandData) {
            const LearnedConflictsLookupKey key = LearnedConflictsLookupKey(decision->operationNodeId, decision->choosenOperand);
            if (const auto& operandAsSignalAccess = std::dynamic_pointer_cast<syrec::VariableExpression>(selectedOperandData); operandAsSignalAccess && !learnedConflictsLookup->count(key)) {
                const auto& equalityResult = SignalAccessUtils::areSignalAccessesEqual(
                        *operandAsSignalAccess->var, accessedSignalParts,
                        SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::DimensionAccess::Overlapping,
                        SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::BitRange::Overlapping,
                        *symbolTableReference);
                if (!(equalityResult.isResultCertain && equalityResult.equality == SignalAccessUtils::SignalAccessEquivalenceResult::NotEqual)) {
                    if (!earliestDecisionOverlappingAccessedSignalParts || decision.get()->operationNodeId <= earliestDecisionOverlappingAccessedSignalParts->operationNodeId) {
                        earliestDecisionOverlappingAccessedSignalParts = decision;
                    }
                }
            }
        }
    }
    return earliestDecisionOverlappingAccessedSignalParts ? std::make_optional(earliestDecisionOverlappingAccessedSignalParts) : std::nullopt;
}

/*
 * TODO: Review search for earliest operation node involved in conflict (line 712) with test 'simplifyWithOnlyReversibleOpsButNonUniqueSignalAccessWithAssignOperationBeingAdditionWithDegeneratedLhsSubASTOfLhsOfAssignmentExpr'
 */
void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleConflict(std::size_t associatedOperationNodeIdOfAccessedSignalPartsOperand, const syrec::VariableAccess& accessedSignalPartsUsedInCheckForConflict) {
    if (associatedOperationNodeIdOfAccessedSignalPartsOperand == 1) {
        int x = 0;
    }

    constexpr std::size_t                  earliestPossibleOperationNodeId               = 0;
    const std::size_t                      idOfEarliestOperationNodeIdInvolvedInConflict = determineOperationNodeIdCausingConflict(accessedSignalPartsUsedInCheckForConflict).value_or(earliestPossibleOperationNodeId);
    const std::optional<DecisionReference> earliestDecisionInvolvedInConflict            = determineEarliestDecisionsOverlappingAccessedSignalPartsOmittingAlreadyRecordedOnes(accessedSignalPartsUsedInCheckForConflict);
    
    if (earliestDecisionInvolvedInConflict.has_value()) {
        rememberConflict(earliestDecisionInvolvedInConflict->get()->operationNodeId, earliestDecisionInvolvedInConflict->get()->choosenOperand);
    }

    logConflict(associatedOperationNodeIdOfAccessedSignalPartsOperand, Decision::ChoosenOperand::None, accessedSignalPartsUsedInCheckForConflict, idOfEarliestOperationNodeIdInvolvedInConflict);

    std::unordered_set<std::size_t> hotPathFromSourceOfConflictToLocationWhereConflictWasDetected                                 = {};
    const std::size_t idOfEarliestSharedParentOperationNodeBetweenSourceOfConflictAndDetectionOfOriginOperationNode = determineEarliestSharedParentOperationNodeIdBetweenCurrentAndConflictOperationNodeId(idOfEarliestOperationNodeIdInvolvedInConflict, associatedOperationNodeIdOfAccessedSignalPartsOperand, &hotPathFromSourceOfConflictToLocationWhereConflictWasDetected);
    markOperationNodeAsSourceOfConflict(idOfEarliestSharedParentOperationNodeBetweenSourceOfConflictAndDetectionOfOriginOperationNode);
    forceReuseOfPreviousDecisionsOnceAtAllDecisionsForChildrenOfNodeButExcludeHotpath(idOfEarliestSharedParentOperationNodeBetweenSourceOfConflictAndDetectionOfOriginOperationNode, &hotPathFromSourceOfConflictToLocationWhereConflictWasDetected);
}

std::size_t noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineEarliestSharedParentOperationNodeIdBetweenCurrentAndConflictOperationNodeId(std::size_t operationNodeIdOfEarliestSourceOfConflict, std::size_t operationNodeIdWhereConflictWasDetected, std::unordered_set<std::size_t>* hotPathContainerFromSourceToSharedOrigin) const {
    /*std::optional<ExpressionTraversalHelper::OperationNodeReference> operationNodeOfInterest;
    if (const std::optional<ExpressionTraversalHelper::OperationNodeReference> dataOfOperationNodeWhereConflictWasDetected = expressionTraversalHelper->getOperationNodeById(operationNodeIdWhereConflictWasDetected); dataOfOperationNodeWhereConflictWasDetected.has_value() && dataOfOperationNodeWhereConflictWasDetected->get()->parentNodeId.has_value()) {
        operationNodeOfInterest = expressionTraversalHelper->getOperationNodeById(*dataOfOperationNodeWhereConflictWasDetected->get()->parentNodeId);
    }*/

    std::optional<ExpressionTraversalHelper::OperationNodeReference> operationNodeOfInterest = expressionTraversalHelper->getOperationNodeById(operationNodeIdOfEarliestSourceOfConflict);

    /*
     * Try to find the first shared operation node by the operation node containing the conflict as well as the operation node for which the conflict was detected. Furthermore, the parent of the found shared parent operation node is returned.
     */
    constexpr std::size_t defaultSearchResultOperationNodeId = 0;
    while (operationNodeOfInterest.has_value()) {
        if (hotPathContainerFromSourceToSharedOrigin) {
            hotPathContainerFromSourceToSharedOrigin->emplace(operationNodeOfInterest->get()->id);
        }

        /*
         * We have found the operation node that is the source of the conflict (called original source), but we need to mark its parent node, if such a node exists, as the "source" of the conflict to trigger
         * a reprocessing of the original source. 
         */
        if (operationNodeOfInterest->get()->id < operationNodeIdOfEarliestSourceOfConflict) {
            // TODO: Why should we always return the parent of the found node and not the node instead ?
            return operationNodeOfInterest->get()->id;
            //return operationNodeOfInterest->get()->parentNodeId.value_or(defaultSearchResultOperationNodeId);
        }
        // Since any generated operation node id is >= 1 we can assume that the lookup for an operation node with id 0 does not return any matching result
        operationNodeOfInterest = expressionTraversalHelper->getOperationNodeById(operationNodeOfInterest->get()->parentNodeId.value_or(defaultSearchResultOperationNodeId));
    }
    return defaultSearchResultOperationNodeId;
}

/*
 * TODO: Think this through more thorougly with the help of the test case conflictInOperationNodeWithOneLeafNodeWhereLeafIsRhsOperandNotResolvableByOtherChoiceInLhsOperandThatGeneratedAssignmentCreatesExprInstead
 */
void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::forceReuseOfPreviousDecisionsOnceAtAllDecisionsForChildrenOfNodeButExcludeHotpath(std::size_t parentOperationNodeId, const std::unordered_set<std::size_t>* idOfOperationNodesOnHotPath) const {
    /*
     * We are assuming here that no decision are removed during the processing of the whole assignment statement (only the chosen operand should change). Additionally, we assume that the operation node ids
     * are ordered ascending and thus the a parent operation node should have a smaller id than any of its child nodes. Since child nodes are processed before their parent, the former
     * are also found at smaller indices in the container than their parent nodes. Thus we perform a reverse search to find the parents first.
     */
    const auto& firstPastDecisionToReuse = std::find_if(pastDecisions.crbegin(), pastDecisions.crend(), [&parentOperationNodeId](const DecisionReference& pastDecision) { return pastDecision->operationNodeId > parentOperationNodeId; });
    for (auto pastDecisionToReuseIterator = firstPastDecisionToReuse; pastDecisionToReuseIterator != pastDecisions.crend(); ++pastDecisionToReuseIterator) {
        pastDecisionToReuseIterator->get()->shouldChoiceBeRepeatedFlag = !idOfOperationNodesOnHotPath || !idOfOperationNodesOnHotPath->count(pastDecisionToReuseIterator->get()->operationNodeId);
    }
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::shouldBacktrackDueToConflict() const {
    return operationNodeCausingConflictAndBacktrack.has_value();
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::considerExpressionInFutureDecisions(const syrec::expression::ptr& expr) const {
    if (temporaryExpressionsContainer && expr) {
        temporaryExpressionsContainer->activateExpression(expr);
    }
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::revokeConsiderationOfExpressionForFutureDecisions(const syrec::expression::ptr& expr) const {
    if (temporaryExpressionsContainer && expr) {
        temporaryExpressionsContainer->deactivateExpression(expr);   
    }
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::isChoiceOfSignalAccessBlockedByAnyActiveExpression(const syrec::VariableAccess& chosenOperand) const {
    return temporaryExpressionsContainer && temporaryExpressionsContainer->existsAnyExpressionDefiningOverlappingSignalAccess(chosenOperand);
}

// TODO: can probably be removed
bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::couldAnotherChoiceBeMadeAtPreviousDecision(const std::optional<std::size_t>& pastDecisionForOperationNodeWithIdToExclude) const {
    if (pastDecisions.empty()) {
        return false;
    }

    std::size_t lastDecisionOffset = 0;
    if (pastDecisionForOperationNodeWithIdToExclude.has_value() && *pastDecisionForOperationNodeWithIdToExclude == pastDecisions.back()->operationNodeId) {
        ++lastDecisionOffset;
    }

    if (lastDecisionOffset >= pastDecisions.size()) {
        return false;
    }

    return std::any_of(
        std::next(pastDecisions.crbegin(), lastDecisionOffset + 1),
        pastDecisions.crend(),
        [&](const DecisionReference& pastDecision) {
                if (const auto& matchingAssignmentOperationForOperation = syrec_operation::getMatchingAssignmentOperationForOperation(*expressionTraversalHelper->getOperationOfOperationNode(pastDecision->operationNodeId)); matchingAssignmentOperationForOperation.has_value()) {
                    return pastDecision->choosenOperand == Decision::ChoosenOperand::Left && syrec_operation::isCommutative(*expressionTraversalHelper->getOperationOfOperationNode(pastDecision->operationNodeId));
                }
                return false;
            });
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::removeDecisionFor(std::size_t operationNodeId) {
    const auto& matchingDecisionForOperationNode = std::find_if(
        pastDecisions.cbegin(),
        pastDecisions.cend(),
        [&operationNodeId](const DecisionReference& decisionReference) {
            return decisionReference->operationNodeId == operationNodeId;
        });

    if (matchingDecisionForOperationNode != pastDecisions.cend()) {
        pastDecisions.erase(matchingDecisionForOperationNode);
    }
}

inline std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryGetLastDecision() const {
    if (pastDecisions.empty()) {
        return std::nullopt;
    }
    return pastDecisions.back();
}

inline std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryGetSecondToLastDecision() const {
    if (pastDecisions.size() < 2) {
        return std::nullopt;
    }
    return pastDecisions.at(pastDecisions.size() - 2);
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::resetInternals() {
    pastDecisions.clear();
    generatedAssignmentsContainer->resetInternals();
    temporaryExpressionsContainer->resetInternals();
    expressionTraversalHelper->resetInternals();
    enabledValueLookup();
}

std::unique_ptr<syrec::AssignStatement> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::transformAssignmentPriorToSimplification(const syrec::AssignStatement& assignmentToSimplify, bool applyHeuristicsForSubassignmentGeneration) const {
    if (std::unique_ptr<syrec::AssignStatement> owningCopyOfAssignmentStmt = copyUtils::createDeepCopyOfAssignmentStmt(assignmentToSimplify); owningCopyOfAssignmentStmt) {
        tryConvertNumericToBinaryExpr(owningCopyOfAssignmentStmt->rhs);
        if (!doesExpressionDefineNestedSplitableExpr(*owningCopyOfAssignmentStmt->rhs)) {
            return nullptr;
        }

        /*
         * Try to convert an assignment of the form a -= (<lhsExpr> - <rhsExpr>) to a += (<rhsExpr> - <lhsExpr>) if the <lhsExpr> is a nested expression, to enable the optimization of converting an assignment of the form:
         * a += ... to a ^= 0 if the symbol table entry for the assigned to signal has the value 0
         */
        if (const auto& assignmentRhsExprAsBinaryExpr = std::dynamic_pointer_cast<syrec::BinaryExpression>(owningCopyOfAssignmentStmt->rhs); assignmentRhsExprAsBinaryExpr) {
            const std::optional<syrec_operation::operation> mappedToAssignmentOperationEnumFromFlag = syrec_operation::tryMapAssignmentOperationFlagToEnum(owningCopyOfAssignmentStmt->op);
            const std::optional<syrec_operation::operation> mappedToBinaryOperationEnumFromFlag     = syrec_operation::tryMapBinaryOperationFlagToEnum(assignmentRhsExprAsBinaryExpr->op);
            if (mappedToAssignmentOperationEnumFromFlag.has_value() && *mappedToAssignmentOperationEnumFromFlag == syrec_operation::operation::MinusAssign
                && mappedToBinaryOperationEnumFromFlag.has_value() && *mappedToBinaryOperationEnumFromFlag == syrec_operation::operation::Subtraction) {
                owningCopyOfAssignmentStmt->op                   = *syrec_operation::tryMapAssignmentOperationEnumToFlag(syrec_operation::operation::AddAssign);
                const syrec::expression::ptr copyOfBinaryExprLhs = assignmentRhsExprAsBinaryExpr->lhs;
                assignmentRhsExprAsBinaryExpr->lhs               = assignmentRhsExprAsBinaryExpr->rhs;
                assignmentRhsExprAsBinaryExpr->rhs               = copyOfBinaryExprLhs;   
            }
        }
        transformExpressionPriorToSimplification(*owningCopyOfAssignmentStmt->rhs, applyHeuristicsForSubassignmentGeneration);
        return owningCopyOfAssignmentStmt;
    }
    return nullptr;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::transformExpressionPriorToSimplification(syrec::expression& expr, bool applyHeuristicsForSubassignmentGeneration) const {
    if (auto* exprAsBinaryExpr = dynamic_cast<syrec::BinaryExpression*>(&expr); exprAsBinaryExpr) {
        tryConvertNumericToBinaryExpr(exprAsBinaryExpr->lhs);
        tryConvertNumericToBinaryExpr(exprAsBinaryExpr->rhs);
        transformExpressionPriorToSimplification(*exprAsBinaryExpr->lhs, applyHeuristicsForSubassignmentGeneration);

        const bool doesLhsOperandDefineNestedEpxr = doesExpressionDefineNestedSplitableExpr(*exprAsBinaryExpr->lhs);
        const std::optional<syrec_operation::operation> mappedToOperationOfParentExpr  = syrec_operation::tryMapBinaryOperationFlagToEnum(exprAsBinaryExpr->op);

        /*
         * Try to transform a binary expression of the form (<number> op <signalAccess>) to (<signalAccess> op <number>) if the defined operation is commutative, has a matching assignment operation and the defined signal access accesses a modifiable signal.
         */
        if (applyHeuristicsForSubassignmentGeneration && mappedToOperationOfParentExpr.has_value() && syrec_operation::isCommutative(*mappedToOperationOfParentExpr) && syrec_operation::getMatchingAssignmentOperationForOperation(*mappedToOperationOfParentExpr).has_value()
            && (doesExpressionDefineNumber(*exprAsBinaryExpr->lhs) || doesLhsOperandDefineNestedEpxr) && doesExprDefineSignalAccess(*exprAsBinaryExpr->rhs)) {
            const auto& rhsOperandAsSignalAccess = std::dynamic_pointer_cast<const syrec::VariableExpression>(exprAsBinaryExpr->rhs);
            if (rhsOperandAsSignalAccess && isAccessedSignalAssignable(rhsOperandAsSignalAccess->var->var->name)) {
                const auto backupOfBinaryExprLhsOperand = exprAsBinaryExpr->rhs;
                exprAsBinaryExpr->rhs                   = exprAsBinaryExpr->lhs;
                exprAsBinaryExpr->lhs                   = backupOfBinaryExprLhsOperand;   
            }
        }


        if (const std::shared_ptr<syrec::BinaryExpression> rhsExprAsBinaryExpr = std::dynamic_pointer_cast<syrec::BinaryExpression>(exprAsBinaryExpr->rhs); rhsExprAsBinaryExpr) {
            const std::optional<syrec_operation::operation> mappedToOperationOfRhsExpr    = syrec_operation::tryMapBinaryOperationFlagToEnum(rhsExprAsBinaryExpr->op);

            /*
             * Try to transform an expression of the form (a - (b - c)) to (a + (c - b)) only if b is not a signal access. The latter condition is heuristic as the transformation could prevent the creation of an assignment
             * of the form b -= c.
             */
            if (applyHeuristicsForSubassignmentGeneration && mappedToOperationOfParentExpr.has_value() && mappedToOperationOfRhsExpr.has_value() && *mappedToOperationOfRhsExpr == syrec_operation::operation::Subtraction && *mappedToOperationOfParentExpr == syrec_operation::operation::Subtraction) {
                /*
                 * Try to convert an expression of the form (<subExpr_1> - (<subExpr_2> - <subExpr_3>)) to (<subExpr_1> + (<subExpr_3> - <subExpr_2)).
                 * We do not apply this transformation if <subExpr_2> defines a signal access while <subExpr_3> defines a nested expressions as this could prevent the generation of the assignment <subExpr_2> -= <subExpr_3>.
                 * NOTE: We try to not prevent any future assignments by this transformation, but could implicitly block some by our transformation due to a conflict later during preprocessing.
                 */
                if (!doesExprDefineSignalAccess(*rhsExprAsBinaryExpr->lhs) || doesExprDefineSignalAccess(*rhsExprAsBinaryExpr->rhs)) {
                    exprAsBinaryExpr->op                    = *syrec_operation::tryMapBinaryOperationEnumToFlag(syrec_operation::operation::Addition);
                    const auto backupOfNestedExprLhsOperand = rhsExprAsBinaryExpr->lhs;
                    rhsExprAsBinaryExpr->lhs                = rhsExprAsBinaryExpr->rhs;
                    rhsExprAsBinaryExpr->rhs                = backupOfNestedExprLhsOperand;
                }
            }  
        }
        transformExpressionPriorToSimplification(*exprAsBinaryExpr->rhs, applyHeuristicsForSubassignmentGeneration);
    } else if (const auto& exprAsShiftExpr = dynamic_cast<const syrec::ShiftExpression*>(&expr); exprAsShiftExpr) {
        tryConvertNumericToBinaryExpr(exprAsBinaryExpr->lhs);
        transformExpressionPriorToSimplification(*exprAsShiftExpr->lhs, applyHeuristicsForSubassignmentGeneration);
        // TODO: Simplification of number
    }
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::rememberConflict(std::size_t operationNodeId, Decision::ChoosenOperand chosenOperandAtOperationNode) const {
    const LearnedConflictsLookupKey lookupKey = LearnedConflictsLookupKey(operationNodeId, chosenOperandAtOperationNode);
    learnedConflictsLookup->emplace(lookupKey);
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::didPreviousDecisionMatchingChoiceCauseConflict(const LearnedConflictsLookupKey& lookupKeyRepresentingSearchedForPreviousDecision) const {
    return learnedConflictsLookup->count(lookupKeyRepresentingSearchedForPreviousDecision);
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::disableValueLookup() {
    disabledValueLookupToggle = true;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::enabledValueLookup() {
    disabledValueLookupToggle = false;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::backtrack(std::size_t operationNodeIdAtOriginOfBacktrack, bool onlyUpToOperationNode) const {
    if (onlyUpToOperationNode) {
        expressionTraversalHelper->backtrackToNode(operationNodeIdAtOriginOfBacktrack);
    }
    else {
        expressionTraversalHelper->backtrackOnePastNode(operationNodeIdAtOriginOfBacktrack);
    }
    const std::optional<ExpressionTraversalHelper::OperationNodeReference> peekedNextOperationNodeAfterFinishOfBacktrack = expressionTraversalHelper->peekNextOperationNode();
    const std::size_t                                                      peekedNextOperationNodeToBeProcessedAfterBacktracking = peekedNextOperationNodeAfterFinishOfBacktrack.has_value() ? peekedNextOperationNodeAfterFinishOfBacktrack.value()->id : 0;
    logBacktrackingResult(operationNodeIdAtOriginOfBacktrack, peekedNextOperationNodeToBeProcessedAfterBacktracking);
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::recordDecision(const DecisionReference& decision) {
    const auto& insertPosition = std::find_if(pastDecisions.cbegin(), pastDecisions.cend(), [&decision](const DecisionReference& pastDecision) { return pastDecision->operationNodeId < decision->operationNodeId; });
    if (insertPosition != pastDecisions.cend()) {
        pastDecisions.insert(insertPosition, decision);
    }
    else {
        pastDecisions.emplace_back(decision);
    }
}

noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OperationNodeProcessingResult noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::processNextOperationNode(const SignalValueLookupCallback& signalValueLookupCallback, bool quitProcessingOnConflictInSameNode) {
    std::optional<ExpressionTraversalHelper::OperationNodeReference>   dataOfOperationNode;
    std::optional<OwningOperationOperandSimplificationResultReference> simplificationResultOfOperationNode;

    bool continueProcessing = true;
    while (continueProcessing) {
        dataOfOperationNode = expressionTraversalHelper->getNextOperationNode();
        if (!dataOfOperationNode.has_value()) {
            return OperationNodeProcessingResult::fromUnknownResult();
        }

        const std::size_t idOfOperationNodeToBeProcessed = dataOfOperationNode->get()->id;
        simplificationResultOfOperationNode = handleOperationNode(*dataOfOperationNode, signalValueLookupCallback);
        if (shouldBacktrackDueToConflict()) {
            const bool isThisOperationNodeSourceOfConflict = isOperationNodeSourceOfConflict(idOfOperationNodeToBeProcessed);
            if (isThisOperationNodeSourceOfConflict) {
                markSourceOfConflictReached();
            }

            generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(!isThisOperationNodeSourceOfConflict);
            backtrack(idOfOperationNodeToBeProcessed, isThisOperationNodeSourceOfConflict);
            if (!isThisOperationNodeSourceOfConflict) {
                return OperationNodeProcessingResult::fromConflictInOtherNode();
            }
            if (quitProcessingOnConflictInSameNode) {
                return OperationNodeProcessingResult::fromFromConflictInSameNode();
            }
        } else {
            continueProcessing = false;
        }
    }
    
    if (!simplificationResultOfOperationNode.has_value()) {
        const std::size_t idOfOperationNodeToBeProcessed = dataOfOperationNode->get()->id;
        if (couldAnotherChoiceBeMadeAtPreviousDecision(idOfOperationNodeToBeProcessed)) {
            generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
            backtrack(idOfOperationNodeToBeProcessed, false);
            return OperationNodeProcessingResult({.simplificationResult = std::nullopt, .derivedConflictInOtherNode = false});
        }
        const std::size_t            operationNodeIdOfFirstOperand = *expressionTraversalHelper->getOperandNodeIdOfNestedOperation(*dataOfOperationNode->get()->parentNodeId, dataOfOperationNode->get()->id);
        const syrec::expression::ptr operandAsExpr                 = *expressionTraversalHelper->getOperandAsExpr(operationNodeIdOfFirstOperand);
        simplificationResultOfOperationNode                        = std::make_unique<OperationOperandSimplificationResult>(OperationOperandSimplificationResult::createManuallyFrom(operandAsExpr));
    }
    return OperationNodeProcessingResult::fromResult(std::move(simplificationResultOfOperationNode));
}


bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::canAlternativeByChosenInOperationNode(std::size_t operationNodeId, Decision::ChoosenOperand toBeChosenAlternative, const syrec::VariableAccess& signalAccess, const syrec::VariableAccess& alternativeToCheckAsSignalAccess, const parser::SymbolTable& symbolTable) const {
    return expressionTraversalHelper->canSignalBeUsedOnAssignmentLhs(signalAccess.var->name)
        && !didPreviousDecisionMatchingChoiceCauseConflict(LearnedConflictsLookupKey(operationNodeId, toBeChosenAlternative))
        && !doSignalAccessesOverlap(alternativeToCheckAsSignalAccess, signalAccess, symbolTable)
        && !isChoiceOfSignalAccessBlockedByAnyActiveExpression(signalAccess);
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::canAlternativeByChosenInOperationNode(std::size_t operationNodeId, Decision::ChoosenOperand toBeChosenAlternative, const syrec::VariableAccess& signalAccess, const syrec::expression& alternativeToCheckAsExpr, const parser::SymbolTable& symbolTable) const {
    return expressionTraversalHelper->canSignalBeUsedOnAssignmentLhs(signalAccess.var->name)
        && !didPreviousDecisionMatchingChoiceCauseConflict(LearnedConflictsLookupKey(operationNodeId, toBeChosenAlternative))
        && !doesExprContainOverlappingAccessOnGivenSignalAccess(alternativeToCheckAsExpr, signalAccess, symbolTable)
        && !isChoiceOfSignalAccessBlockedByAnyActiveExpression(signalAccess);
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::isAccessedSignalAssignable(const std::string_view& accessedSignalIdent) const {
    return symbolTableReference && symbolTableReference->canSignalBeAssignedTo(accessedSignalIdent).value_or(false);
}


std::optional<double> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineCostOfExpr(const syrec::expression& expr, std::size_t currentNestingLevel) const {
    if (const auto& exprAsBinaryExpr = dynamic_cast<const syrec::BinaryExpression*>(&expr); exprAsBinaryExpr) {
        ++currentNestingLevel;
        const std::optional<double> costOfLhsExpr = determineCostOfExpr(*exprAsBinaryExpr->lhs, currentNestingLevel);
        const std::optional<double> costOfRhsExpr = costOfLhsExpr.has_value() ? determineCostOfExpr(*exprAsBinaryExpr->rhs, currentNestingLevel) : std::nullopt;

        if (costOfRhsExpr.has_value()) {
            return (internalConfig.expressionNestingPenaltyScalingPerNestingLevel * currentNestingLevel * internalConfig.expressionNestingPenalty) + *costOfLhsExpr + *costOfRhsExpr;
        }
        return std::nullopt;
    }
    if (const auto& exprAsShiftExpr = dynamic_cast<const syrec::ShiftExpression*>(&expr); exprAsShiftExpr) {
        ++currentNestingLevel;
        const std::optional<double> costOfToBeShiftedExpr = determineCostOfExpr(*exprAsShiftExpr->lhs, currentNestingLevel);
        const std::optional<double> costOfShiftAmount     = costOfToBeShiftedExpr.has_value() ? determineCostOfNumber(*exprAsShiftExpr->rhs, currentNestingLevel) : std::nullopt;

        if (costOfShiftAmount.has_value()) {
            return (internalConfig.expressionNestingPenaltyScalingPerNestingLevel * currentNestingLevel * internalConfig.expressionNestingPenalty) + *costOfToBeShiftedExpr + *costOfShiftAmount;
        }
        return std::nullopt;
    }
    if (const auto& exprAsNumericExpr = dynamic_cast<const syrec::NumericExpression*>(&expr); exprAsNumericExpr) {
        return determineCostOfNumber(*exprAsNumericExpr->value, currentNestingLevel + 1);
    }
    if (const auto& exprAsVariableExpr = dynamic_cast<const syrec::VariableExpression*>(&expr); exprAsVariableExpr) {
        return 1;
    }
    return std::nullopt;
}

std::optional<double> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineCostOfAssignment(const syrec::AssignStatement& assignment) const {
    return determineCostOfExpr(*assignment.rhs, 0);
}

std::optional<double> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineCostOfNumber(const syrec::Number& number, std::size_t currentNestingLevel) const {
    if (number.isCompileTimeConstantExpression()) {
        const std::optional<syrec::BinaryExpression::ptr> numericExprAsBinaryExpr = convertCompileTimeConstantExprToBinaryExpr(number.getExpression(), 0);
        return numericExprAsBinaryExpr.has_value() ? determineCostOfExpr(**numericExprAsBinaryExpr, currentNestingLevel + 1) : std::nullopt;
    }
    return 1;
}

std::optional<double> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineCostOfAssignments(const syrec::AssignStatement::vec& assignments) const {
    std::optional<std::size_t> determinedCost;
    for (const syrec::AssignStatement::ptr& assignment : assignments) {
        if (const auto&                          assignmentCasted = std::dynamic_pointer_cast<const syrec::AssignStatement>(assignment); assignmentCasted) {
            if (const std::optional<std::size_t> costOfAssignment = determineCostOfAssignment(*assignmentCasted); costOfAssignment.has_value()) {
                determinedCost = determinedCost.value_or(0) + *costOfAssignment;
                continue;
            }
        }
        break;
    }
    return determinedCost;
}


syrec::AssignStatement::vec noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineMostViableAlternativeBasedOnCost(const syrec::AssignStatement::vec& generatedSimplifiedAssignments, const std::shared_ptr<syrec::AssignStatement>& originalAssignmentUnoptimized, const SignalValueLookupCallback& signalValueCallback) const {
    if (!generatedSimplifiedAssignments.empty() && (!doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(*originalAssignmentUnoptimized->rhs) || internalConfig.preferAssignmentsGeneratedByChoiceRegardlessOfCost)) {
        return generatedSimplifiedAssignments;
    }
    
    syrec::AssignStatement::vec containerForUnoptimizedTopmostAssignment = std::vector<syrec::AssignStatement::ptr>(1, originalAssignmentUnoptimized);
    containerForUnoptimizedTopmostAssignment                             = assignmentTransformer->simplify(containerForUnoptimizedTopmostAssignment, signalValueCallback);

    if (generatedSimplifiedAssignments.empty()) {
        return containerForUnoptimizedTopmostAssignment;
    }

    const std::optional<std::size_t> costOfSimplifiedAssignments = determineCostOfAssignments(generatedSimplifiedAssignments);
    const std::optional<std::size_t> costOfSimplifiedAssignmentsOfTopmostAssignment = determineCostOfAssignments(containerForUnoptimizedTopmostAssignment);

    if (!costOfSimplifiedAssignments.has_value() || !costOfSimplifiedAssignmentsOfTopmostAssignment.has_value()) {
        return generatedSimplifiedAssignments;
    }

    if (*costOfSimplifiedAssignments < *costOfSimplifiedAssignmentsOfTopmostAssignment || (*costOfSimplifiedAssignments == *costOfSimplifiedAssignmentsOfTopmostAssignment && internalConfig.useGeneratedAssignmentsByDecisionAsTieBreaker)) {
        return generatedSimplifiedAssignments;
    }
    return containerForUnoptimizedTopmostAssignment;
}

syrec::expression::ptr noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::fuseExpressions(const syrec::expression::ptr& lhsOperand, syrec_operation::operation op, const syrec::expression::ptr& rhsOperand) {
    if (syrec_operation::isOperationShiftOperation(op)) {
        const auto& rhsOperandAsNumericExpr = std::dynamic_pointer_cast<syrec::NumericExpression>(rhsOperand);
        const auto  generatedShiftExpr      = std::make_shared<syrec::ShiftExpression>(
                lhsOperand,
                *syrec_operation::tryMapShiftOperationEnumToFlag(op),
                rhsOperandAsNumericExpr->value);
        return generatedShiftExpr;
    }
    const auto generatedBinaryExpr = std::make_shared<syrec::BinaryExpression>(lhsOperand, *syrec_operation::tryMapBinaryOperationEnumToFlag(op), rhsOperand);
    return generatedBinaryExpr;
}

std::optional<syrec::AssignStatement::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryCreateAssignmentForOperationNode(const syrec::VariableAccess::ptr& assignmentLhs, syrec_operation::operation op, const syrec::expression::ptr& assignmentRhs) {
    if (const auto matchingAssignmentOperationForOperation = syrec_operation::getMatchingAssignmentOperationForOperation(op); matchingAssignmentOperationForOperation.has_value()) {
        const auto& mappedToAssignmentOperationFlag = syrec_operation::tryMapAssignmentOperationEnumToFlag(*matchingAssignmentOperationForOperation);
        const auto& generatedAssignment = std::make_shared<syrec::AssignStatement>(assignmentLhs, *mappedToAssignmentOperationFlag, assignmentRhs);
        return generatedAssignment;
    }
    return std::nullopt;
}

syrec::expression::ptr noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::createExpressionFrom(const syrec::expression::ptr& lhsOperand, syrec_operation::operation op, const syrec::expression::ptr& rhsOperand) {
    if (syrec_operation::isOperationShiftOperation(op)) {
        const auto& rhsOperandAsNumericExpr = std::dynamic_pointer_cast<syrec::NumericExpression>(rhsOperand);
        const auto  generatedShiftExpr      = std::make_shared<syrec::ShiftExpression>(
                lhsOperand,
                *syrec_operation::tryMapShiftOperationEnumToFlag(op),
                rhsOperandAsNumericExpr->value);
        return generatedShiftExpr;
    }
    const auto generatedBinaryExpr = std::make_shared<syrec::BinaryExpression>(lhsOperand, *syrec_operation::tryMapBinaryOperationEnumToFlag(op), rhsOperand);
    return generatedBinaryExpr;
}

syrec::expression::ptr noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::createExpressionFromOperationNode(const ExpressionTraversalHelper::ptr& expressionTraversalHelper, const ExpressionTraversalHelper::OperationNodeReference& operationNode) {
    const auto& lhsOperandData = expressionTraversalHelper->getOperandAsExpr(operationNode->lhsOperand.id);
    const auto& rhsOperandData = expressionTraversalHelper->getOperandAsExpr(operationNode->rhsOperand.id);
    return createExpressionFrom(*lhsOperandData, operationNode->operation, *rhsOperandData);
}

inline syrec::expression::ptr noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::createExpressionFromOperandSimplificationResult(const OperationOperandSimplificationResult& operandSimplificationResult) {
    if (const auto& lastAssignedToSignalInOperandSimplificationResult = operandSimplificationResult.getAssignedToSignalOfAssignment(); lastAssignedToSignalInOperandSimplificationResult.has_value()) {
        return std::make_shared<syrec::VariableExpression>(*lastAssignedToSignalInOperandSimplificationResult);
    }
    return *operandSimplificationResult.getGeneratedExpr();
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesExpressionDefineNestedSplitableExpr(const syrec::expression& expr) {
    // We are assuming here that compile time constant expressions were already converted to binary expressions
    return dynamic_cast<const syrec::BinaryExpression*>(&expr) != nullptr || dynamic_cast<const syrec::ShiftExpression*>(&expr) != nullptr;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesExpressionDefineNumber(const syrec::expression& expr) {
    return dynamic_cast<const syrec::NumericExpression*>(&expr) != nullptr;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesExprDefineSignalAccess(const syrec::expression& expr) {
    return dynamic_cast<const syrec::VariableExpression*>(&expr);
}

std::optional<syrec::AssignStatement::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryCreateAssignmentFromOperands(Decision::ChoosenOperand chosenOperandAsAssignedToSignal, const OperationOperandSimplificationResult& simplificationResultOfFirstOperand, syrec_operation::operation operationNodeOperation, const OperationOperandSimplificationResult& simplificationResultOfSecondOperand) {
    if (chosenOperandAsAssignedToSignal == Decision::ChoosenOperand::None) {
        return std::nullopt;   
    }

    const std::optional<syrec::VariableAccess::ptr> lastAssignedToSignalOfFirstOperand = simplificationResultOfFirstOperand.getAssignedToSignalOfAssignment();
    const std::optional<syrec::VariableAccess::ptr> lastAssignedToSignalOfSecondOperand = simplificationResultOfSecondOperand.getAssignedToSignalOfAssignment();

    if ((chosenOperandAsAssignedToSignal == Decision::ChoosenOperand::Left && !lastAssignedToSignalOfFirstOperand.has_value()) || (chosenOperandAsAssignedToSignal == Decision::ChoosenOperand::Right && !lastAssignedToSignalOfSecondOperand.has_value())) {
        return std::nullopt;
    }

    syrec::VariableAccess::ptr assignedToSignalOfGeneratedAssignment;
    syrec::expression::ptr     generatedAssignmentRhsExpr;
    if (chosenOperandAsAssignedToSignal == Decision::ChoosenOperand::Left) {
        assignedToSignalOfGeneratedAssignment = *lastAssignedToSignalOfFirstOperand;
        if (lastAssignedToSignalOfSecondOperand.has_value()) {
            generatedAssignmentRhsExpr = std::make_shared<syrec::VariableExpression>(*lastAssignedToSignalOfSecondOperand);
        } else {
            generatedAssignmentRhsExpr = *simplificationResultOfSecondOperand.getGeneratedExpr();
        }
    } else {
        assignedToSignalOfGeneratedAssignment = *lastAssignedToSignalOfSecondOperand;
        if (lastAssignedToSignalOfFirstOperand.has_value()) {
            generatedAssignmentRhsExpr = std::make_shared<syrec::VariableExpression>(*lastAssignedToSignalOfFirstOperand);
        } else {
            generatedAssignmentRhsExpr = *simplificationResultOfFirstOperand.getGeneratedExpr();
        }
    }

    const auto& generatedAssignment = tryCreateAssignmentForOperationNode(assignedToSignalOfGeneratedAssignment, operationNodeOperation, generatedAssignmentRhsExpr);
    return generatedAssignment;
}

std::optional<syrec::expression::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryCreateExpressionFromOperationNodeOperandSimplifications(const OperationOperandSimplificationResult& simplificationResultOfFirstOperand, syrec_operation::operation operationNodeOperation, const OperationOperandSimplificationResult& simplificationResultOfSecondOperand) {
    syrec::expression::ptr generatedExprLhsOperand;
    syrec::expression::ptr generatedExprRhsOperand;
    
    if (const std::optional<syrec::VariableAccess::ptr> lastAssignedToSignalOfFirstOperand = simplificationResultOfFirstOperand.getAssignedToSignalOfAssignment(); lastAssignedToSignalOfFirstOperand.has_value()) {
        generatedExprLhsOperand = std::make_shared<syrec::VariableExpression>(*lastAssignedToSignalOfFirstOperand);
    }
    else {
        generatedExprLhsOperand = *simplificationResultOfFirstOperand.getGeneratedExpr();
    }

    if (const std::optional<syrec::VariableAccess::ptr> lastAssignedToSignalOfSecondOperand = simplificationResultOfSecondOperand.getAssignedToSignalOfAssignment(); lastAssignedToSignalOfSecondOperand.has_value()) {
        generatedExprRhsOperand = std::make_shared<syrec::VariableExpression>(*lastAssignedToSignalOfSecondOperand);
    }
    else {
        generatedExprRhsOperand = *simplificationResultOfSecondOperand.getGeneratedExpr();
    }
    return fuseExpressions(generatedExprLhsOperand, operationNodeOperation, generatedExprRhsOperand);
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::areAssignedToSignalPartsZero(const syrec::VariableAccess& accessedSignalParts, const SignalValueLookupCallback& signalValueLookupCallback) {
    const std::optional<unsigned int> fetchedValueOfAccessedSignalParts = signalValueLookupCallback(accessedSignalParts);
    return fetchedValueOfAccessedSignalParts.has_value() && !*fetchedValueOfAccessedSignalParts;
}

// TODO: One could extend this condition to also include that non-reversible operations are only defined at operations nodes with only leaf nodes
bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(const syrec::expression& expr) {
    if (const auto& exprAsNumericExpr = dynamic_cast<const syrec::NumericExpression*>(&expr); exprAsNumericExpr) {
        return !exprAsNumericExpr->value->isCompileTimeConstantExpression();
    }
    if (const auto& exprAsVariableExpr = dynamic_cast<const syrec::VariableExpression*>(&expr); exprAsVariableExpr) {
        return true;
    }
    if (const auto& exprAsBinaryExpr = dynamic_cast<const syrec::BinaryExpression*>(&expr); exprAsBinaryExpr) {
        const std::optional<syrec_operation::operation> mappedToBinaryOperationEnumValue = syrec_operation::tryMapBinaryOperationFlagToEnum(exprAsBinaryExpr->op);
        if (mappedToBinaryOperationEnumValue.has_value() && syrec_operation::getMatchingAssignmentOperationForOperation(*mappedToBinaryOperationEnumValue).has_value()) {
            if (*mappedToBinaryOperationEnumValue == syrec_operation::operation::BitwiseXor) {
                return !(doesExpressionDefineNestedSplitableExpr(*exprAsBinaryExpr->lhs) && doesExpressionDefineNestedSplitableExpr(*exprAsBinaryExpr->rhs))
                    && doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(*exprAsBinaryExpr->lhs) && doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(*exprAsBinaryExpr->rhs);
            }
            return doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(*exprAsBinaryExpr->lhs) && doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(*exprAsBinaryExpr->rhs);
        }
    }
    return false;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryConvertNumericToBinaryExpr(syrec::expression::ptr& expr) {
    if (const auto& lhsExprAsNumericExpr = std::dynamic_pointer_cast<const syrec::NumericExpression>(expr)) {
        if (const auto& lhsNumericExprAsBinaryExpr = convertNumericExprToBinary(*lhsExprAsNumericExpr); lhsNumericExprAsBinaryExpr.has_value()) {
            expr = *lhsNumericExprAsBinaryExpr;
        }
    }
}


std::optional<syrec::BinaryExpression::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::convertNumericExprToBinary(const syrec::NumericExpression& numericExpr) {
    if (!numericExpr.value->isCompileTimeConstantExpression()) {
        return std::nullopt;
    }
    return convertCompileTimeConstantExprToBinaryExpr(numericExpr.value->getExpression(), numericExpr.bwidth);
}

std::optional<syrec_operation::operation> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryMapCompileTimeConstantExprOperationToBinaryOperation(syrec::Number::CompileTimeConstantExpression::Operation operation) {
    switch (operation) {
        case syrec::Number::CompileTimeConstantExpression::Addition:
            return syrec_operation::operation::Addition;
        case syrec::Number::CompileTimeConstantExpression::Subtraction:
            return syrec_operation::operation::Subtraction;
        case syrec::Number::CompileTimeConstantExpression::Multiplication:
            return syrec_operation::operation::Multiplication;
        case syrec::Number::CompileTimeConstantExpression::Division:
        default:
            return std::nullopt;
    }
}

syrec::expression::ptr noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::convertNumberToExpr(const syrec::Number::ptr& number, unsigned int expectedBitwidth) {
    if (number->isCompileTimeConstantExpression()) {
        if (const std::optional<syrec::BinaryExpression::ptr> mappedToBinaryExpr = convertCompileTimeConstantExprToBinaryExpr(number->getExpression(), expectedBitwidth); mappedToBinaryExpr.has_value()) {
            return *mappedToBinaryExpr;
        }
        return nullptr;
    }

    const syrec::NumericExpression::ptr generatedExpr = std::make_shared<syrec::NumericExpression>(number, expectedBitwidth);
    return generatedExpr;
}

std::optional<syrec::BinaryExpression::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::convertCompileTimeConstantExprToBinaryExpr(const syrec::Number::CompileTimeConstantExpression& compileTimeConstantExpr, unsigned int expectedBitwidth) {
    const std::optional<syrec_operation::operation> mappedToOperation = tryMapCompileTimeConstantExprOperationToBinaryOperation(compileTimeConstantExpr.operation);
    if (!mappedToOperation.has_value()) {
        return std::nullopt;
    }

    const syrec::expression::ptr& lhsOperandConverted = convertNumberToExpr(compileTimeConstantExpr.lhsOperand, expectedBitwidth);
    const syrec::expression::ptr& rhsOperandConverted = convertNumberToExpr(compileTimeConstantExpr.rhsOperand, expectedBitwidth);
    if (!lhsOperandConverted || !rhsOperandConverted) {
        return std::nullopt;
    }

    const syrec::BinaryExpression::ptr generatedExpr = std::make_shared<syrec::BinaryExpression>(lhsOperandConverted, *syrec_operation::tryMapBinaryOperationEnumToFlag(*mappedToOperation), rhsOperandConverted);
    return generatedExpr;
}

syrec::expression::ptr noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::transformExprBeforeProcessing(const syrec::expression::ptr& initialExpr) {
    if (const auto& exprAsNumericExpr = std::dynamic_pointer_cast<syrec::NumericExpression>(initialExpr); exprAsNumericExpr) {
        if (const auto& exprConverted = convertNumericExprToBinary(*exprAsNumericExpr); exprConverted.has_value()) {
            return *exprConverted;
        }
    }
    return initialExpr;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesExprContainOverlappingAccessOnGivenSignalAccess(const syrec::expression& expr, const syrec::VariableAccess& signalAccess, const parser::SymbolTable& symbolTable) {
    if (const auto& exprAsBinaryExpr = dynamic_cast<const syrec::BinaryExpression*>(&expr); exprAsBinaryExpr) {
        return doesExprContainOverlappingAccessOnGivenSignalAccess(*exprAsBinaryExpr->lhs, signalAccess, symbolTable) || doesExprContainOverlappingAccessOnGivenSignalAccess(*exprAsBinaryExpr->rhs, signalAccess, symbolTable);
    }
    if (const auto& exprAsShiftExpr = dynamic_cast<const syrec::ShiftExpression*>(&expr); exprAsShiftExpr) {
        return doesExprContainOverlappingAccessOnGivenSignalAccess(*exprAsShiftExpr->lhs, signalAccess, symbolTable) || doesNumberContainOverlappingAccessOnGivenSignalAccess(*exprAsShiftExpr->rhs, signalAccess, symbolTable);
    }
    if (const auto& exprAsVariableExpr = dynamic_cast<const syrec::VariableExpression*>(&expr); exprAsVariableExpr) {
        return doSignalAccessesOverlap(signalAccess, *exprAsVariableExpr->var, symbolTable);
    }
    if (const auto& exprAsNumericExpr = dynamic_cast<const syrec::NumericExpression*>(&expr); exprAsNumericExpr) {
        return doesNumberContainOverlappingAccessOnGivenSignalAccess(*exprAsNumericExpr->value, signalAccess, symbolTable);
    }
    return false;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesNumberContainOverlappingAccessOnGivenSignalAccess(const syrec::Number& number, const syrec::VariableAccess& signalAccess, const parser::SymbolTable& symbolTable) {
    if (!number.isCompileTimeConstantExpression()) {
        return false;
    }

    const auto& numericExprAsBinaryOne = convertCompileTimeConstantExprToBinaryExpr(number.getExpression(), 0);
    return numericExprAsBinaryOne.has_value() && doesExprContainOverlappingAccessOnGivenSignalAccess(**numericExprAsBinaryOne, signalAccess, symbolTable);
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doSignalAccessesOverlap(const syrec::VariableAccess& firstSignalAccess, const syrec::VariableAccess& otherSignalAccess, const parser::SymbolTable& symbolTable) {
    const SignalAccessUtils::SignalAccessEquivalenceResult equivalenceResult = SignalAccessUtils::areSignalAccessesEqual(
            firstSignalAccess, otherSignalAccess,
            SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::DimensionAccess::Overlapping,
            SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::BitRange::Overlapping,
            symbolTable);
    return !equivalenceResult.isResultCertain || equivalenceResult.equality != SignalAccessUtils::SignalAccessEquivalenceResult::NotEqual;
}

constexpr bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::shouldLogMessageBePrinted() {
    #ifndef NDEBUG
    return true;
    #else
    return false;
    #endif
}

std::string noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::stringifyChosenOperandForLogMessage(Decision::ChoosenOperand chosenOperand) {
    switch (chosenOperand) {
        case Decision::ChoosenOperand::Left:
            return "LEFT";
        case Decision::ChoosenOperand::Right:
            return "RIGHT";
        case Decision::ChoosenOperand::None:
            return "NONE";
        default:
            return "UNKNOWN";
    }
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logDecision(const DecisionReference& madeDecision) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }
    logMessage(fmt::format("Decision @ operation node {:d} choose operand {:s} | Decision repeated: {:s} \n", madeDecision->operationNodeId, stringifyChosenOperandForLogMessage(madeDecision->choosenOperand), madeDecision->shouldChoiceBeRepeatedFlag));
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logConflict(std::size_t operationNodeId, Decision::ChoosenOperand operandCausingConflict, const syrec::VariableAccess& signalAccessCausingConflict, const std::optional<std::size_t>& idOfEarliestDecisionInvolvedInConflict) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }
    const std::size_t printableIdOfEarliestOperationNodeInvolvedInConflict = idOfEarliestDecisionInvolvedInConflict.value_or(0);
    logMessage(fmt::format("Conflict @ operation node {:d} detected by usage of operand {:s} (i.e. signal access {:s} which overlaps decision made in operation node {:d}\n", operationNodeId, stringifyChosenOperandForLogMessage(operandCausingConflict), signalAccessCausingConflict.var->name, printableIdOfEarliestOperationNodeInvolvedInConflict));
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logStartOfProcessingOfOperationNode(std::size_t operationNodeId) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }
    logMessage(fmt::format("START Processing operation node {:d}\n", operationNodeId));
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logEndOfProcessingOfOperationNode(std::size_t operationNodeId) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }
    logMessage(fmt::format("END Processing operation node {:d}\n", operationNodeId));
}


void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logBacktrackingResult(std::size_t operationNodeIdAtStartOfBacktracking, std::size_t nextOperationNodeAfterBacktrackingFinished) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }
    logMessage(fmt::format("Backtracking started @ operation node with id {:d} | finished @ operation node with id {:d} as next to be processed\n", operationNodeIdAtStartOfBacktracking, nextOperationNodeAfterBacktrackingFinished));
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logMarkingOfOperationNodeAsSourceOfConflict(std::size_t operationNodeId) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }
    logMessage(fmt::format("Marking operation node {:d} as source of conflict\n", operationNodeId));
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logMessage(const std::string& msg) {
    fmt::print(stdout, msg);
}