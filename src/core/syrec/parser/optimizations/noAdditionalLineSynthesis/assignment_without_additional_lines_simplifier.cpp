#include "core/syrec/parser/optimizations/noAdditionalLineSynthesis/assignment_without_additional_lines_simplifier.hpp"
#include "core/syrec/parser/utils/copy_utils.hpp"
#include "core/syrec/parser/utils/signal_access_utils.hpp"

#ifndef NDEBUG
#include "fmt/format.h"
#endif

/*
 * TODO: IMPORTANT (testcase simplificationWithOnlyReversibleOpsAndUniqueSignalAccessesWithTopmostAssignmentBeingXorCorrectlyHandlesMixedOperationsInRhsExpr) is missing required inversion of assignments
 *
 * TODO: Add as a precondition that no signal accesses overlapping the lhs operand of the initial assignment exists on the rhs which should already be done by the caller but a safety to prevent invalid assignments generated by this simplifier
 * TODO: When inverting all active assignments during processing of operation node, we should not "deactivated" active assignments that operate on the same signal as the chosen one in the operation node - IMPORTANT
 * TODO: Are active assignments added to set determining conflicts
 * TODO: If a decision was prevented by learned conflict the generated expr could be further simplified in the parent operation node (i.e. b += (d - 2) was created when the learned conflict was d and could be simplified to b += d; b -= 2)
 *
 * TODO: If original rhs expr does only consist of invertible operations (with xor only defined for leaf nodes) fallback to expression split
 * TODO: Shift expressions are currently not handled since the shift amount is a number::ptr instead of an expression::ptr
 *
 *
 * TODO: Currently we have a problem to fine a correct metric to decide whether we should perform our "simple" or "complex" simplification algorithm if the assignment only contains reversible operations (its a problem since the "complex" algorithm leads to a larger code size due to a larger number of assignments being created)
 * TODO: IMPORTANT: When a conflict arises we should only remember the conflict at the earliest node to not prevent the reuse of assignment that could lead to conflicts but are "defused" by an assignment higher in the traversal queue
 * TODO: NICE-TO-HAVE: Try to perform constant propagation and further optimizations if value of any signal changes during simplifications
 *
 * TODO: Reordering sequences of assignment statements could lead to further optimization potential, see test case simplificationWithOnlyReversibleOpsAndUniqueSignalAccessHandlesRhsCorrectlyIfRhsCreatesNoAssignmentAndAssignmentOperationIsXorAndTopmostOperationOfRhsIsMinusAndAssignedtoSignalValueIsNotZero
 * TODO: Could the simplification (a - (b + c)) = (a - (c - b)) lead to further optimizations?
 *
 * TODO: Some cases could offer new optimizations: module main(out a(16), inout b(16), in c(16), in d(16)) a += (((b - c) + b) * d) [see simplification of previous point])
 *
 * TODO: IMPORTANT - When processing a rhs of an expression we cannot use any operand use in the lhs expr (how can we do this efficiently, does this check need to be done everytime)
 * TODO: IMPORTANT - Check whether we need to add additional tests for the the tie breaker flag is not specified and the simplified assignments of the original assignment cost less than the simplified ones
 * TODO: IMPORTANT - Check the metric chosen for the weighting, if our topmost expression has a nesting level of two but the simplified ones only have a nesting level of 1 but the latter is inverted once
 * (i.e.) a += ((b + c) + d) being the topmost assignment while the simplified ones are d += (b + c); a ^= d; d -= (b + c). [Also add tests for this]
 * TODO: IMPORTANT - The split of an simplified assignment (i.e. a -= (b + 2)) at the topmost level leads to the sequence a -= b; a -= 2 ... a += b; a += 2
 *  if the split would take place immediately after the creation of the assignment would lead to the sequence a += b; a += 2 ... a -= b; a -= 2
 *
 * TODO: Testcase 'simplifyWithOnlyReversibleOpsButNonUniqueSignalAccessWithAssignOperationBeingAdditionWithDegeneratedLhsSubASTOfLhsOfAssignmentExpr' is an example where the heuristic optimization of - (<subExpr_1> - <subExpr_2>) leads to a worse result
 *
 * TODO: Should the decisions for intermediate operation nodes (i.e. with non-leaf nodes be extendened from the simple left, right distinction to a lookup) ?
 *
 * TODO: IMPORTANT: Rework of conflict handling that conflicting decision could be remade when reset in by a parent decision (check detection of hot path, found earliest conflict node, etc.)
 * TODO: IMPORTANT: Tests that decision are remade not on hot path
 * TODO: IMPORTANT: Assignments using boxing (i.e. operand has bitwidth 5 instead of 4) should not be able to be processed
 * TODO: IMPORTANT: Assignment where the bitwidth is unknown will not use replacements
 */

// TODO: We should probably also validate that the optimized circuit that is created after a successful parse is also correct
// TODO: Correct update of reference counts for simplification of assignments with no additional lines

/*
 * REPLACEMENT GENERATOR TODOS:
 * - Correct reference count updates for new signals
 * - Correct insertion of new signals into symbol table
 * - Correct reference count updates when assignment is simplified (i.e. split into smaller subassignments)
 * - Fixed replacement generator for example ((a + b) + (a + b)) to generate replacement __x ^= a; ... and not __x ^= (a + b) [see test case 'simpleReplacementTest']
 */

/*
 * Ideas for the introduction of replacements:
 * - Replace signal accesses at operation nodes which are the cause of the conflict with a replacement
 * - Replace expressions with replacements (synthesizing the expression y += (a * (b + c)) is more costly than x ^= (b + c); y += (a * x)?
 * - Replacements should at first be looked for in existing signals that are unused in the expression and only if none are available should extra signals be introduced
 */
// TODO: CHECK TEST simplificationWithNoneReversibleOperationWithXorAssignOperationAndTopmostOperationOfRhsBeingAdditionOperationWithLhsGeneratingAssignmentAndRhsGeneratingAssignmentCreatesCorrectAssignment FOR FAILED ROLLBACK
noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::SimplificationResultReference noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::simplify(const syrec::AssignStatement& assignmentStatement, const SignalValueLookupCallback& signalValueLookupCallback) {
    resetInternals();
    if (!symbolTableReference) {
        SimplificationResult result = SimplificationResult::asEmptyResult();
        return std::make_unique<SimplificationResult>(std::move(result)); 
    }

    // TODO: For a binary expression with no nested expressions as operands, should we prefer that a signal access is always the lhs operand
    const std::shared_ptr<syrec::AssignStatement> transformedAssignmentStmt = transformAssignmentPriorToSimplification(assignmentStatement, true);
    if (!transformedAssignmentStmt) {
        SimplificationResult          simplificationResult          = SimplificationResult::asEmptyResult();
        SimplificationResultReference simplificationResultContainer = std::make_unique<SimplificationResult>(std::move(simplificationResult));
        return simplificationResultContainer;
    }

    expressionTraversalHelper->buildTraversalQueue(transformedAssignmentStmt->rhs, *symbolTableReference);
    disableValueLookup();
    const std::vector<syrec::VariableAccess::ptr> replacementCandidateRestrictionsStemmingFromAssignment = defineNotUsableReplacementCandidatesFromAssignmentForGenerator(*transformedAssignmentStmt);
    determinedBitWidthOfAssignmentToSimplify                                                             = determineBitwidthOfSignalAccess(*assignmentStatement.lhs);

    bool                                                               continueProcessingOperationNode = true;
    std::optional<OwningOperationOperandSimplificationResultReference> simplificationResultOfTopmostOperationNode;
    while (continueProcessingOperationNode) {
        std::optional<ExpressionTraversalHelper::OperationNodeReference> topMostOperationNode = expressionTraversalHelper->getNextOperationNode();

        // TODO: If an expression is created for the rhs we can still try to split it if a binary operation with an assignment counterpart exists
        simplificationResultOfTopmostOperationNode = topMostOperationNode.has_value() ? handleOperationNode(*topMostOperationNode, signalValueLookupCallback) : std::nullopt;
        if (shouldBacktrackDueToConflict()) {
            markSourceOfConflictReached();
            backtrack(topMostOperationNode->get()->id, false);
        } else {
            continueProcessingOperationNode = !simplificationResultOfTopmostOperationNode.has_value();
        }
    }

    if (simplificationResultOfTopmostOperationNode.has_value()) {
        const auto& generatedExprForTopmostOperationRhsExpr = simplificationResultOfTopmostOperationNode->get()->getGeneratedExpr();
        const auto& generatedLastAssignedToSignalOfRhsExpr  = simplificationResultOfTopmostOperationNode->get()->getAssignedToSignalOfAssignment();

        syrec::VariableAccess::ptr generatedAssignmentAssignedToSignal = transformedAssignmentStmt->lhs;
        syrec::expression::ptr     generatedAssignmentRhsExpr;
        if (generatedLastAssignedToSignalOfRhsExpr.has_value()) {
            generatedAssignmentRhsExpr = std::make_shared<syrec::VariableExpression>(*generatedLastAssignedToSignalOfRhsExpr);
        } else {
            generatedAssignmentRhsExpr = *generatedExprForTopmostOperationRhsExpr;
        }

        const std::shared_ptr<syrec::AssignStatement> generatedAssignment = std::make_shared<syrec::AssignStatement>(
                generatedAssignmentAssignedToSignal,
                transformedAssignmentStmt->op,
                generatedAssignmentRhsExpr);
        const std::size_t currentNumberOfExistingAssignments = generatedAssignmentsContainer->getNumberOfAssignments();
        generatedAssignmentsContainer->storeActiveAssignment(generatedAssignment);
        const std::size_t numberOfAssignmentsToNotInvertStartingFromLastCreatedOne = generatedAssignmentsContainer->getNumberOfAssignments() - currentNumberOfExistingAssignments;
        generatedAssignmentsContainer->invertAllAssignmentsUpToLastCutoff(numberOfAssignmentsToNotInvertStartingFromLastCreatedOne, nullptr);
    }
    clearNotUsableReplacementCandidatesFromAssignmentForGenerator(replacementCandidateRestrictionsStemmingFromAssignment);

    bool                        wasAnyAssignmentGeneratedDuringProcessing = true;

    std::vector<TemporaryAssignmentsContainer::SharedAssignmentReference> generatedAssignments;
    if (!generatedAssignmentsContainer->getNumberOfAssignments()) {
        if (const std::shared_ptr<syrec::AssignStatement> topMostAssignmentStmtIfNoOptimizationTookPlace = transformedAssignmentStmt ? transformedAssignmentStmt : std::make_shared<syrec::AssignStatement>(assignmentStatement); topMostAssignmentStmtIfNoOptimizationTookPlace) {
            generatedAssignments.emplace_back(topMostAssignmentStmtIfNoOptimizationTookPlace);
            wasAnyAssignmentGeneratedDuringProcessing = false;
        }
    } else {
        generatedAssignments = generatedAssignmentsContainer->getAssignments();
    }

    /*
     * If any assignments where generated by our more "complex" algorithm, try to determine the more viable alternative by comparing the cost of the simplified assignments generated
     * by the more "simple" algorithm (if applicable) to the ones generated by the "complex" one.
     */
    generatedAssignments = assignmentTransformer->simplify(generatedAssignments, signalValueLookupCallback);
    if (wasAnyAssignmentGeneratedDuringProcessing) {
        SimplificationResultReference finalSimplificationResultInCaseAnyAssignmentWereGenerated;
        if (std::optional<SimplificationResult::OwningCopiesOfAssignment> requiredInversionsOfValueResetsAfterUsageOfGeneratedReplacements = generatedAssignmentsContainer->getInvertedAssignmentsUndoingValueResetsOfGeneratedSubstitutions(); requiredInversionsOfValueResetsAfterUsageOfGeneratedReplacements.has_value()) {
            if (std::optional<SimplificationResult::OwningCopiesOfAssignment> owningCopiesOfGeneratedAssignments = createOwningCopiesOfAssignments(generatedAssignments); owningCopiesOfGeneratedAssignments.has_value()) {
                if (std::optional<SimplificationResult::OwningCopiesOfAssignment> requiredValueResetsPriorToUsageOfGeneratedReplacements = generatedAssignmentsContainer->getAssignmentsDefiningValueResetsOfGeneratedSubstitutions(); requiredValueResetsPriorToUsageOfGeneratedReplacements.has_value()) {
                    const syrec::Variable::vec newlyGeneratedReplacementCandidates = substitutionGenerator ? substitutionGenerator->getDefinitionsOfReplacementsCreatedFromNewlyGeneratedSignals() : syrec::Variable::vec();
                    SimplificationResult       internalContainerOfSimplificationResult = SimplificationResult({
                        newlyGeneratedReplacementCandidates,
                        std::move(*owningCopiesOfGeneratedAssignments),
                        std::move(*requiredValueResetsPriorToUsageOfGeneratedReplacements),
                        std::move(*requiredInversionsOfValueResetsAfterUsageOfGeneratedReplacements)}
                    );
                    finalSimplificationResultInCaseAnyAssignmentWereGenerated          = std::make_unique<SimplificationResult>(std::move(internalContainerOfSimplificationResult));
                }
            }
        }
        // TODO: Update metric to include all generated assignments
        // TODO: Rework this check and maybe move it to if below (and also take reset and inversion of resets into account since the generated assignment do not include these)
        if (const std::shared_ptr<syrec::AssignStatement>& transformedAssignmentStmtWithoutAppliedHeuristicsForSubassignmentGeneration = transformAssignmentPriorToSimplification(assignmentStatement, false); transformedAssignmentStmtWithoutAppliedHeuristicsForSubassignmentGeneration) {
            if (SimplificationResultReference mostViableAlternative = determineMostViableAlternativeBasedOnCost(finalSimplificationResultInCaseAnyAssignmentWereGenerated, transformedAssignmentStmtWithoutAppliedHeuristicsForSubassignmentGeneration, signalValueLookupCallback); mostViableAlternative) {
                return mostViableAlternative;
            }      
        }
    }

    if (transformedAssignmentStmt) {
        if (std::optional<SimplificationResult::OwningCopyOfAssignment> owningCopyOfTransformedAssignment = createOwningCopyOfAssignment(*transformedAssignmentStmt); owningCopyOfTransformedAssignment.has_value()) {
            SimplificationResult result = SimplificationResult::asSingleStatement(std::move(*owningCopyOfTransformedAssignment));
            return std::make_unique<SimplificationResult>(std::move(result));
        }
    }
    SimplificationResult result = SimplificationResult::asEmptyResult();
    return std::make_unique<SimplificationResult>(std::move(result));
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::defineSymbolTable(const parser::SymbolTable::ptr& activeSymbolTableScope) {
    symbolTableReference = activeSymbolTableScope;
    temporaryExpressionsContainer->defineSymbolTable(symbolTableReference);
    if (substitutionGenerator) {
        substitutionGenerator->defineSymbolTable(symbolTableReference);   
    }
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::reloadGenerateableReplacementSignalName() {
    if (substitutionGenerator) {
        substitutionGenerator->loadLastNewlyGeneratedReplacementSignalInformation();   
    }
}

// START OF NON-PUBLIC FUNCTION IMPLEMENTATIONS
std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OwningOperationOperandSimplificationResultReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleOperationNode(const ExpressionTraversalHelper::OperationNodeReference& operationNode, const SignalValueLookupCallback& signalValueLookupCallback) {
    logStartOfProcessingOfOperationNode(operationNode->id);
    std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OwningOperationOperandSimplificationResultReference> simplificationResult;
    if (!operationNode->hasAnyLeafOperandNodes()) {
        simplificationResult = handleOperationNodeWithNoLeafNodes(operationNode, signalValueLookupCallback);
    }
    else if (operationNode->areBothOperandsLeafNodes()) {
        simplificationResult = handleOperationNodeWithOnlyLeafNodes(operationNode, signalValueLookupCallback);
    } else {
        simplificationResult = handleOperationNodeWithOneLeafNode(operationNode, signalValueLookupCallback);
    }
    logEndOfProcessingOfOperationNode(operationNode->id);
    return simplificationResult;
}

// TODO: If the simplification of any non-leaf node did result in a conflict check whether another decision at a previous position is possible, see other functions handling operation node with one leaf node
std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OwningOperationOperandSimplificationResultReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleOperationNodeWithNoLeafNodes(const ExpressionTraversalHelper::OperationNodeReference& operationNode, const SignalValueLookupCallback& signalValueLookupCallback) {
    std::optional<OwningOperationOperandSimplificationResultReference> firstOperandSimplificationResult;
    std::optional<OwningOperationOperandSimplificationResultReference> secondOperandSimplificationResult;
    syrec::expression::ptr                                             expressionToConsiderForDecisionInSecondNode;

    std::size_t numExistingAssignmentsPriorToAnyOperandHandled = 0;
    bool continueProcessing = true;
    while (continueProcessing) {
        numExistingAssignmentsPriorToAnyOperandHandled = generatedAssignmentsContainer->getNumberOfAssignments();
        generatedAssignmentsContainer->markCutoffForInvertibleAssignments();
        expressionTraversalHelper->markOperationNodeAsPotentialBacktrackOption(operationNode->id);

        OperationNodeProcessingResult firstOperandProcessingResult = processNextOperationNode(signalValueLookupCallback);
        if (firstOperandProcessingResult.derivedConflictInOtherNode) {
            generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
            return std::nullopt;
        }
        firstOperandSimplificationResult = std::move(firstOperandProcessingResult.simplificationResult);

        /*
         * If the first non-leaf node created an expression instead of an assignment, we need also need to take this generated expression as well as all active assignments into consideration
         * when processing the second non-leaf-node
         */
        expressionToConsiderForDecisionInSecondNode = firstOperandSimplificationResult->get()->getGeneratedExpr().value_or(nullptr);
        considerExpressionInFutureDecisions(expressionToConsiderForDecisionInSecondNode);

        /*
         * TODO: Is this comment correct
         * If we do not quit the processing loop of the second non-leaf operation node, we would only never reprocess the first non-leaf operation node again.
         */
        /*OperationNodeProcessingResult secondOperandProcessingResult = processNextOperationNode(signalValueLookupCallback, true);
        if (secondOperandProcessingResult.derivedConflictInOtherNode || isOperationNodeSourceOfConflict(operationNode->id)) {
            return std::nullopt;
        }*/
        OperationNodeProcessingResult secondOperandProcessingResult = processNextOperationNode(signalValueLookupCallback);
        if (secondOperandProcessingResult.derivedConflictInOtherNode) {
            generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
            return std::nullopt;
        }
        continueProcessing = secondOperandProcessingResult.derivedConflictInThisNode;
        if (!continueProcessing) {
            secondOperandSimplificationResult = std::move(secondOperandProcessingResult.simplificationResult);
        }
    }

    const DecisionReference madeDecision = makeDecision(operationNode, **firstOperandSimplificationResult, **secondOperandSimplificationResult, signalValueLookupCallback);
    /*
     * We need to revoke our consideration of the generated expression from the first non-leaf node of this operation node for any further decisions
     */
    revokeConsiderationOfExpressionForFutureDecisions(expressionToConsiderForDecisionInSecondNode);

    const std::variant<syrec::VariableAccess::ptr, syrec::expression::ptr> simplificationResultData = createFinalSimplificationResultAfterDecisionWasMade(madeDecision, **firstOperandSimplificationResult, operationNode->operation, **secondOperandSimplificationResult, signalValueLookupCallback);
    // We should probably not remove any past decisions since this would clash with the check whether a different choice could be made at a previous decision
    //removeDecisionFor(operationNode->id);

    expressionTraversalHelper->removeOperationNodeAsPotentialBacktrackOperation(operationNode->id);
    generatedAssignmentsContainer->popLastCutoffForInvertibleAssignments();

    const std::size_t numExistingAssignmentsAfterOperationNodeWasHandled = generatedAssignmentsContainer->getNumberOfAssignments();
    const std::size_t numGeneratedAssignmentsByHandlingOfOperationNode   = numExistingAssignmentsAfterOperationNodeWasHandled - numExistingAssignmentsPriorToAnyOperandHandled;
    return std::make_unique<OperationOperandSimplificationResult>(numGeneratedAssignmentsByHandlingOfOperationNode, simplificationResultData);
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OwningOperationOperandSimplificationResultReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleOperationNodeWithOneLeafNode(const ExpressionTraversalHelper::OperationNodeReference& operationNode, const SignalValueLookupCallback& signalValueLookupCallback) {
    expressionTraversalHelper->markOperationNodeAsPotentialBacktrackOption(operationNode->id);
    generatedAssignmentsContainer->markCutoffForInvertibleAssignments();
    const std::size_t numExistingAssignmentsPriorToHandlingOfOperationNode = generatedAssignmentsContainer->getNumberOfAssignments();

    const bool                                          wasLhsOperandLeafNode        = operationNode->getLeafNodeOperandId().value() == operationNode->lhsOperand.id;
    const std::optional<syrec::VariableExpression::ptr> dataOfLeafNodeAsVariableExpr = expressionTraversalHelper->getOperandAsVariableExpr(wasLhsOperandLeafNode ? operationNode->lhsOperand.id : operationNode->rhsOperand.id);

    if (dataOfLeafNodeAsVariableExpr.has_value()) {
        const auto& accessedSignalPartsOfLeafNode = std::dynamic_pointer_cast<syrec::VariableExpression>(*dataOfLeafNodeAsVariableExpr);
        if (wereAccessedSignalPartsModifiedByActiveAssignment(*accessedSignalPartsOfLeafNode->var)) {
            handleConflict(operationNode->id, wasLhsOperandLeafNode ? Decision::ChoosenOperand::Left : Decision::ChoosenOperand::Right, *accessedSignalPartsOfLeafNode->var);
            generatedAssignmentsContainer->popLastCutoffForInvertibleAssignments();
            backtrack(operationNode->id, false);
            return std::nullopt;
        }
    }

    std::optional<OwningOperationOperandSimplificationResultReference> simplificationResultOfOperationNodeOperand;
    bool continueProcessingOfNonLeafNode = true;
    while (continueProcessingOfNonLeafNode) {
       OperationNodeProcessingResult resultOfNonLeafNode = processNextOperationNode(signalValueLookupCallback);
        if (resultOfNonLeafNode.derivedConflictInOtherNode) {
           generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
           return std::nullopt;
        }
        simplificationResultOfOperationNodeOperand = std::move(resultOfNonLeafNode.simplificationResult);
        /*
        * We need to perform our conflict check twice, once prior to the processing of the subexpression define in one of the operands of this operation and also
        * after we have processed said subexpression, to determine whether the value of the leaf node was not changed in any of the sub-assignments generated during the processing
        * of said subexpression
        */
        if (dataOfLeafNodeAsVariableExpr.has_value()) {
            const auto& accessedSignalPartsOfLeafNode = std::dynamic_pointer_cast<syrec::VariableExpression>(*dataOfLeafNodeAsVariableExpr);
            if (wereAccessedSignalPartsModifiedByActiveAssignment(*accessedSignalPartsOfLeafNode->var)) {
                handleConflict(operationNode->id, wasLhsOperandLeafNode ? Decision::ChoosenOperand::Left : Decision::ChoosenOperand::Right, *accessedSignalPartsOfLeafNode->var);
                const bool isCurrentOperationNodeSourceOfConflict = isOperationNodeSourceOfConflict(operationNode->id);
                
                generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(!isCurrentOperationNodeSourceOfConflict);
                backtrack(operationNode->id, isCurrentOperationNodeSourceOfConflict);
                if (isCurrentOperationNodeSourceOfConflict) {
                    markSourceOfConflictReached();
                    simplificationResultOfOperationNodeOperand.reset();
                } else {
                    return std::nullopt;
                }
            }
        }
        continueProcessingOfNonLeafNode = !simplificationResultOfOperationNodeOperand.has_value();
    }
    
    DecisionReference                                                madeDecision = nullptr;
    std::variant<syrec::VariableAccess::ptr, syrec::expression::ptr> simplificationResultDataOfLeafNode;
    if (dataOfLeafNodeAsVariableExpr.has_value()) {
        simplificationResultDataOfLeafNode = std::dynamic_pointer_cast<syrec::VariableExpression>(*dataOfLeafNodeAsVariableExpr)->var;
    } else {
        simplificationResultDataOfLeafNode = *expressionTraversalHelper->getOperandAsExpr(wasLhsOperandLeafNode ? operationNode->lhsOperand.id : operationNode->rhsOperand.id);
    }
    OperationOperandSimplificationResult simplificationResultOfLeafNode = OperationOperandSimplificationResult::createManuallyFrom(simplificationResultDataOfLeafNode);

    // TODO: Semantic check for prior to assingment generation
    if (simplificationResultOfOperationNodeOperand.has_value()) {
        const syrec::expression::ptr temporaryExpressionToConsiderForDecision = simplificationResultOfOperationNodeOperand->get()->getGeneratedExpr().value_or(nullptr);
        considerExpressionInFutureDecisions(temporaryExpressionToConsiderForDecision);
        if (wasLhsOperandLeafNode) {
            madeDecision = makeDecision(operationNode, simplificationResultOfLeafNode, **simplificationResultOfOperationNodeOperand, signalValueLookupCallback);
        } else {
            madeDecision = makeDecision(operationNode, **simplificationResultOfOperationNodeOperand, simplificationResultOfLeafNode, signalValueLookupCallback);
        }
        revokeConsiderationOfExpressionForFutureDecisions(temporaryExpressionToConsiderForDecision);
    } else {
        const std::size_t operandIdOfNonLeafNode   = wasLhsOperandLeafNode ? operationNode->rhsOperand.id : operationNode->lhsOperand.id;
        simplificationResultOfOperationNodeOperand = std::make_unique<OperationOperandSimplificationResult>(OperationOperandSimplificationResult::createManuallyFrom(*expressionTraversalHelper->getOperandAsExpr(operandIdOfNonLeafNode)));   
    }
    expressionTraversalHelper->removeOperationNodeAsPotentialBacktrackOperation(operationNode->id);

    std::variant<syrec::VariableAccess::ptr, syrec::expression::ptr> simplificationResultData;
    if (wasLhsOperandLeafNode) {
        simplificationResultData = createFinalSimplificationResultAfterDecisionWasMade(madeDecision, simplificationResultOfLeafNode, operationNode->operation, **simplificationResultOfOperationNodeOperand, signalValueLookupCallback);
    }
    else {
        simplificationResultData = createFinalSimplificationResultAfterDecisionWasMade(madeDecision, **simplificationResultOfOperationNodeOperand, operationNode->operation, simplificationResultOfLeafNode, signalValueLookupCallback);
    }
    generatedAssignmentsContainer->popLastCutoffForInvertibleAssignments();

    const std::size_t numExistingAssignmentsAfterHandlingOfOperationNode = generatedAssignmentsContainer->getNumberOfAssignments();
    const std::size_t numGeneratedAssignmentsByHandlingOfOperationNode   = numExistingAssignmentsAfterHandlingOfOperationNode - numExistingAssignmentsPriorToHandlingOfOperationNode;
    auto simplificationResult                                            = std::make_unique<OperationOperandSimplificationResult>(numGeneratedAssignmentsByHandlingOfOperationNode, simplificationResultData);
    return simplificationResult;
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OwningOperationOperandSimplificationResultReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleOperationNodeWithOnlyLeafNodes(const ExpressionTraversalHelper::OperationNodeReference& operationNode, const SignalValueLookupCallback& signalValueLookupCallback) {
    generatedAssignmentsContainer->markCutoffForInvertibleAssignments();

    std::optional<std::shared_ptr<syrec::VariableAccess>> accessedSignalPartsOfFirstOperand;
    if (const auto& accessedSignalPartsExprOfFirstOperand = expressionTraversalHelper->getOperandAsVariableExpr(operationNode->lhsOperand.id); accessedSignalPartsExprOfFirstOperand.has_value()) {
        const auto accessedSignalPartsOfFirstOperandCasted = std::dynamic_pointer_cast<syrec::VariableExpression>(*accessedSignalPartsExprOfFirstOperand);
        accessedSignalPartsOfFirstOperand                  = accessedSignalPartsOfFirstOperandCasted->var;

        if (wereAccessedSignalPartsModifiedByActiveAssignment(**accessedSignalPartsOfFirstOperand)) {
            handleConflict(operationNode->id, Decision::ChoosenOperand::Left, **accessedSignalPartsOfFirstOperand);
            generatedAssignmentsContainer->popLastCutoffForInvertibleAssignments();
            return std::nullopt;
        }
    }

    std::optional<std::shared_ptr<syrec::VariableAccess>> accessedSignalPartsOfSecondOperand;
    if (const auto& accessedSignalPartsExprOfSecondOperand = expressionTraversalHelper->getOperandAsVariableExpr(operationNode->rhsOperand.id); accessedSignalPartsExprOfSecondOperand.has_value()) {
        const auto accessedSignalPartsOfSecondOperandCasted = std::dynamic_pointer_cast<syrec::VariableExpression>(*accessedSignalPartsExprOfSecondOperand);
        accessedSignalPartsOfSecondOperand                  = accessedSignalPartsOfSecondOperandCasted->var;
        
        if (wereAccessedSignalPartsModifiedByActiveAssignment(**accessedSignalPartsOfSecondOperand)) {
            handleConflict(operationNode->id, Decision::ChoosenOperand::Right, **accessedSignalPartsOfSecondOperand);
            generatedAssignmentsContainer->popLastCutoffForInvertibleAssignments();
            return std::nullopt;
        }
    }
    
    std::variant<syrec::VariableAccess::ptr, syrec::expression::ptr> simplificationResultDataOfFirstOperand;
    if (accessedSignalPartsOfFirstOperand.has_value()) {
        simplificationResultDataOfFirstOperand = *accessedSignalPartsOfFirstOperand;
    } else {
        simplificationResultDataOfFirstOperand = *expressionTraversalHelper->getOperandAsExpr(operationNode->lhsOperand.id);
    }
    OperationOperandSimplificationResult simplificationResultOfFirstOperand = OperationOperandSimplificationResult::createManuallyFrom(simplificationResultDataOfFirstOperand);
    
    std::variant<syrec::VariableAccess::ptr, syrec::expression::ptr> simplificationResultDataOfSecondOperand;
    if (accessedSignalPartsOfSecondOperand.has_value()) {
        simplificationResultDataOfSecondOperand = *accessedSignalPartsOfSecondOperand;
    } else {
        simplificationResultDataOfSecondOperand = *expressionTraversalHelper->getOperandAsExpr(operationNode->rhsOperand.id);
    }
    OperationOperandSimplificationResult                                   simplificationResultOfSecondOperand              = OperationOperandSimplificationResult::createManuallyFrom(simplificationResultDataOfSecondOperand);
    const DecisionReference                                                madeDecision                        = makeDecision(operationNode, simplificationResultOfFirstOperand, simplificationResultOfSecondOperand, signalValueLookupCallback);
    const std::variant<syrec::VariableAccess::ptr, syrec::expression::ptr> simplificationResultData                         = createFinalSimplificationResultAfterDecisionWasMade(madeDecision, simplificationResultOfFirstOperand, operationNode->operation, simplificationResultOfSecondOperand, signalValueLookupCallback);

    generatedAssignmentsContainer->popLastCutoffForInvertibleAssignments();
    // We should probably not remove any past decisions since this would clash with the check whether a different choice could be made at a previous decision
    //removeDecisionFor(operationNode->id);
    return std::make_unique<OperationOperandSimplificationResult>(std::holds_alternative<syrec::VariableAccess::ptr>(simplificationResultData), simplificationResultData);
}

inline bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesAssignmentToSignalLeadToConflict(const syrec::VariableAccess& assignedToSignal) const {
    return generatedAssignmentsContainer->existsOverlappingAssignmentFor(assignedToSignal, *symbolTableReference);
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryGetDecisionForOperationNode(const std::size_t& operationNodeId) const {
    const auto& matchingDecisionForOperationNode = std::find_if(
            pastDecisions.cbegin(),
            pastDecisions.cend(),
            [&operationNodeId](const DecisionReference& pastDecision) {
                return pastDecision->operationNodeId == operationNodeId;
            });
    if (matchingDecisionForOperationNode != pastDecisions.cend()) {
        return *matchingDecisionForOperationNode;
    }
    return std::nullopt;
}

// TODO: When replacing an operand with a replacement, should we also clear any existing learned conflicts for that operand in the operation node ?
noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::makeDecision(const ExpressionTraversalHelper::OperationNodeReference& operationNode, OperationOperandSimplificationResult& simplificationResultOfFirstOperand, OperationOperandSimplificationResult& simplificationResultOfSecondOperand, const SignalValueLookupCallback& callbackForValueLookupOfExistingSymbolTableSignals) {
    const std::optional<DecisionReference>          previousDecisionForOperationNode = tryGetDecisionForOperationNode(operationNode->id);
    const bool                                      wasAssignmentGeneratedByLhsOperand = simplificationResultOfFirstOperand.getAssignedToSignalOfAssignment().has_value();
    const bool                                      wasAssignmentGeneratedByRhsOperand = simplificationResultOfSecondOperand.getAssignedToSignalOfAssignment().has_value();
    const std::optional<syrec_operation::operation> matchingAssignmentOperationForOperationNode = syrec_operation::getMatchingAssignmentOperationForOperation(operationNode->operation);
    const bool                                      isAnyChoiceBetweenOperandsPossible          = matchingAssignmentOperationForOperationNode.has_value() && (wasAssignmentGeneratedByLhsOperand || wasAssignmentGeneratedByRhsOperand);

    DecisionReference madeDecision;
    if (previousDecisionForOperationNode.has_value()) {
        madeDecision = *previousDecisionForOperationNode;
        madeDecision->numExistingAssignmentsPriorToDecision = generatedAssignmentsContainer->getNumberOfAssignments();
        if (madeDecision->shouldChoiceBeRepeated == Decision::ChoiceRepetition::UntilReset) {
            logDecision(madeDecision);
            madeDecision->shouldChoiceBeRepeated = Decision::ChoiceRepetition::None;
            return madeDecision;
        }
        if (madeDecision->shouldChoiceBeRepeated == Decision::ChoiceRepetition::Always) {
            logDecision(madeDecision);
            return madeDecision;
        }
        madeDecision->choosenOperand                = Decision::ChoosenOperand::None;
        madeDecision->inheritedOperandDataForChoice = nullptr;
    }
    else {
        madeDecision = std::make_shared<Decision>(Decision{operationNode->id, generatedAssignmentsContainer->getNumberOfAssignments(), Decision::ChoosenOperand::None, Decision::ChoiceRepetition::None, nullptr});
        recordDecision(madeDecision);
    }

    if (!isAnyChoiceBetweenOperandsPossible) {
        madeDecision->choosenOperand = Decision::ChoosenOperand::None;
        logDecision(madeDecision);
        return madeDecision;
    }

    std::optional<syrec::VariableAccess::ptr> firstOperandAsVariableAccess  = simplificationResultOfFirstOperand.getAssignedToSignalOfAssignment();
    std::optional<syrec::expression::ptr>     firstOperandAsExpr            = simplificationResultOfFirstOperand.getGeneratedExpr();
    std::optional<syrec::VariableAccess::ptr> secondOperandAsVariableAccess = simplificationResultOfSecondOperand.getAssignedToSignalOfAssignment();
    std::optional<syrec::expression::ptr>     secondOperandAsExpr           = simplificationResultOfSecondOperand.getGeneratedExpr();

    /*
     * We have a preference to start our decision process by choosing the lhs operand first, but in case that no assignment was generated only by the rhs operand, we would like
     * to reuse said assignment if the given operation is commutative.
     */
    const bool shouldOperandsBeSwappedDueToPreferenceForReuseOfExistingAssignmentOfRhs = (simplificationResultOfFirstOperand.wasResultManuallyCreated() || firstOperandAsExpr.has_value()) && !simplificationResultOfSecondOperand.wasResultManuallyCreated()
        && secondOperandAsVariableAccess.has_value() && syrec_operation::isCommutative(operationNode->operation);

    if (shouldOperandsBeSwappedDueToPreferenceForReuseOfExistingAssignmentOfRhs) {
        firstOperandAsVariableAccess.swap(secondOperandAsVariableAccess);
        firstOperandAsExpr.swap(secondOperandAsExpr);
    }

    /*
     * Our decision follows the pattern:
     * I.   Try to select one of the operands as a potential choice with a higher preference for the left operand as a first choice.
     * II.  Check whether the decision can actually be used on the left-hand side of an assignment and does not lead to a conflict (this includes a check if any previous conflicts were already learned for the selected choice at the given operation node and that no overlapping signal access is defined in the second alternative)
     * III. If our first choice failed, try to repeat the steps but choose the right operand if possible (i.e. the operation is commutative).
     * IV.  If no operand could be selected as a candidate, the whole expression will be selected as our final decision.
     *
     * We will also remember any conflicts that we derive during this check and will not reset them during our parsing of the further parts of the initial assignment
     * since these learned conflicts are valid for the whole duration of the assignment parsing.
     */
    if (firstOperandAsVariableAccess.has_value()) {
        constexpr Decision::ChoosenOperand toBeChosenOperand = Decision::ChoosenOperand::Left;
        if (secondOperandAsVariableAccess.has_value() && canAlternativeByChosenInOperationNode(operationNode->id, toBeChosenOperand, **firstOperandAsVariableAccess, **secondOperandAsVariableAccess, *symbolTableReference)) {
            madeDecision->choosenOperand = toBeChosenOperand;
        } else if (secondOperandAsExpr.has_value() && canAlternativeByChosenInOperationNode(operationNode->id, toBeChosenOperand, **firstOperandAsVariableAccess, **secondOperandAsExpr, *symbolTableReference)) {
            madeDecision->choosenOperand = toBeChosenOperand;
        }
    }
    
    if (madeDecision->choosenOperand == Decision::ChoosenOperand::None && syrec_operation::isCommutative(operationNode->operation) && secondOperandAsVariableAccess.has_value()) {
        constexpr Decision::ChoosenOperand toBeChosenOperand = Decision::ChoosenOperand::Right;
        if (firstOperandAsVariableAccess.has_value() && canAlternativeByChosenInOperationNode(operationNode->id, toBeChosenOperand, **secondOperandAsVariableAccess, **firstOperandAsVariableAccess, *symbolTableReference)) {
            madeDecision->choosenOperand = toBeChosenOperand;
        } else if (firstOperandAsExpr.has_value() && canAlternativeByChosenInOperationNode(operationNode->id, toBeChosenOperand, **secondOperandAsVariableAccess, **firstOperandAsExpr, *symbolTableReference)) {
            madeDecision->choosenOperand = toBeChosenOperand;
        }
    }

    if (madeDecision->choosenOperand != Decision::ChoosenOperand::None) {
        if (shouldOperandsBeSwappedDueToPreferenceForReuseOfExistingAssignmentOfRhs) {
            madeDecision->choosenOperand = madeDecision->choosenOperand == Decision::ChoosenOperand::Left ? Decision::ChoosenOperand::Right : Decision::ChoosenOperand::Left;
        }

        if (madeDecision->choosenOperand == Decision::ChoosenOperand::Left && !operationNode->lhsOperand.isLeafNode()) {
            madeDecision->inheritedOperandDataForChoice = shouldOperandsBeSwappedDueToPreferenceForReuseOfExistingAssignmentOfRhs ? *secondOperandAsVariableAccess : *firstOperandAsVariableAccess;
        } else if (madeDecision->choosenOperand == Decision::ChoosenOperand::Right && !operationNode->rhsOperand.isLeafNode()) {
            madeDecision->inheritedOperandDataForChoice = shouldOperandsBeSwappedDueToPreferenceForReuseOfExistingAssignmentOfRhs ? *firstOperandAsVariableAccess : *secondOperandAsVariableAccess;
        }
    }
    /*
     * If case that no decision could be made we try to create a substitute for the/one of the defined signal accesses. Furthermore, the latter wil also replace the signal access data with the generated substitute in the
     * expression traversal object.
     *
     * TODO: Reference count updates ?
     * TODO: How are generated replacements made available to the caller?
     *
     * When we encounter a decision node defining an operation without assignment counterpart we should only generate the substitution and store it in a lookup but generate the required assignment
     * every time anew (since the operand data could change due to backtracking, etc.).
     */
    else if (firstOperandAsVariableAccess.has_value()) {
        madeDecision->choosenOperand = shouldOperandsBeSwappedDueToPreferenceForReuseOfExistingAssignmentOfRhs ? Decision::ChoosenOperand::Right: Decision::ChoosenOperand::Left;
        if (const std::optional<syrec::VariableAccess::ptr> generatedSubstitution = createReplacementForChosenOperand(madeDecision, callbackForValueLookupOfExistingSymbolTableSignals); generatedSubstitution.has_value()) {
            logCreationOfSubstitutionOfOperandOfOperationNode(madeDecision->operationNodeId, madeDecision->choosenOperand, **generatedSubstitution);
            madeDecision->shouldChoiceBeRepeated = Decision::ChoiceRepetition::Always;
            /*
             * We do not only need to update the data of the operand in the operation node but also in the given input data
             */
            if (madeDecision->choosenOperand == Decision::ChoosenOperand::Left) {
                simplificationResultOfFirstOperand.updateData(*generatedSubstitution);
            }
            else {
                simplificationResultOfSecondOperand.updateData(*generatedSubstitution);
            }
        }
        else {
            madeDecision->choosenOperand = Decision::ChoosenOperand::None;
        }
    }

    logDecision(madeDecision);
    return madeDecision;
}

std::optional<std::size_t> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineOperationNodeIdCausingConflict(const syrec::VariableAccess& choiceOfAssignedToSignalTriggeringSearchForCauseOfConflict) const {
    for (auto decisionIterator = pastDecisions.rbegin(); decisionIterator != pastDecisions.rend(); ++decisionIterator) {
        const DecisionReference& decision = *decisionIterator;
        if (decision->choosenOperand == Decision::ChoosenOperand::None || decision->inheritedOperandDataForChoice) {
            continue;
        }

        const auto& referenceOperationNode = expressionTraversalHelper->getOperationNodeById(decision->operationNodeId);
        if (!referenceOperationNode.has_value()) {
            continue;
        }

        /*syrec::VariableExpression::ptr selectedOperandData;
        if (decision->inheritedOperandDataForChoice) {
            selectedOperandData = std::make_shared<syrec::VariableExpression>(decision->inheritedOperandDataForChoice);
        } else {
            selectedOperandData = decision->choosenOperand == Decision::ChoosenOperand::Left ? expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->lhsOperand.id).value_or(nullptr) : expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->rhsOperand.id).value_or(nullptr);
        }*/

        syrec::VariableExpression::ptr selectedOperandData = decision->choosenOperand == Decision::ChoosenOperand::Left
            ? expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->lhsOperand.id).value_or(nullptr)
            : expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->rhsOperand.id).value_or(nullptr);

        if (!selectedOperandData) {
            return std::nullopt;
        }

        // TODO: if the made choice was inherited from an assignment, the call getOperandAsVariableExpr will not return anything (pastDecision needs to have additional field [inheritedOperand])
        if (const auto& operandAsSignalAccess = std::dynamic_pointer_cast<syrec::VariableExpression>(selectedOperandData); operandAsSignalAccess) {
            const auto& accessedSignalIdentOfDecision = operandAsSignalAccess->var->var->name;

            if (accessedSignalIdentOfDecision == choiceOfAssignedToSignalTriggeringSearchForCauseOfConflict.var->name) {
                const auto& equalityResult = SignalAccessUtils::areSignalAccessesEqual(
                        *operandAsSignalAccess->var, choiceOfAssignedToSignalTriggeringSearchForCauseOfConflict,
                        SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::DimensionAccess::Overlapping,
                        SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::BitRange::Overlapping,
                        *symbolTableReference);

                if (equalityResult.equality != SignalAccessUtils::SignalAccessEquivalenceResult::NotEqual) {
                    return decision->operationNodeId;
                }
            }
        }
    }
    return std::nullopt;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::isOperationNodeSourceOfConflict(std::size_t operationNodeId) const {
    return operationNodeCausingConflictAndBacktrack.has_value() && *operationNodeCausingConflictAndBacktrack == operationNodeId;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::markOperationNodeAsSourceOfConflict(std::size_t operationNodeId) {
    operationNodeCausingConflictAndBacktrack = operationNodeId;
    logMarkingOfOperationNodeAsSourceOfConflict(operationNodeId);
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::markSourceOfConflictReached() {
    operationNodeCausingConflictAndBacktrack.reset();
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::wereAccessedSignalPartsModifiedByActiveAssignment(const syrec::VariableAccess& accessedSignalParts) const {
    return generatedAssignmentsContainer->existsOverlappingAssignmentFor(accessedSignalParts, *symbolTableReference);
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineEarliestDecisionsOverlappingAccessedSignalPartsOmittingAlreadyRecordedOnes(const syrec::VariableAccess& accessedSignalParts) const {
    DecisionReference earliestDecisionOverlappingAccessedSignalParts;
    for (const DecisionReference& decision : pastDecisions) {
        if (decision->choosenOperand == Decision::ChoosenOperand::None || decision->inheritedOperandDataForChoice) {
            continue;
        }

        const auto& referenceOperationNode = expressionTraversalHelper->getOperationNodeById(decision->operationNodeId);
        if (!referenceOperationNode.has_value()) {
            continue;
        }

        /*syrec::VariableExpression::ptr selectedOperandData;
        if (decision->inheritedOperandDataForChoice) {
            selectedOperandData = std::make_shared<syrec::VariableExpression>(decision->inheritedOperandDataForChoice);
        } else {
            selectedOperandData = decision->choosenOperand == Decision::ChoosenOperand::Left
                ? expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->lhsOperand.id).value_or(nullptr)
                : expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->rhsOperand.id).value_or(nullptr);
        }*/

        const syrec::VariableExpression::ptr selectedOperandData = decision->choosenOperand == Decision::ChoosenOperand::Left
            ? expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->lhsOperand.id).value_or(nullptr)
            : expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->rhsOperand.id).value_or(nullptr);

        if (selectedOperandData) {
            const LearnedConflictsLookupKey key = LearnedConflictsLookupKey(decision->operationNodeId, decision->choosenOperand);
            if (const auto& operandAsSignalAccess = std::dynamic_pointer_cast<syrec::VariableExpression>(selectedOperandData); operandAsSignalAccess && !learnedConflictsLookup->count(key)) {
                const auto& equalityResult = SignalAccessUtils::areSignalAccessesEqual(
                        *operandAsSignalAccess->var, accessedSignalParts,
                        SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::DimensionAccess::Overlapping,
                        SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::BitRange::Overlapping,
                        *symbolTableReference);
                if (!(equalityResult.isResultCertain && equalityResult.equality == SignalAccessUtils::SignalAccessEquivalenceResult::NotEqual)) {
                    if (!earliestDecisionOverlappingAccessedSignalParts || decision.get()->operationNodeId <= earliestDecisionOverlappingAccessedSignalParts->operationNodeId) {
                        earliestDecisionOverlappingAccessedSignalParts = decision;
                    }
                }
            }
        }
    }
    return earliestDecisionOverlappingAccessedSignalParts ? std::make_optional(earliestDecisionOverlappingAccessedSignalParts) : std::nullopt;
}

/*
 * TODO: Review search for earliest operation node involved in conflict (line 712) with test 'simplifyWithOnlyReversibleOpsButNonUniqueSignalAccessWithAssignOperationBeingAdditionWithDegeneratedLhsSubASTOfLhsOfAssignmentExpr'
 */
void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleConflict(std::size_t associatedOperationNodeIdOfAccessedSignalPartsOperand, Decision::ChoosenOperand chosenOperandLeadingToDetectionOfConflict, const syrec::VariableAccess& accessedSignalPartsUsedInCheckForConflict) {
    constexpr std::size_t                  earliestPossibleOperationNodeId               = 0;
    const std::size_t                      idOfEarliestOperationNodeIdInvolvedInConflict = determineOperationNodeIdCausingConflict(accessedSignalPartsUsedInCheckForConflict).value_or(earliestPossibleOperationNodeId);
    const std::optional<DecisionReference> earliestDecisionInvolvedInConflict            = determineEarliestDecisionsOverlappingAccessedSignalPartsOmittingAlreadyRecordedOnes(accessedSignalPartsUsedInCheckForConflict);
    
    if (earliestDecisionInvolvedInConflict.has_value()) {
        rememberConflict(earliestDecisionInvolvedInConflict->get()->operationNodeId, earliestDecisionInvolvedInConflict->get()->choosenOperand);
    }

    logConflict(associatedOperationNodeIdOfAccessedSignalPartsOperand, chosenOperandLeadingToDetectionOfConflict, accessedSignalPartsUsedInCheckForConflict, idOfEarliestOperationNodeIdInvolvedInConflict);

    std::unordered_set<std::size_t> hotPathFromSourceOfConflictToLocationWhereConflictWasDetected                                 = {};
    const std::size_t idOfEarliestSharedParentOperationNodeBetweenSourceOfConflictAndDetectionOfOriginOperationNode = determineEarliestSharedParentOperationNodeIdBetweenCurrentAndConflictOperationNodeId(idOfEarliestOperationNodeIdInvolvedInConflict, associatedOperationNodeIdOfAccessedSignalPartsOperand, &hotPathFromSourceOfConflictToLocationWhereConflictWasDetected);
    markOperationNodeAsSourceOfConflict(idOfEarliestSharedParentOperationNodeBetweenSourceOfConflictAndDetectionOfOriginOperationNode);
    forceReuseOfPreviousDecisionsOnceAtAllDecisionsForChildrenOfNodeButExcludeHotpath(idOfEarliestSharedParentOperationNodeBetweenSourceOfConflictAndDetectionOfOriginOperationNode, &hotPathFromSourceOfConflictToLocationWhereConflictWasDetected);
}

std::size_t noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineEarliestSharedParentOperationNodeIdBetweenCurrentAndConflictOperationNodeId(std::size_t operationNodeIdOfEarliestSourceOfConflict, std::size_t operationNodeIdWhereConflictWasDetected, std::unordered_set<std::size_t>* hotPathContainerFromSourceToSharedOrigin) const {
    /*std::optional<ExpressionTraversalHelper::OperationNodeReference> operationNodeOfInterest;
    if (const std::optional<ExpressionTraversalHelper::OperationNodeReference> dataOfOperationNodeWhereConflictWasDetected = expressionTraversalHelper->getOperationNodeById(operationNodeIdWhereConflictWasDetected); dataOfOperationNodeWhereConflictWasDetected.has_value() && dataOfOperationNodeWhereConflictWasDetected->get()->parentNodeId.has_value()) {
        operationNodeOfInterest = expressionTraversalHelper->getOperationNodeById(*dataOfOperationNodeWhereConflictWasDetected->get()->parentNodeId);
    }*/

    std::optional<ExpressionTraversalHelper::OperationNodeReference> operationNodeOfInterest = expressionTraversalHelper->getOperationNodeById(operationNodeIdOfEarliestSourceOfConflict);

    /*
     * Try to find the first shared operation node by the operation node containing the conflict as well as the operation node for which the conflict was detected. Furthermore, the parent of the found shared parent operation node is returned.
     */
    constexpr std::size_t defaultSearchResultOperationNodeId = 0;
    while (operationNodeOfInterest.has_value()) {
        if (hotPathContainerFromSourceToSharedOrigin) {
            hotPathContainerFromSourceToSharedOrigin->emplace(operationNodeOfInterest->get()->id);
        }

        /*
         * We have found the operation node that is the source of the conflict (called original source), but we need to mark its parent node, if such a node exists, as the "source" of the conflict to trigger
         * a reprocessing of the original source. 
         */
        if (operationNodeOfInterest->get()->id < operationNodeIdOfEarliestSourceOfConflict) {
            // TODO: Why should we always return the parent of the found node and not the node instead ?
            return operationNodeOfInterest->get()->id;
            //return operationNodeOfInterest->get()->parentNodeId.value_or(defaultSearchResultOperationNodeId);
        }
        // Since any generated operation node id is >= 1 we can assume that the lookup for an operation node with id 0 does not return any matching result
        operationNodeOfInterest = expressionTraversalHelper->getOperationNodeById(operationNodeOfInterest->get()->parentNodeId.value_or(defaultSearchResultOperationNodeId));
    }
    return defaultSearchResultOperationNodeId;
}

/*
 * TODO: Think this through more thorougly with the help of the test case conflictInOperationNodeWithOneLeafNodeWhereLeafIsRhsOperandNotResolvableByOtherChoiceInLhsOperandThatGeneratedAssignmentCreatesExprInstead
 */
void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::forceReuseOfPreviousDecisionsOnceAtAllDecisionsForChildrenOfNodeButExcludeHotpath(std::size_t parentOperationNodeId, const std::unordered_set<std::size_t>* idOfOperationNodesOnHotPath) const {
    /*
     * We are assuming here that no decision are removed during the processing of the whole assignment statement (only the chosen operand should change). Additionally, we assume that the operation node ids
     * are ordered ascending and thus the a parent operation node should have a smaller id than any of its child nodes. Since child nodes are processed before their parent, the former
     * are also found at smaller indices in the container than their parent nodes. Thus we perform a reverse search to find the parents first.
     */
    const auto& firstPastDecisionToReuse = std::find_if(pastDecisions.crbegin(), pastDecisions.crend(), [&parentOperationNodeId](const DecisionReference& pastDecision) { return pastDecision->operationNodeId > parentOperationNodeId; });
    for (auto pastDecisionToReuseIterator = firstPastDecisionToReuse; pastDecisionToReuseIterator != pastDecisions.crend(); ++pastDecisionToReuseIterator) {
        if (pastDecisionToReuseIterator->get()->shouldChoiceBeRepeated != Decision::ChoiceRepetition::Always) {
            pastDecisionToReuseIterator->get()->shouldChoiceBeRepeated = (!idOfOperationNodesOnHotPath || !idOfOperationNodesOnHotPath->count(pastDecisionToReuseIterator->get()->operationNodeId)) ? Decision::ChoiceRepetition::UntilReset : Decision::ChoiceRepetition::None;    
        }
        
    }
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::shouldBacktrackDueToConflict() const {
    return operationNodeCausingConflictAndBacktrack.has_value();
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::considerExpressionInFutureDecisions(const syrec::expression::ptr& expr) const {
    if (temporaryExpressionsContainer && expr) {
        temporaryExpressionsContainer->activateExpression(expr);
    }
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::revokeConsiderationOfExpressionForFutureDecisions(const syrec::expression::ptr& expr) const {
    if (temporaryExpressionsContainer && expr) {
        temporaryExpressionsContainer->deactivateExpression(expr);   
    }
}

std::vector<syrec::VariableAccess::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::defineNotUsableReplacementCandidatesFromAssignmentForGenerator(const syrec::AssignStatement& assignment) const {
    if (substitutionGenerator) {
        std::vector<syrec::VariableAccess::ptr> notUsableReplacementCandidatesForSubstitutionGenerator = determineSignalPartsNotUsableAsPotentialReplacementCandidates(*assignment.rhs, *symbolTableReference);
        notUsableReplacementCandidatesForSubstitutionGenerator.emplace_back(assignment.lhs);
        substitutionGenerator->updateRestrictions(notUsableReplacementCandidatesForSubstitutionGenerator, ExpressionSubstitutionGenerator::RestrictionLifetime::Temporary, ExpressionSubstitutionGenerator::RestrictionUpdate::Activation);
        return notUsableReplacementCandidatesForSubstitutionGenerator;
    }
    return {};
}
void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::clearNotUsableReplacementCandidatesFromAssignmentForGenerator(const std::vector<syrec::VariableAccess::ptr>& replacementCandidateRestrictionsStemmingFromAssignment) const {
    if (substitutionGenerator) {
        substitutionGenerator->updateRestrictions(replacementCandidateRestrictionsStemmingFromAssignment, ExpressionSubstitutionGenerator::RestrictionLifetime::Temporary, ExpressionSubstitutionGenerator::Deactivation);
    }
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::isChoiceOfSignalAccessBlockedByAnyActiveExpression(const syrec::VariableAccess& chosenOperand) const {
    return temporaryExpressionsContainer && temporaryExpressionsContainer->existsAnyExpressionDefiningOverlappingSignalAccess(chosenOperand).value_or(true);
}

std::optional<syrec::VariableAccess::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::createReplacementForChosenOperand(const DecisionReference& decisionToReplace, const SignalValueLookupCallback& callbackForValueLookupOfExistingSymbolTableSignals) const {
    if (!determinedBitWidthOfAssignmentToSimplify.has_value() || !substitutionGenerator || !decisionToReplace || decisionToReplace->choosenOperand == Decision::ChoosenOperand::None) {
        return std::nullopt;
    }

    const std::optional<ExpressionTraversalHelper::OperationNodeReference> referencedOperationNode = expressionTraversalHelper->getOperationNodeById(decisionToReplace->operationNodeId);
    if (!referencedOperationNode.has_value() || !referencedOperationNode->get()->hasAnyLeafOperandNodes()) {
        return std::nullopt;
    }

    const std::optional<ExpressionSubstitutionGenerator::ReplacementResult> generatedReplacement = substitutionGenerator->generateReplacementFor(*determinedBitWidthOfAssignmentToSimplify, callbackForValueLookupOfExistingSymbolTableSignals);
    if (!generatedReplacement.has_value()) {
        return std::nullopt;
    }

    /*
     * Since a newly generated replacement signal will always have the initial value of 0 (assuming our replacement is generated as a local signal) thus the XOR assignment operation is sufficient to create the required substitution for the operand of the operation node.
     */
    const std::optional<unsigned int>           mappedToAssignmentOperation            = syrec_operation::tryMapAssignmentOperationEnumToFlag(syrec_operation::operation::XorAssign);
    const std::size_t                           idOfToBeReplacedOperandInOperationNode = decisionToReplace->choosenOperand == Decision::ChoosenOperand::Left ? referencedOperationNode->get()->lhsOperand.id : referencedOperationNode->get()->rhsOperand.id;
    const std::optional<syrec::expression::ptr> generatedSubstitutionAssignmentRhsExpr = expressionTraversalHelper->getOperandAsVariableExpr(idOfToBeReplacedOperandInOperationNode);
    if (!mappedToAssignmentOperation.has_value() || !generatedSubstitutionAssignmentRhsExpr.has_value()) {
        return std::nullopt;
    }
    
    const syrec::VariableExpression::ptr generatedContainerForReplacementExpr = mappedToAssignmentOperation.has_value() ? std::make_shared<syrec::VariableExpression>(generatedReplacement->foundReplacement) : nullptr;
    const syrec::AssignStatement::ptr    generatedSubstitutionAssignment      = generatedContainerForReplacementExpr ? std::make_shared<syrec::AssignStatement>(generatedReplacement->foundReplacement, *mappedToAssignmentOperation, *generatedSubstitutionAssignmentRhsExpr) : nullptr;
    if (!generatedSubstitutionAssignment || !expressionTraversalHelper->updateOperandData(referencedOperationNode->get()->id, decisionToReplace->choosenOperand == Decision::ChoosenOperand::Left, generatedContainerForReplacementExpr)) {
        return std::nullopt;
    }
    generatedAssignmentsContainer->storeInitializationForReplacementOfLeafNode(generatedSubstitutionAssignment, generatedReplacement->requiredResetOfReplacement);
    return generatedReplacement->foundReplacement;
}

std::optional<syrec::VariableAccess::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::getAndActiveReplacementForOperationNode(std::size_t referencedOperationNodeId, syrec_operation::operation definedOperationInOperationNode, const OperationOperandSimplificationResult& lhsOperandDataChoicesAfterSimplification, const OperationOperandSimplificationResult& rhsOperandDataChoicesAfterSimplification, bool* wasExistingReplacementForOperationNodeEntryUpdated, const SignalValueLookupCallback& callbackForValueLookupOfExistingSymbolTableSignals) {
    // Currently we do not support shift expressions here
    if (!determinedBitWidthOfAssignmentToSimplify.has_value() || !substitutionGenerator || !expressionTraversalHelper->getOperationNodeById(referencedOperationNodeId).has_value() || syrec_operation::isOperationShiftOperation(definedOperationInOperationNode)) {
        return std::nullopt;
    }
    
    const std::optional<syrec::expression::ptr> fusedExpressionFromOperands = tryCreateExpressionFromOperationNodeOperandSimplifications(lhsOperandDataChoicesAfterSimplification, definedOperationInOperationNode, rhsOperandDataChoicesAfterSimplification);
    if (!fusedExpressionFromOperands.has_value()) {
        return std::nullopt;
    }

    if (wholeExpressionOfOperationNodeReplacementLookup.count(referencedOperationNodeId)) {
        /*
         * If the operands of the already existing assignment did not change, simply reuse said assignment again. Otherwise, update the operands. The operation of the rhs expression of the assignments should not change thus the type of the expression should also not change.
         */
        const std::shared_ptr<syrec::AssignStatement> existingReplacementForOperationNode = std::dynamic_pointer_cast<syrec::AssignStatement>(wholeExpressionOfOperationNodeReplacementLookup.at(referencedOperationNodeId));
        const std::shared_ptr<syrec::BinaryExpression> existingAssignmentRhsExprAsBinaryExpr = existingReplacementForOperationNode ? std::dynamic_pointer_cast<syrec::BinaryExpression>(existingReplacementForOperationNode->rhs) : nullptr;
        if (!existingAssignmentRhsExprAsBinaryExpr) {
            return std::nullopt;
        }
        if (!doesOperandSimplificationResultMatchExpression(lhsOperandDataChoicesAfterSimplification, existingAssignmentRhsExprAsBinaryExpr->lhs)) {
            existingAssignmentRhsExprAsBinaryExpr->lhs = tryCreateExpressionFromOperationNodeOperandSimplification(lhsOperandDataChoicesAfterSimplification).value_or(nullptr);
        }
        if (!doesOperandSimplificationResultMatchExpression(rhsOperandDataChoicesAfterSimplification, existingAssignmentRhsExprAsBinaryExpr->rhs)) {
            existingAssignmentRhsExprAsBinaryExpr->rhs = tryCreateExpressionFromOperationNodeOperandSimplification(rhsOperandDataChoicesAfterSimplification).value_or(nullptr);
        }

        if (!existingAssignmentRhsExprAsBinaryExpr->lhs || !existingAssignmentRhsExprAsBinaryExpr->rhs) {
            wholeExpressionOfOperationNodeReplacementLookup.erase(referencedOperationNodeId);
            return std::nullopt;
        }

        if (wasExistingReplacementForOperationNodeEntryUpdated) {
            *wasExistingReplacementForOperationNodeEntryUpdated = true;
        }
        generatedAssignmentsContainer->storeActiveAssignment(existingReplacementForOperationNode);
        return existingReplacementForOperationNode->lhs;
    }
    const std::optional<unsigned int>                                       mappedToFlagForAssignmentEnumValue = syrec_operation::tryMapAssignmentOperationEnumToFlag(syrec_operation::operation::XorAssign);
    const std::optional<ExpressionSubstitutionGenerator::ReplacementResult> generatedReplacement               = mappedToFlagForAssignmentEnumValue.has_value() ? substitutionGenerator->generateReplacementFor(*determinedBitWidthOfAssignmentToSimplify, callbackForValueLookupOfExistingSymbolTableSignals) : std::nullopt;
    if (!generatedReplacement.has_value()) {
        return std::nullopt;
    }

    if (const syrec::AssignStatement::ptr assignmentFusingReplacementAndExpression = std::make_shared<syrec::AssignStatement>(generatedReplacement->foundReplacement, *mappedToFlagForAssignmentEnumValue, *fusedExpressionFromOperands); assignmentFusingReplacementAndExpression) {
        wholeExpressionOfOperationNodeReplacementLookup.insert(std::make_pair(referencedOperationNodeId, assignmentFusingReplacementAndExpression));
        /*
             * Since the operands of the generated assignment, fusing the generated replacement with the expression defining the substitution, rhs expression could potentially change, we need to store said assignment as an active assignment.
             * The optional reset of the replacement can be executed prior to any active assignment and will be stored accordingly in the generated assignment container.
             */
        generatedAssignmentsContainer->storeReplacementAsActiveAssignment(assignmentFusingReplacementAndExpression, generatedReplacement->requiredResetOfReplacement);
        return generatedReplacement->foundReplacement;
    }
    return std::nullopt;
}

// TODO: can probably be removed
bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::couldAnotherChoiceBeMadeAtPreviousDecision(const std::optional<std::size_t>& pastDecisionForOperationNodeWithIdToExclude) const {
    if (pastDecisions.empty()) {
        return false;
    }

    std::size_t lastDecisionOffset = 0;
    if (pastDecisionForOperationNodeWithIdToExclude.has_value() && *pastDecisionForOperationNodeWithIdToExclude == pastDecisions.back()->operationNodeId) {
        ++lastDecisionOffset;
    }

    if (lastDecisionOffset >= pastDecisions.size()) {
        return false;
    }

    return std::any_of(
        std::next(pastDecisions.crbegin(), lastDecisionOffset + 1),
        pastDecisions.crend(),
        [&](const DecisionReference& pastDecision) {
                if (const auto& matchingAssignmentOperationForOperation = syrec_operation::getMatchingAssignmentOperationForOperation(*expressionTraversalHelper->getOperationOfOperationNode(pastDecision->operationNodeId)); matchingAssignmentOperationForOperation.has_value()) {
                    return pastDecision->choosenOperand == Decision::ChoosenOperand::Left && syrec_operation::isCommutative(*expressionTraversalHelper->getOperationOfOperationNode(pastDecision->operationNodeId));
                }
                return false;
            });
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::removeDecisionFor(std::size_t operationNodeId) {
    const auto& matchingDecisionForOperationNode = std::find_if(
        pastDecisions.cbegin(),
        pastDecisions.cend(),
        [&operationNodeId](const DecisionReference& decisionReference) {
            return decisionReference->operationNodeId == operationNodeId;
        });

    if (matchingDecisionForOperationNode != pastDecisions.cend()) {
        pastDecisions.erase(matchingDecisionForOperationNode);
    }
}

inline std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryGetLastDecision() const {
    if (pastDecisions.empty()) {
        return std::nullopt;
    }
    return pastDecisions.back();
}

inline std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryGetSecondToLastDecision() const {
    if (pastDecisions.size() < 2) {
        return std::nullopt;
    }
    return pastDecisions.at(pastDecisions.size() - 2);
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::resetInternals() {
    pastDecisions.clear();
    generatedAssignmentsContainer->resetInternals();
    temporaryExpressionsContainer->resetInternals();
    expressionTraversalHelper->resetInternals();
    if (substitutionGenerator) {
        substitutionGenerator->resetInternals(false);
    }
    determinedBitWidthOfAssignmentToSimplify.reset();
    enabledValueLookup();
}

std::unique_ptr<syrec::AssignStatement> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::transformAssignmentPriorToSimplification(const syrec::AssignStatement& assignmentToSimplify, bool applyHeuristicsForSubassignmentGeneration) const {
    if (std::unique_ptr<syrec::AssignStatement> owningCopyOfAssignmentStmt = copyUtils::createDeepCopyOfAssignmentStmt(assignmentToSimplify); owningCopyOfAssignmentStmt) {
        tryConvertNumericToBinaryExpr(owningCopyOfAssignmentStmt->rhs);
        if (!doesExpressionDefineNestedSplitableExpr(*owningCopyOfAssignmentStmt->rhs)) {
            return nullptr;
        }

        /*
         * Try to convert an assignment of the form a -= (<lhsExpr> - <rhsExpr>) to a += (<rhsExpr> - <lhsExpr>) if the <lhsExpr> is a nested expression, to enable the optimization of converting an assignment of the form:
         * a += ... to a ^= 0 if the symbol table entry for the assigned to signal has the value 0
         */
        if (const auto& assignmentRhsExprAsBinaryExpr = std::dynamic_pointer_cast<syrec::BinaryExpression>(owningCopyOfAssignmentStmt->rhs); assignmentRhsExprAsBinaryExpr) {
            const std::optional<syrec_operation::operation> mappedToAssignmentOperationEnumFromFlag = syrec_operation::tryMapAssignmentOperationFlagToEnum(owningCopyOfAssignmentStmt->op);
            const std::optional<syrec_operation::operation> mappedToBinaryOperationEnumFromFlag     = syrec_operation::tryMapBinaryOperationFlagToEnum(assignmentRhsExprAsBinaryExpr->op);
            if (mappedToAssignmentOperationEnumFromFlag.has_value() && *mappedToAssignmentOperationEnumFromFlag == syrec_operation::operation::MinusAssign
                && mappedToBinaryOperationEnumFromFlag.has_value() && *mappedToBinaryOperationEnumFromFlag == syrec_operation::operation::Subtraction) {
                owningCopyOfAssignmentStmt->op                   = *syrec_operation::tryMapAssignmentOperationEnumToFlag(syrec_operation::operation::AddAssign);
                const syrec::expression::ptr copyOfBinaryExprLhs = assignmentRhsExprAsBinaryExpr->lhs;
                assignmentRhsExprAsBinaryExpr->lhs               = assignmentRhsExprAsBinaryExpr->rhs;
                assignmentRhsExprAsBinaryExpr->rhs               = copyOfBinaryExprLhs;   
            }
        }
        transformExpressionPriorToSimplification(*owningCopyOfAssignmentStmt->rhs, applyHeuristicsForSubassignmentGeneration);
        return owningCopyOfAssignmentStmt;
    }
    return nullptr;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::transformExpressionPriorToSimplification(syrec::expression& expr, bool applyHeuristicsForSubassignmentGeneration) const {
    if (auto* exprAsBinaryExpr = dynamic_cast<syrec::BinaryExpression*>(&expr); exprAsBinaryExpr) {
        tryConvertNumericToBinaryExpr(exprAsBinaryExpr->lhs);
        tryConvertNumericToBinaryExpr(exprAsBinaryExpr->rhs);
        transformExpressionPriorToSimplification(*exprAsBinaryExpr->lhs, applyHeuristicsForSubassignmentGeneration);

        const bool doesLhsOperandDefineNestedEpxr = doesExpressionDefineNestedSplitableExpr(*exprAsBinaryExpr->lhs);
        const std::optional<syrec_operation::operation> mappedToOperationOfParentExpr  = syrec_operation::tryMapBinaryOperationFlagToEnum(exprAsBinaryExpr->op);

        /*
         * Try to transform a binary expression of the form (<number> op <signalAccess>) to (<signalAccess> op <number>) if the defined operation is commutative, has a matching assignment operation and the defined signal access accesses a modifiable signal.
         */
        if (applyHeuristicsForSubassignmentGeneration && mappedToOperationOfParentExpr.has_value() && syrec_operation::isCommutative(*mappedToOperationOfParentExpr) && syrec_operation::getMatchingAssignmentOperationForOperation(*mappedToOperationOfParentExpr).has_value()
            && (doesExpressionDefineNumber(*exprAsBinaryExpr->lhs) || doesLhsOperandDefineNestedEpxr) && doesExprDefineSignalAccess(*exprAsBinaryExpr->rhs)) {
            const auto& rhsOperandAsSignalAccess = std::dynamic_pointer_cast<const syrec::VariableExpression>(exprAsBinaryExpr->rhs);
            if (rhsOperandAsSignalAccess && isAccessedSignalAssignable(rhsOperandAsSignalAccess->var->var->name)) {
                exprAsBinaryExpr->lhs.swap(exprAsBinaryExpr->rhs);
            }
        }

        if (const std::shared_ptr<syrec::BinaryExpression> rhsExprAsBinaryExpr = std::dynamic_pointer_cast<syrec::BinaryExpression>(exprAsBinaryExpr->rhs); rhsExprAsBinaryExpr) {
            const std::optional<syrec_operation::operation> mappedToOperationOfRhsExpr    = syrec_operation::tryMapBinaryOperationFlagToEnum(rhsExprAsBinaryExpr->op);

            /*
             * Try to transform an expression of the form (a - (b - c)) to (a + (c - b)) only if b is not a signal access. The latter condition is heuristic as the transformation could prevent the creation of an assignment
             * of the form b -= c.
             */
            if (applyHeuristicsForSubassignmentGeneration && mappedToOperationOfParentExpr.has_value() && mappedToOperationOfRhsExpr.has_value() && *mappedToOperationOfRhsExpr == syrec_operation::operation::Subtraction) {
                if (*mappedToOperationOfParentExpr == syrec_operation::operation::Subtraction) {
                /*
                 * TODO: Could a similar transformation take place during the processing of the operation nodes (i.e. when the constellation or something similar (<sigAcc_1> - (<subExpr_1> - <sigAcc_2>)) is encountered?
                 * Try to convert an expression of the form (<subExpr_1> - (<subExpr_2> - <subExpr_3>)) to (<subExpr_1> + (<subExpr_3> - <subExpr_2)).
                 * We do not apply this transformation if <subExpr_2> defines a signal access while <subExpr_3> defines a nested expressions as this could prevent the generation of the assignment <subExpr_2> -= <subExpr_3>.
                 * NOTE: We try to not prevent any future assignments by this transformation, but could implicitly block some by our transformation due to a conflict later during preprocessing.
                 */
                    if (!doesExprDefineSignalAccess(*rhsExprAsBinaryExpr->lhs) || doesExprDefineSignalAccess(*rhsExprAsBinaryExpr->rhs)) {
                        exprAsBinaryExpr->op                    = *syrec_operation::tryMapBinaryOperationEnumToFlag(syrec_operation::operation::Addition);
                        const auto backupOfNestedExprLhsOperand = rhsExprAsBinaryExpr->lhs;
                        rhsExprAsBinaryExpr->lhs                = rhsExprAsBinaryExpr->rhs;
                        rhsExprAsBinaryExpr->rhs                = backupOfNestedExprLhsOperand;
                    }
                /*
                 * TODO: Add tests for this behaviour and could this transformation also be done during the processing of the operation nodes itself ?
                 * Try to convert an expression of the form (<subExpr_1> + (<subExpr_with_op_without_assignmentCounterPart> - <assignableSignalAccess>) to (<subExpr_1> - (<assignableSignalAccess> - <subExpr_with_op_without_assignmentCounterPart>)
                 * where the subexpression that defines an operation without assignment counterpart can also be either a number of a readonly signal access.
                 *
                 * Apply the same transformation if the rhs operand defines an expression with an operation that has an assignment counterpart.
                 * E.g.: (<subExpr_1> + (<notSplitableExprNumberOrReadonlySignalAccess> - <splitableExpr>)) to (<subExpr_1> - (<splitableExpr> - <notSplitableExprNumberOfReadonlySignalAccess>))
                 */
                } else if (*mappedToOperationOfParentExpr == syrec_operation::operation::Addition) {
                    const auto& rhsOperandAsSignalAccess = std::dynamic_pointer_cast<const syrec::VariableExpression>(rhsExprAsBinaryExpr->rhs);
                    const auto& lhsOperandAsSignalAccess                   = std::dynamic_pointer_cast<const syrec::VariableExpression>(rhsExprAsBinaryExpr->lhs);
                    const bool  doesLhsOperandDefineAssignableSignalAccess = lhsOperandAsSignalAccess && isAccessedSignalAssignable(lhsOperandAsSignalAccess->var->var->name);

                    if ((!doesExpressionDefineNestedSplitableExpr(*rhsExprAsBinaryExpr->lhs) && rhsOperandAsSignalAccess && isAccessedSignalAssignable(rhsOperandAsSignalAccess->var->var->name)) 
                        || (!doesLhsOperandDefineAssignableSignalAccess && doesExpressionDefineNestedSplitableExpr(*rhsExprAsBinaryExpr->lhs))) {
                        if (!doesLhsOperandDefineAssignableSignalAccess) {
                            rhsExprAsBinaryExpr->lhs.swap(rhsExprAsBinaryExpr->rhs);
                            exprAsBinaryExpr->op = *syrec_operation::tryMapBinaryOperationEnumToFlag(syrec_operation::operation::Subtraction);
                        }
                    }
                }
            }  
        }
        transformExpressionPriorToSimplification(*exprAsBinaryExpr->rhs, applyHeuristicsForSubassignmentGeneration);
    } else if (const auto& exprAsShiftExpr = dynamic_cast<const syrec::ShiftExpression*>(&expr); exprAsShiftExpr) {
        tryConvertNumericToBinaryExpr(exprAsBinaryExpr->lhs);
        transformExpressionPriorToSimplification(*exprAsShiftExpr->lhs, applyHeuristicsForSubassignmentGeneration);
        // TODO: Simplification of number
    }
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::rememberConflict(std::size_t operationNodeId, Decision::ChoosenOperand chosenOperandAtOperationNode) const {
    const LearnedConflictsLookupKey lookupKey = LearnedConflictsLookupKey(operationNodeId, chosenOperandAtOperationNode);
    learnedConflictsLookup->emplace(lookupKey);
    logLearnedConflict(operationNodeId, chosenOperandAtOperationNode);
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::didPreviousDecisionMatchingChoiceCauseConflict(const LearnedConflictsLookupKey& lookupKeyRepresentingSearchedForPreviousDecision) const {
    return learnedConflictsLookup->count(lookupKeyRepresentingSearchedForPreviousDecision);
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::disableValueLookup() {
    disabledValueLookupToggle = true;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::enabledValueLookup() {
    disabledValueLookupToggle = false;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::backtrack(std::size_t operationNodeIdAtOriginOfBacktrack, bool onlyUpToOperationNode) const {
    if (onlyUpToOperationNode) {
        expressionTraversalHelper->backtrackToNode(operationNodeIdAtOriginOfBacktrack);
    }
    else {
        expressionTraversalHelper->backtrackOnePastNode(operationNodeIdAtOriginOfBacktrack);
    }
    const std::optional<ExpressionTraversalHelper::OperationNodeReference> peekedNextOperationNodeAfterFinishOfBacktrack = expressionTraversalHelper->peekNextOperationNode();
    const std::size_t                                                      peekedNextOperationNodeToBeProcessedAfterBacktracking = peekedNextOperationNodeAfterFinishOfBacktrack.has_value() ? peekedNextOperationNodeAfterFinishOfBacktrack.value()->id : 0;
    logBacktrackingResult(operationNodeIdAtOriginOfBacktrack, peekedNextOperationNodeToBeProcessedAfterBacktracking);
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::recordDecision(const DecisionReference& decision) {
    const auto& insertPosition = std::find_if(pastDecisions.cbegin(), pastDecisions.cend(), [&decision](const DecisionReference& pastDecision) { return pastDecision->operationNodeId < decision->operationNodeId; });
    if (insertPosition != pastDecisions.cend()) {
        pastDecisions.insert(insertPosition, decision);
    }
    else {
        pastDecisions.emplace_back(decision);
    }
}

noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OperationNodeProcessingResult noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::processNextOperationNode(const SignalValueLookupCallback& signalValueLookupCallback) {
    std::optional<ExpressionTraversalHelper::OperationNodeReference>   dataOfOperationNode;
    std::optional<OwningOperationOperandSimplificationResultReference> simplificationResultOfOperationNode;

    bool continueProcessing = true;
    while (continueProcessing) {
        dataOfOperationNode = expressionTraversalHelper->getNextOperationNode();
        if (!dataOfOperationNode.has_value()) {
            return OperationNodeProcessingResult::fromUnknownResult();
        }

        const std::size_t idOfOperationNodeToBeProcessed = dataOfOperationNode->get()->id;
        simplificationResultOfOperationNode = handleOperationNode(*dataOfOperationNode, signalValueLookupCallback);
        if (shouldBacktrackDueToConflict()) {
            const bool isThisOperationNodeSourceOfConflict = isOperationNodeSourceOfConflict(idOfOperationNodeToBeProcessed);
            if (isThisOperationNodeSourceOfConflict) {
                markSourceOfConflictReached();
            }

            //generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(!isThisOperationNodeSourceOfConflict);
            //backtrack(idOfOperationNodeToBeProcessed, isThisOperationNodeSourceOfConflict);
            backtrack(idOfOperationNodeToBeProcessed, false);
            if (!isThisOperationNodeSourceOfConflict) {
                return OperationNodeProcessingResult::fromConflictInOtherNode();
            }
            /*if (quitProcessingOnConflictInSameNode) {
                return OperationNodeProcessingResult::fromFromConflictInSameNode();
            }*/
        } else {
            continueProcessing = false;
        }
    }
    
    if (!simplificationResultOfOperationNode.has_value()) {
        const std::size_t idOfOperationNodeToBeProcessed = dataOfOperationNode->get()->id;
        if (couldAnotherChoiceBeMadeAtPreviousDecision(idOfOperationNodeToBeProcessed)) {
            generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
            backtrack(idOfOperationNodeToBeProcessed, false);
            return OperationNodeProcessingResult({.simplificationResult = std::nullopt, .derivedConflictInOtherNode = false});
        }
        const std::size_t            operationNodeIdOfFirstOperand = *expressionTraversalHelper->getOperandNodeIdOfNestedOperation(*dataOfOperationNode->get()->parentNodeId, dataOfOperationNode->get()->id);
        const syrec::expression::ptr operandAsExpr                 = *expressionTraversalHelper->getOperandAsExpr(operationNodeIdOfFirstOperand);
        simplificationResultOfOperationNode                        = std::make_unique<OperationOperandSimplificationResult>(OperationOperandSimplificationResult::createManuallyFrom(operandAsExpr));
    }
    return OperationNodeProcessingResult::fromResult(std::move(simplificationResultOfOperationNode));
}


bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::canAlternativeByChosenInOperationNode(std::size_t operationNodeId, Decision::ChoosenOperand toBeChosenAlternative, const syrec::VariableAccess& signalAccess, const syrec::VariableAccess& alternativeToCheckAsSignalAccess, const parser::SymbolTable& symbolTable) const {
    return expressionTraversalHelper->canSignalBeUsedOnAssignmentLhs(signalAccess.var->name)
        && !didPreviousDecisionMatchingChoiceCauseConflict(LearnedConflictsLookupKey(operationNodeId, toBeChosenAlternative))
        && !doSignalAccessesOverlap(alternativeToCheckAsSignalAccess, signalAccess, symbolTable)
        && !isChoiceOfSignalAccessBlockedByAnyActiveExpression(signalAccess);
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::canAlternativeByChosenInOperationNode(std::size_t operationNodeId, Decision::ChoosenOperand toBeChosenAlternative, const syrec::VariableAccess& signalAccess, const syrec::expression& alternativeToCheckAsExpr, const parser::SymbolTable& symbolTable) const {
    return expressionTraversalHelper->canSignalBeUsedOnAssignmentLhs(signalAccess.var->name)
        && !didPreviousDecisionMatchingChoiceCauseConflict(LearnedConflictsLookupKey(operationNodeId, toBeChosenAlternative))
        && !doesExprContainOverlappingAccessOnGivenSignalAccess(alternativeToCheckAsExpr, signalAccess, symbolTable)
        && !isChoiceOfSignalAccessBlockedByAnyActiveExpression(signalAccess);
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::isAccessedSignalAssignable(const std::string_view& accessedSignalIdent) const {
    return symbolTableReference && symbolTableReference->canSignalBeAssignedTo(accessedSignalIdent).value_or(false);
}


std::optional<double> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineCostOfExpr(const syrec::expression& expr, std::size_t currentNestingLevel) const {
    if (const auto& exprAsBinaryExpr = dynamic_cast<const syrec::BinaryExpression*>(&expr); exprAsBinaryExpr) {
        ++currentNestingLevel;
        const std::optional<double> costOfLhsExpr = determineCostOfExpr(*exprAsBinaryExpr->lhs, currentNestingLevel);
        const std::optional<double> costOfRhsExpr = costOfLhsExpr.has_value() ? determineCostOfExpr(*exprAsBinaryExpr->rhs, currentNestingLevel) : std::nullopt;

        if (costOfRhsExpr.has_value()) {
            return (internalConfig.expressionNestingPenaltyScalingPerNestingLevel * currentNestingLevel * internalConfig.expressionNestingPenalty) + *costOfLhsExpr + *costOfRhsExpr;
        }
        return std::nullopt;
    }
    if (const auto& exprAsShiftExpr = dynamic_cast<const syrec::ShiftExpression*>(&expr); exprAsShiftExpr) {
        ++currentNestingLevel;
        const std::optional<double> costOfToBeShiftedExpr = determineCostOfExpr(*exprAsShiftExpr->lhs, currentNestingLevel);
        const std::optional<double> costOfShiftAmount     = costOfToBeShiftedExpr.has_value() ? determineCostOfNumber(*exprAsShiftExpr->rhs, currentNestingLevel) : std::nullopt;

        if (costOfShiftAmount.has_value()) {
            return (internalConfig.expressionNestingPenaltyScalingPerNestingLevel * currentNestingLevel * internalConfig.expressionNestingPenalty) + *costOfToBeShiftedExpr + *costOfShiftAmount;
        }
        return std::nullopt;
    }
    if (const auto& exprAsNumericExpr = dynamic_cast<const syrec::NumericExpression*>(&expr); exprAsNumericExpr) {
        return determineCostOfNumber(*exprAsNumericExpr->value, currentNestingLevel + 1);
    }
    if (const auto& exprAsVariableExpr = dynamic_cast<const syrec::VariableExpression*>(&expr); exprAsVariableExpr) {
        return 1;
    }
    return std::nullopt;
}

std::optional<double> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineCostOfAssignment(const syrec::AssignStatement& assignment) const {
    return determineCostOfExpr(*assignment.rhs, 0);
}

std::optional<double> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineCostOfNumber(const syrec::Number& number, std::size_t currentNestingLevel) const {
    if (number.isCompileTimeConstantExpression()) {
        const std::optional<syrec::BinaryExpression::ptr> numericExprAsBinaryExpr = convertCompileTimeConstantExprToBinaryExpr(number.getExpression(), 0);
        return numericExprAsBinaryExpr.has_value() ? determineCostOfExpr(**numericExprAsBinaryExpr, currentNestingLevel + 1) : std::nullopt;
    }
    return 1;
}

std::optional<double> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineCostOfAssignments(const std::vector<AssignmentTransformer::SharedAssignmentReference>& assignmentsToCheck) const {
    std::optional<double> sumOfCosts = 0;
    for (auto&& assignment: assignmentsToCheck) {
        if (!sumOfCosts.has_value()) {
            break;
        }

        if (std::holds_alternative<std::shared_ptr<syrec::AssignStatement>>(assignment)) {
            const std::shared_ptr<syrec::AssignStatement> assignmentCastedAsBinaryOne = std::get<std::shared_ptr<syrec::AssignStatement>>(assignment);
            tryAddCosts(sumOfCosts, determineCostOfAssignment(*assignmentCastedAsBinaryOne));
        } else if (std::holds_alternative<std::shared_ptr<syrec::UnaryStatement>>(assignment)) {
            tryAddCosts(sumOfCosts, 1);
        } else {
            sumOfCosts.reset();
        }
    }
    return sumOfCosts;
}

std::optional<double> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineCostOfAssignments(SimplificationResult::OwningCopiesOfAssignment& assignments) const {
    std::optional<double> sumOfCosts = 0;
    for (auto&& assignment : assignments){
        if (!sumOfCosts.has_value()) {
            break;
        }

        if (std::holds_alternative<std::unique_ptr<syrec::AssignStatement>>(assignment)) {
            std::unique_ptr<syrec::AssignStatement> temporarilyOwningBinaryAssignment = std::move(std::get<std::unique_ptr<syrec::AssignStatement>>(assignment));
            tryAddCosts(sumOfCosts, determineCostOfAssignment(*temporarilyOwningBinaryAssignment));
            assignment = std::move(temporarilyOwningBinaryAssignment);
        }
        else if (std::holds_alternative<std::unique_ptr<syrec::UnaryStatement>>(assignment)) {
            tryAddCosts(sumOfCosts, 1);
        }
        else {
            sumOfCosts.reset();
        }
    }
    return sumOfCosts;
}

noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::SimplificationResultReference noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineMostViableAlternativeBasedOnCost(SimplificationResultReference& generatedSimplifiedAssignments, const std::shared_ptr<syrec::AssignStatement>& originalAssignmentUnoptimized, const SignalValueLookupCallback& signalValueCallback) const {
    SimplificationResultReference endResult = std::make_unique<SimplificationResult>();
    if (internalConfig.preferAssignmentsGeneratedByChoiceRegardlessOfCost) {
        return std::move(generatedSimplifiedAssignments);
    }

    /*if (!generatedSimplifiedAssignments.empty() && (!doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(*originalAssignmentUnoptimized->rhs) || internalConfig.preferAssignmentsGeneratedByChoiceRegardlessOfCost)) {
        return generatedSimplifiedAssignments;
    }*/

    auto containerForUnoptimizedOriginalAssignment = std::vector<AssignmentTransformer::SharedAssignmentReference>(1, originalAssignmentUnoptimized);
    containerForUnoptimizedOriginalAssignment      = assignmentTransformer->simplify(containerForUnoptimizedOriginalAssignment, signalValueCallback);

    const std::optional<std::size_t> costOfUnoptimizedAssignment                                 = determineCostOfAssignments(containerForUnoptimizedOriginalAssignment);
    const std::optional<std::size_t> costOfRequiredValueResetsOfOptimizedAssignments             = costOfUnoptimizedAssignment.has_value() ? determineCostOfAssignments(generatedSimplifiedAssignments->requiredValueResetsForReplacementsTargetingExistingSignals) : std::nullopt;
    const std::optional<std::size_t> costOfOptimizedAssignments                                  = costOfRequiredValueResetsOfOptimizedAssignments.has_value() ? determineCostOfAssignments(generatedSimplifiedAssignments->generatedAssignments) : std::nullopt;
    const std::optional<std::size_t> costOfRequiredInversionsOfValueResetsOfOptimizedAssignments = costOfOptimizedAssignments.has_value() ? determineCostOfAssignments(generatedSimplifiedAssignments->requiredInversionsOfValuesResetsForReplacementsTargetingExistingSignals) : std::nullopt;

    std::optional<double> sumOfCostsOfOptimizedAssignments = 0;
    tryAddCosts(sumOfCostsOfOptimizedAssignments, costOfRequiredValueResetsOfOptimizedAssignments);
    tryAddCosts(sumOfCostsOfOptimizedAssignments, costOfOptimizedAssignments);
    tryAddCosts(sumOfCostsOfOptimizedAssignments, costOfRequiredInversionsOfValueResetsOfOptimizedAssignments);

    if (sumOfCostsOfOptimizedAssignments.has_value() && costOfOptimizedAssignments.has_value() && *sumOfCostsOfOptimizedAssignments < *costOfUnoptimizedAssignment) {
        return std::move(generatedSimplifiedAssignments);
    }

    if (std::optional<SimplificationResult::OwningCopiesOfAssignment> owningCopiesOfAssignmentsOfTransformedOriginalAssignment = createOwningCopiesOfAssignments(containerForUnoptimizedOriginalAssignment); owningCopiesOfAssignmentsOfTransformedOriginalAssignment.has_value()) {
        return std::make_unique<SimplificationResult>(SimplificationResult::asCopyOf(SimplificationResult({.newlyGeneratedReplacementSignalDefinitions                              = {},
                                                                                                           .generatedAssignments                                                    = std::move(*owningCopiesOfAssignmentsOfTransformedOriginalAssignment),
                                                                                                           .requiredValueResetsForReplacementsTargetingExistingSignals              = {},
                                                                                                           .requiredInversionsOfValuesResetsForReplacementsTargetingExistingSignals = {}})));    
    }
    return nullptr;
}

std::variant<syrec::VariableAccess::ptr, syrec::expression::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::createFinalSimplificationResultAfterDecisionWasMade(const DecisionReference& madeDecision, const OperationOperandSimplificationResult& lhsOperandOfOperationNode, syrec_operation::operation definedOperationAtOperationNode, const OperationOperandSimplificationResult& rhsOperandOfOperationNode, const SignalValueLookupCallback& callbackForValueLookupOfExistingSymbolTableSignals) {
    if (madeDecision->choosenOperand == Decision::ChoosenOperand::None) {
        /*
         * Replacing the topmost expression via a replacement does not lead to any improvement and would only introduce unnecessary additional signals.
         * Furthermore, we assume that the topmost operation node has an id with value 0.
         */
        if (madeDecision->operationNodeId) {
            const std::size_t currentNumberOfExistingAssignments = generatedAssignmentsContainer->getNumberOfAssignments();
            bool wasExistingEntryForExprOfOperationNodeUpdated = false;
            if (const std::optional<syrec::VariableAccess::ptr> generatedReplacementForWholeExpr = getAndActiveReplacementForOperationNode(madeDecision->operationNodeId, definedOperationAtOperationNode, lhsOperandOfOperationNode, rhsOperandOfOperationNode, &wasExistingEntryForExprOfOperationNodeUpdated, callbackForValueLookupOfExistingSymbolTableSignals); generatedReplacementForWholeExpr.has_value()) {
                /*
                * Since we use the expression traversal helper to determine whether a signal ident refers to an assignable signal in our implementation of a decision, and due to the fact that said
                * lookup is initially built during the generation of the traversal data from the initial assignment right-hand side expression, we need to manually add the generated replacement signal
                * as an assignable signal.
                */
                expressionTraversalHelper->markSignalAsAssignable(generatedReplacementForWholeExpr->get()->var->name);
                logCreationOfSubstitutionOfExprOfOperationNode(madeDecision->operationNodeId, generatedReplacementForWholeExpr->get()->var->name, wasExistingEntryForExprOfOperationNodeUpdated);

                /*
                 * The replacement of the given expression by an replacement is equivalent to generating an assignment from one of its operands, thus we can also invert all active assignments
                 * that contributed to the given expression.
                 */
                const std::size_t numberOfAssignmentsToNotInvertStartingFromLastCreatedOne = generatedAssignmentsContainer->getNumberOfAssignments() - currentNumberOfExistingAssignments;
                generatedAssignmentsContainer->invertAllAssignmentsUpToLastCutoff(numberOfAssignmentsToNotInvertStartingFromLastCreatedOne, nullptr);
                return *generatedReplacementForWholeExpr;
            }
        } 
    }
    else {
        /*
         * At this point no overlapping signal accesses can be contained in the rhs of the generated assignment since this would have already triggered a conflict.
         */
        if (const std::optional<syrec::AssignStatement::ptr> generatedAssignment = tryCreateAssignmentFromOperands(madeDecision->choosenOperand, lhsOperandOfOperationNode, definedOperationAtOperationNode, rhsOperandOfOperationNode); generatedAssignment.has_value()) {
            const std::size_t currentNumberOfExistingAssignments = generatedAssignmentsContainer->getNumberOfAssignments();
            generatedAssignmentsContainer->storeActiveAssignment(std::static_pointer_cast<syrec::AssignStatement>(*generatedAssignment));
            const std::size_t numberOfAssignmentsToNotInvertStartingFromLastCreatedOne = generatedAssignmentsContainer->getNumberOfAssignments() - currentNumberOfExistingAssignments;
            const auto&       assignedToSignalOfGeneratedAssignment                    = std::dynamic_pointer_cast<const syrec::AssignStatement>(*generatedAssignment)->lhs;
            generatedAssignmentsContainer->invertAllAssignmentsUpToLastCutoff(numberOfAssignmentsToNotInvertStartingFromLastCreatedOne, &assignedToSignalOfGeneratedAssignment);
            return std::dynamic_pointer_cast<syrec::AssignStatement>(*generatedAssignment)->lhs;
        } 
    }
    const std::optional<syrec::expression::ptr> generatedExpr = tryCreateExpressionFromOperationNodeOperandSimplifications(lhsOperandOfOperationNode, definedOperationAtOperationNode, rhsOperandOfOperationNode);
    return *generatedExpr;
}


syrec::expression::ptr noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::fuseExpressions(const syrec::expression::ptr& lhsOperand, syrec_operation::operation op, const syrec::expression::ptr& rhsOperand) {
    if (syrec_operation::isOperationShiftOperation(op)) {
        const auto& rhsOperandAsNumericExpr = std::dynamic_pointer_cast<syrec::NumericExpression>(rhsOperand);
        const auto  generatedShiftExpr      = std::make_shared<syrec::ShiftExpression>(
                lhsOperand,
                *syrec_operation::tryMapShiftOperationEnumToFlag(op),
                rhsOperandAsNumericExpr->value);
        return generatedShiftExpr;
    }
    const auto generatedBinaryExpr = std::make_shared<syrec::BinaryExpression>(lhsOperand, *syrec_operation::tryMapBinaryOperationEnumToFlag(op), rhsOperand);
    return generatedBinaryExpr;
}

std::optional<syrec::AssignStatement::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryCreateAssignmentForOperationNode(const syrec::VariableAccess::ptr& assignmentLhs, syrec_operation::operation op, const syrec::expression::ptr& assignmentRhs) {
    if (const auto matchingAssignmentOperationForOperation = syrec_operation::getMatchingAssignmentOperationForOperation(op); matchingAssignmentOperationForOperation.has_value()) {
        const auto& mappedToAssignmentOperationFlag = syrec_operation::tryMapAssignmentOperationEnumToFlag(*matchingAssignmentOperationForOperation);
        const auto& generatedAssignment = std::make_shared<syrec::AssignStatement>(assignmentLhs, *mappedToAssignmentOperationFlag, assignmentRhs);
        return generatedAssignment;
    }
    return std::nullopt;
}

syrec::expression::ptr noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::createExpressionFrom(const syrec::expression::ptr& lhsOperand, syrec_operation::operation op, const syrec::expression::ptr& rhsOperand) {
    if (syrec_operation::isOperationShiftOperation(op)) {
        const auto& rhsOperandAsNumericExpr = std::dynamic_pointer_cast<syrec::NumericExpression>(rhsOperand);
        const auto  generatedShiftExpr      = std::make_shared<syrec::ShiftExpression>(
                lhsOperand,
                *syrec_operation::tryMapShiftOperationEnumToFlag(op),
                rhsOperandAsNumericExpr->value);
        return generatedShiftExpr;
    }
    const auto generatedBinaryExpr = std::make_shared<syrec::BinaryExpression>(lhsOperand, *syrec_operation::tryMapBinaryOperationEnumToFlag(op), rhsOperand);
    return generatedBinaryExpr;
}

syrec::expression::ptr noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::createExpressionFromOperationNode(const ExpressionTraversalHelper::ptr& expressionTraversalHelper, const ExpressionTraversalHelper::OperationNodeReference& operationNode) {
    const auto& lhsOperandData = expressionTraversalHelper->getOperandAsExpr(operationNode->lhsOperand.id);
    const auto& rhsOperandData = expressionTraversalHelper->getOperandAsExpr(operationNode->rhsOperand.id);
    return createExpressionFrom(*lhsOperandData, operationNode->operation, *rhsOperandData);
}

inline syrec::expression::ptr noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::createExpressionFromOperandSimplificationResult(const OperationOperandSimplificationResult& operandSimplificationResult) {
    if (const auto& lastAssignedToSignalInOperandSimplificationResult = operandSimplificationResult.getAssignedToSignalOfAssignment(); lastAssignedToSignalInOperandSimplificationResult.has_value()) {
        return std::make_shared<syrec::VariableExpression>(*lastAssignedToSignalInOperandSimplificationResult);
    }
    return *operandSimplificationResult.getGeneratedExpr();
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesExpressionDefineNestedSplitableExpr(const syrec::expression& expr) {
    // We are assuming here that compile time constant expressions were already converted to binary expressions
    return dynamic_cast<const syrec::BinaryExpression*>(&expr) != nullptr || dynamic_cast<const syrec::ShiftExpression*>(&expr) != nullptr;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesExpressionDefineNumber(const syrec::expression& expr) {
    return dynamic_cast<const syrec::NumericExpression*>(&expr) != nullptr;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesExprDefineSignalAccess(const syrec::expression& expr) {
    return dynamic_cast<const syrec::VariableExpression*>(&expr);
}

std::optional<syrec::AssignStatement::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryCreateAssignmentFromOperands(Decision::ChoosenOperand chosenOperandAsAssignedToSignal, const OperationOperandSimplificationResult& simplificationResultOfFirstOperand, syrec_operation::operation operationNodeOperation, const OperationOperandSimplificationResult& simplificationResultOfSecondOperand) {
    if (chosenOperandAsAssignedToSignal == Decision::ChoosenOperand::None) {
        return std::nullopt;   
    }

    const std::optional<syrec::VariableAccess::ptr> lastAssignedToSignalOfFirstOperand = simplificationResultOfFirstOperand.getAssignedToSignalOfAssignment();
    const std::optional<syrec::VariableAccess::ptr> lastAssignedToSignalOfSecondOperand = simplificationResultOfSecondOperand.getAssignedToSignalOfAssignment();

    if ((chosenOperandAsAssignedToSignal == Decision::ChoosenOperand::Left && !lastAssignedToSignalOfFirstOperand.has_value()) || (chosenOperandAsAssignedToSignal == Decision::ChoosenOperand::Right && !lastAssignedToSignalOfSecondOperand.has_value())) {
        return std::nullopt;
    }

    syrec::VariableAccess::ptr assignedToSignalOfGeneratedAssignment;
    syrec::expression::ptr     generatedAssignmentRhsExpr;
    if (chosenOperandAsAssignedToSignal == Decision::ChoosenOperand::Left) {
        assignedToSignalOfGeneratedAssignment = *lastAssignedToSignalOfFirstOperand;
        if (lastAssignedToSignalOfSecondOperand.has_value()) {
            generatedAssignmentRhsExpr = std::make_shared<syrec::VariableExpression>(*lastAssignedToSignalOfSecondOperand);
        } else {
            generatedAssignmentRhsExpr = *simplificationResultOfSecondOperand.getGeneratedExpr();
        }
    } else {
        assignedToSignalOfGeneratedAssignment = *lastAssignedToSignalOfSecondOperand;
        if (lastAssignedToSignalOfFirstOperand.has_value()) {
            generatedAssignmentRhsExpr = std::make_shared<syrec::VariableExpression>(*lastAssignedToSignalOfFirstOperand);
        } else {
            generatedAssignmentRhsExpr = *simplificationResultOfFirstOperand.getGeneratedExpr();
        }
    }

    const auto& generatedAssignment = tryCreateAssignmentForOperationNode(assignedToSignalOfGeneratedAssignment, operationNodeOperation, generatedAssignmentRhsExpr);
    return generatedAssignment;
}

std::optional<syrec::expression::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryCreateExpressionFromOperationNodeOperandSimplifications(const OperationOperandSimplificationResult& simplificationResultOfFirstOperand, syrec_operation::operation operationNodeOperation, const OperationOperandSimplificationResult& simplificationResultOfSecondOperand) {
    const std::optional<syrec::expression::ptr> generatedLhsOperandExpr = tryCreateExpressionFromOperationNodeOperandSimplification(simplificationResultOfFirstOperand);
    const std::optional<syrec::expression::ptr> generatedRhsOperandExpr = generatedLhsOperandExpr.has_value() ? tryCreateExpressionFromOperationNodeOperandSimplification(simplificationResultOfSecondOperand) : std::nullopt;
    if (generatedRhsOperandExpr.has_value()) {
        return fuseExpressions(*generatedLhsOperandExpr, operationNodeOperation, *generatedRhsOperandExpr);
    }
    return std::nullopt;
}

std::optional<syrec::expression::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryCreateExpressionFromOperationNodeOperandSimplification(const OperationOperandSimplificationResult& simplificationResultOfOperand) {
    if (const std::optional<syrec::VariableAccess::ptr> lastAssignedToSignalOfFirstOperand = simplificationResultOfOperand.getAssignedToSignalOfAssignment(); lastAssignedToSignalOfFirstOperand.has_value()) {
        if (const syrec::expression::ptr generatedVariableExpr = std::make_shared<syrec::VariableExpression>(*lastAssignedToSignalOfFirstOperand); generatedVariableExpr) {
            return generatedVariableExpr;
        }
    } else {
        if (std::optional<syrec::expression::ptr> preexistingExpr = simplificationResultOfOperand.getGeneratedExpr(); preexistingExpr.has_value()) {
            return preexistingExpr;
        }
    }
    return std::nullopt;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::areAssignedToSignalPartsZero(const syrec::VariableAccess& accessedSignalParts, const SignalValueLookupCallback& signalValueLookupCallback) {
    const std::optional<unsigned int> fetchedValueOfAccessedSignalParts = signalValueLookupCallback(accessedSignalParts);
    return fetchedValueOfAccessedSignalParts.has_value() && !*fetchedValueOfAccessedSignalParts;
}

// TODO: One could extend this condition to also include that non-reversible operations are only defined at operations nodes with only leaf nodes
bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(const syrec::expression& expr) {
    if (const auto& exprAsNumericExpr = dynamic_cast<const syrec::NumericExpression*>(&expr); exprAsNumericExpr) {
        return !exprAsNumericExpr->value->isCompileTimeConstantExpression();
    }
    if (const auto& exprAsVariableExpr = dynamic_cast<const syrec::VariableExpression*>(&expr); exprAsVariableExpr) {
        return true;
    }
    if (const auto& exprAsBinaryExpr = dynamic_cast<const syrec::BinaryExpression*>(&expr); exprAsBinaryExpr) {
        const std::optional<syrec_operation::operation> mappedToBinaryOperationEnumValue = syrec_operation::tryMapBinaryOperationFlagToEnum(exprAsBinaryExpr->op);
        if (mappedToBinaryOperationEnumValue.has_value() && syrec_operation::getMatchingAssignmentOperationForOperation(*mappedToBinaryOperationEnumValue).has_value()) {
            if (*mappedToBinaryOperationEnumValue == syrec_operation::operation::BitwiseXor) {
                return !(doesExpressionDefineNestedSplitableExpr(*exprAsBinaryExpr->lhs) && doesExpressionDefineNestedSplitableExpr(*exprAsBinaryExpr->rhs))
                    && doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(*exprAsBinaryExpr->lhs) && doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(*exprAsBinaryExpr->rhs);
            }
            return doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(*exprAsBinaryExpr->lhs) && doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(*exprAsBinaryExpr->rhs);
        }
    }
    return false;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryConvertNumericToBinaryExpr(syrec::expression::ptr& expr) {
    if (const auto& lhsExprAsNumericExpr = std::dynamic_pointer_cast<const syrec::NumericExpression>(expr)) {
        if (const auto& lhsNumericExprAsBinaryExpr = convertNumericExprToBinary(*lhsExprAsNumericExpr); lhsNumericExprAsBinaryExpr.has_value()) {
            expr = *lhsNumericExprAsBinaryExpr;
        }
    }
}


std::optional<syrec::BinaryExpression::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::convertNumericExprToBinary(const syrec::NumericExpression& numericExpr) {
    if (!numericExpr.value->isCompileTimeConstantExpression()) {
        return std::nullopt;
    }
    return convertCompileTimeConstantExprToBinaryExpr(numericExpr.value->getExpression(), numericExpr.bwidth);
}

std::optional<syrec_operation::operation> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryMapCompileTimeConstantExprOperationToBinaryOperation(syrec::Number::CompileTimeConstantExpression::Operation operation) {
    switch (operation) {
        case syrec::Number::CompileTimeConstantExpression::Addition:
            return syrec_operation::operation::Addition;
        case syrec::Number::CompileTimeConstantExpression::Subtraction:
            return syrec_operation::operation::Subtraction;
        case syrec::Number::CompileTimeConstantExpression::Multiplication:
            return syrec_operation::operation::Multiplication;
        case syrec::Number::CompileTimeConstantExpression::Division:
        default:
            return std::nullopt;
    }
}

syrec::expression::ptr noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::convertNumberToExpr(const syrec::Number::ptr& number, unsigned int expectedBitwidth) {
    if (number->isCompileTimeConstantExpression()) {
        if (const std::optional<syrec::BinaryExpression::ptr> mappedToBinaryExpr = convertCompileTimeConstantExprToBinaryExpr(number->getExpression(), expectedBitwidth); mappedToBinaryExpr.has_value()) {
            return *mappedToBinaryExpr;
        }
        return nullptr;
    }

    const syrec::NumericExpression::ptr generatedExpr = std::make_shared<syrec::NumericExpression>(number, expectedBitwidth);
    return generatedExpr;
}

std::optional<syrec::BinaryExpression::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::convertCompileTimeConstantExprToBinaryExpr(const syrec::Number::CompileTimeConstantExpression& compileTimeConstantExpr, unsigned int expectedBitwidth) {
    const std::optional<syrec_operation::operation> mappedToOperation = tryMapCompileTimeConstantExprOperationToBinaryOperation(compileTimeConstantExpr.operation);
    if (!mappedToOperation.has_value()) {
        return std::nullopt;
    }

    const syrec::expression::ptr& lhsOperandConverted = convertNumberToExpr(compileTimeConstantExpr.lhsOperand, expectedBitwidth);
    const syrec::expression::ptr& rhsOperandConverted = convertNumberToExpr(compileTimeConstantExpr.rhsOperand, expectedBitwidth);
    if (!lhsOperandConverted || !rhsOperandConverted) {
        return std::nullopt;
    }

    const syrec::BinaryExpression::ptr generatedExpr = std::make_shared<syrec::BinaryExpression>(lhsOperandConverted, *syrec_operation::tryMapBinaryOperationEnumToFlag(*mappedToOperation), rhsOperandConverted);
    return generatedExpr;
}

syrec::expression::ptr noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::transformExprBeforeProcessing(const syrec::expression::ptr& initialExpr) {
    if (const auto& exprAsNumericExpr = std::dynamic_pointer_cast<syrec::NumericExpression>(initialExpr); exprAsNumericExpr) {
        if (const auto& exprConverted = convertNumericExprToBinary(*exprAsNumericExpr); exprConverted.has_value()) {
            return *exprConverted;
        }
    }
    return initialExpr;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesExprContainOverlappingAccessOnGivenSignalAccess(const syrec::expression& expr, const syrec::VariableAccess& signalAccess, const parser::SymbolTable& symbolTable) {
    if (const auto& exprAsBinaryExpr = dynamic_cast<const syrec::BinaryExpression*>(&expr); exprAsBinaryExpr) {
        return doesExprContainOverlappingAccessOnGivenSignalAccess(*exprAsBinaryExpr->lhs, signalAccess, symbolTable) || doesExprContainOverlappingAccessOnGivenSignalAccess(*exprAsBinaryExpr->rhs, signalAccess, symbolTable);
    }
    if (const auto& exprAsShiftExpr = dynamic_cast<const syrec::ShiftExpression*>(&expr); exprAsShiftExpr) {
        return doesExprContainOverlappingAccessOnGivenSignalAccess(*exprAsShiftExpr->lhs, signalAccess, symbolTable) || doesNumberContainOverlappingAccessOnGivenSignalAccess(*exprAsShiftExpr->rhs, signalAccess, symbolTable);
    }
    if (const auto& exprAsVariableExpr = dynamic_cast<const syrec::VariableExpression*>(&expr); exprAsVariableExpr) {
        return doSignalAccessesOverlap(signalAccess, *exprAsVariableExpr->var, symbolTable);
    }
    if (const auto& exprAsNumericExpr = dynamic_cast<const syrec::NumericExpression*>(&expr); exprAsNumericExpr) {
        return doesNumberContainOverlappingAccessOnGivenSignalAccess(*exprAsNumericExpr->value, signalAccess, symbolTable);
    }
    return false;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesNumberContainOverlappingAccessOnGivenSignalAccess(const syrec::Number& number, const syrec::VariableAccess& signalAccess, const parser::SymbolTable& symbolTable) {
    if (!number.isCompileTimeConstantExpression()) {
        return false;
    }

    const auto& numericExprAsBinaryOne = convertCompileTimeConstantExprToBinaryExpr(number.getExpression(), 0);
    return numericExprAsBinaryOne.has_value() && doesExprContainOverlappingAccessOnGivenSignalAccess(**numericExprAsBinaryOne, signalAccess, symbolTable);
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doSignalAccessesOverlap(const syrec::VariableAccess& firstSignalAccess, const syrec::VariableAccess& otherSignalAccess, const parser::SymbolTable& symbolTable) {
    const SignalAccessUtils::SignalAccessEquivalenceResult equivalenceResult = SignalAccessUtils::areSignalAccessesEqual(
            firstSignalAccess, otherSignalAccess,
            SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::DimensionAccess::Overlapping,
            SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::BitRange::Overlapping,
            symbolTable);
    return !equivalenceResult.isResultCertain || equivalenceResult.equality != SignalAccessUtils::SignalAccessEquivalenceResult::NotEqual;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::areSignalAccessesSyntacticallyEquivalent(const syrec::VariableAccess& firstSignalAccess, const syrec::VariableAccess& otherSignalAccess, const parser::SymbolTable& symbolTable) {
    const SignalAccessUtils::SignalAccessEquivalenceResult equivalenceResult = SignalAccessUtils::areSignalAccessesEqual(
            firstSignalAccess, otherSignalAccess,
            SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::DimensionAccess::Equal,
            SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::BitRange::Equal,
            symbolTable);
    return equivalenceResult.isResultCertain && equivalenceResult.equality == SignalAccessUtils::SignalAccessEquivalenceResult::Equal;
}

std::optional<unsigned> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineBitwidthOfSignalAccess(const syrec::VariableAccess& signalAccess) {
    if (!signalAccess.range.has_value()) {
        return signalAccess.var->bitwidth;
    }

    const std::optional<unsigned int> bitRangeStartEvaluated = evaluateNumber(*signalAccess.range->first);
    const std::optional<unsigned int> bitRangeEndEvaluated   = evaluateNumber(*signalAccess.range->second);
    if (!bitRangeStartEvaluated.has_value() || !bitRangeEndEvaluated.has_value()) {
        return std::nullopt;
    }
    return (*bitRangeEndEvaluated - *bitRangeStartEvaluated) + 1;
}

std::optional<unsigned> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::evaluateNumber(const syrec::Number& numberToEvaluate) {
    return numberToEvaluate.isConstant() ? std::make_optional(numberToEvaluate.evaluate({})) : std::nullopt;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesOperandSimplificationResultMatchExpression(const OperationOperandSimplificationResult& operandSimplificationResult, const syrec::expression::ptr& exprToCheck) {
    if (const std::optional<syrec::VariableAccess::ptr>& signalAccessDataOfOperand = operandSimplificationResult.getAssignedToSignalOfAssignment(); signalAccessDataOfOperand.has_value()) {
        if (const std::shared_ptr<syrec::VariableExpression>& exprAsVariableExpr = std::dynamic_pointer_cast<syrec::VariableExpression>(exprToCheck); exprAsVariableExpr) {
            return *signalAccessDataOfOperand == exprAsVariableExpr->var;
        }
    } else if (const std::optional<syrec::expression::ptr>& exprDataOfOperand = operandSimplificationResult.getGeneratedExpr(); exprDataOfOperand.has_value()) {
        return *exprDataOfOperand == exprToCheck;
    }
    return false;
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::SimplificationResult::OwningCopyOfAssignment> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::createOwningCopyOfAssignment(const syrec::AssignStatement& assignment) {
    if (auto owningCopyOfAssignment = std::make_unique<syrec::AssignStatement>(assignment); owningCopyOfAssignment) {
        return owningCopyOfAssignment;
    }
    return std::nullopt;
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::SimplificationResult::OwningCopyOfAssignment> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::createOwningCopyOfAssignment(const syrec::UnaryStatement& assignment) {
    if (auto owningCopyOfAssignment = std::make_unique<syrec::UnaryStatement>(assignment); owningCopyOfAssignment) {
        return owningCopyOfAssignment;
    }
    return std::nullopt;
}


std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::SimplificationResult::OwningCopiesOfAssignment> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::createOwningCopiesOfAssignments(const std::vector<TemporaryAssignmentsContainer::SharedAssignmentReference>& assignments) {
    SimplificationResult::OwningCopiesOfAssignment containerForCopies;
    containerForCopies.reserve(assignments.size());

    bool copyingSuccessful = true;
    for (std::size_t i = 0; i < assignments.size() && copyingSuccessful; ++i) {
        const TemporaryAssignmentsContainer::SharedAssignmentReference& statementToTreatAsAssignment = assignments.at(i);
        if (std::holds_alternative<std::shared_ptr<syrec::AssignStatement>>(statementToTreatAsAssignment)) {
            const std::shared_ptr<syrec::AssignStatement> castedStatementAsBinaryAssignment = std::get<std::shared_ptr<syrec::AssignStatement>>(statementToTreatAsAssignment);
            if (std::optional<SimplificationResult::OwningCopyOfAssignment> copyOfAssignment = createOwningCopyOfAssignment(*castedStatementAsBinaryAssignment); copyOfAssignment.has_value()) {
                containerForCopies.push_back(std::move(*copyOfAssignment));
                continue;
            }    
        }
        else if (std::holds_alternative<std::shared_ptr<syrec::UnaryStatement>>(statementToTreatAsAssignment)) {
            const std::shared_ptr<syrec::UnaryStatement> castedStatementAsUnaryAssignment = std::get<std::shared_ptr<syrec::UnaryStatement>>(statementToTreatAsAssignment);
            if (std::optional<SimplificationResult::OwningCopyOfAssignment> copyOfAssignment = createOwningCopyOfAssignment(*castedStatementAsUnaryAssignment); copyOfAssignment.has_value()) {
                containerForCopies.push_back(std::move(*copyOfAssignment));
                continue;
            }
        }
        copyingSuccessful = false;
    }
    return copyingSuccessful ? std::make_optional(std::move(containerForCopies)) : std::nullopt;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryAddCosts(std::optional<double>& currentSumOfCosts, const std::optional<double>& costsToAdd) {
    if (!costsToAdd.has_value() || !currentSumOfCosts.has_value()) {
        currentSumOfCosts.reset();
        return;
    }

    if (*costsToAdd < (UINT_MAX - *currentSumOfCosts)) {
        currentSumOfCosts = *currentSumOfCosts + *costsToAdd;
    } else {
        currentSumOfCosts.reset();
    }
}


std::vector<syrec::VariableAccess::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineSignalPartsNotUsableAsPotentialReplacementCandidates(const syrec::expression& expr, const parser::SymbolTable& symbolTable) {
    if (const auto& exprAsBinaryExpr = dynamic_cast<const syrec::BinaryExpression*>(&expr); exprAsBinaryExpr) {
        std::vector<syrec::VariableAccess::ptr> notUsableCandidatesOfLhs = determineSignalPartsNotUsableAsPotentialReplacementCandidates(*exprAsBinaryExpr->lhs, symbolTable);
        const std::vector<syrec::VariableAccess::ptr> notUsableCandidatesOfRhs = determineSignalPartsNotUsableAsPotentialReplacementCandidates(*exprAsBinaryExpr->rhs, symbolTable);

        for (const syrec::VariableAccess::ptr& notUsableCandidateOfRhs : notUsableCandidatesOfRhs) {
            if (std::all_of(notUsableCandidatesOfLhs.cbegin(), notUsableCandidatesOfLhs.cend(), [&notUsableCandidateOfRhs, &symbolTable](const syrec::VariableAccess::ptr& notUsableCandidateOfLhs) { return !areSignalAccessesSyntacticallyEquivalent(*notUsableCandidateOfLhs, *notUsableCandidateOfRhs, symbolTable); })) {
                notUsableCandidatesOfLhs.emplace_back(notUsableCandidateOfRhs);
            }
        }
        return notUsableCandidatesOfLhs;
    }
    if (const auto& exprAsShiftExpr = dynamic_cast<const syrec::ShiftExpression*>(&expr); exprAsShiftExpr) {
        return determineSignalPartsNotUsableAsPotentialReplacementCandidates(*exprAsShiftExpr->lhs, symbolTable);
    }
    if (const auto& exprAsVariableExpr = dynamic_cast<const syrec::VariableExpression*>(&expr); exprAsVariableExpr) {
        if (symbolTable.canSignalBeAssignedTo(exprAsVariableExpr->var->var->name)) {
            return {exprAsVariableExpr->var};
        }
    }
    return {};
}


constexpr bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::shouldLogMessageBePrinted() {
    #ifndef NDEBUG
    return true;
    #else
    return false;
    #endif
}

std::string noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::stringifyChosenOperandForLogMessage(Decision::ChoosenOperand chosenOperand) {
    switch (chosenOperand) {
        case Decision::ChoosenOperand::Left:
            return "LEFT";
        case Decision::ChoosenOperand::Right:
            return "RIGHT";
        case Decision::ChoosenOperand::None:
            return "NONE";
        default:
            return "UNKNOWN";
    }
}

std::string noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::stringifyRepetitionOfChoice(Decision::ChoiceRepetition setRepetitionOfChoice) {
    switch (setRepetitionOfChoice) {
        case Decision::ChoiceRepetition::None:
            return "NONE";
        case Decision::ChoiceRepetition::UntilReset:
            return "UNTIL_RESET";
        case Decision::ChoiceRepetition::Always:
            return "ALWAYS";
        default:
            return "UNKNOWN";
    }
}


void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logDecision(const DecisionReference& madeDecision) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }
    logMessage(fmt::format("Decision @ operation node {:d} choose operand {:s} | Decision repetition flag: {:s} \n", madeDecision->operationNodeId, stringifyChosenOperandForLogMessage(madeDecision->choosenOperand), stringifyRepetitionOfChoice(madeDecision->shouldChoiceBeRepeated)));
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logConflict(std::size_t operationNodeId, Decision::ChoosenOperand operandCausingConflict, const syrec::VariableAccess& signalAccessCausingConflict, const std::optional<std::size_t>& idOfEarliestDecisionInvolvedInConflict) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }
    const std::size_t printableIdOfEarliestOperationNodeInvolvedInConflict = idOfEarliestDecisionInvolvedInConflict.value_or(0);
    logMessage(fmt::format("Conflict @ operation node {:d} detected by usage of operand {:s} => signal access {:s} overlaps decision made in operation node {:d}\n", operationNodeId, stringifyChosenOperandForLogMessage(operandCausingConflict), signalAccessCausingConflict.var->name, printableIdOfEarliestOperationNodeInvolvedInConflict));
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logStartOfProcessingOfOperationNode(std::size_t operationNodeId) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }
    logMessage(fmt::format("START Processing operation node {:d}\n", operationNodeId));
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logEndOfProcessingOfOperationNode(std::size_t operationNodeId) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }
    logMessage(fmt::format("END Processing operation node {:d}\n", operationNodeId));
}


void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logBacktrackingResult(std::size_t operationNodeIdAtStartOfBacktracking, std::size_t nextOperationNodeAfterBacktrackingFinished) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }
    logMessage(fmt::format("Backtracking started @ operation node with id {:d} | finished @ operation node with id {:d} as next to be processed\n", operationNodeIdAtStartOfBacktracking, nextOperationNodeAfterBacktrackingFinished));
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logMarkingOfOperationNodeAsSourceOfConflict(std::size_t operationNodeId) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }
    logMessage(fmt::format("Marking operation node {:d} as source of conflict\n", operationNodeId));
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logMessage(const std::string& msg) {
    fmt::print(stdout, msg);
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logCreationOfSubstitutionOfOperandOfOperationNode(std::size_t operationNodeId, Decision::ChoosenOperand substitutedOperand, const syrec::VariableAccess& generatedSubstitution) {
    logMessage(fmt::format("{:s} operand in operation node {:d} was replaced with {:s}\n", stringifyChosenOperandForLogMessage(substitutedOperand), operationNodeId, generatedSubstitution.var->name));
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logLearnedConflict(std::size_t operationNodeId, Decision::ChoosenOperand learnedConflictingChoiceOfOperand) {
    logMessage(fmt::format("Remembering conflict @ operation node {:d} due to choice of operand {:s}\n", operationNodeId, stringifyChosenOperandForLogMessage(learnedConflictingChoiceOfOperand)));
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logCreationOfSubstitutionOfExprOfOperationNode(std::size_t operationNodeId, const std::string& replacementSignalIdent, bool wasExistingEntryUpdated) {
    if (wasExistingEntryUpdated) {
        logMessage(fmt::format("Updated existing replacement (defined by assignment to replacement signal {:s}) for whole expression of operation node with id {:d}\n", replacementSignalIdent, operationNodeId));
    }
    else {
        logMessage(fmt::format("Created replacement signal {:s} for whole expression of operation node with id {:d}\n", replacementSignalIdent, operationNodeId));   
    }
}
