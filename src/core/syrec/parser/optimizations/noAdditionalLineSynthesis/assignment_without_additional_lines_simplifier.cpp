#include "core/syrec/parser/optimizations/noAdditionalLineSynthesis/assignment_without_additional_lines_simplifier.hpp"
#include "core/syrec/parser/optimizations/noAdditionalLineSynthesis/assignment_without_additional_lines_simplifier.hpp"
#include "core/syrec/parser/optimizations/noAdditionalLineSynthesis/assignment_without_additional_lines_simplifier.hpp"
#include "core/syrec/parser/optimizations/noAdditionalLineSynthesis/assignment_without_additional_lines_simplifier.hpp"
#include "core/syrec/parser/optimizations/noAdditionalLineSynthesis/assignment_without_additional_lines_simplifier.hpp"
#include "core/syrec/parser/optimizations/noAdditionalLineSynthesis/assignment_without_additional_lines_simplifier.hpp"
#include "core/syrec/parser/optimizations/noAdditionalLineSynthesis/assignment_without_additional_lines_simplifier.hpp"
#include "core/syrec/parser/optimizations/noAdditionalLineSynthesis/assignment_without_additional_lines_simplifier.hpp"
#include "core/syrec/parser/utils/copy_utils.hpp"
#include "core/syrec/parser/utils/signal_access_utils.hpp"

#ifndef NDEBUG
#include "fmt/format.h"
#endif

/*
 * TODO: IMPORTANT (testcase simplificationWithOnlyReversibleOpsAndUniqueSignalAccessesWithTopmostAssignmentBeingXorCorrectlyHandlesMixedOperationsInRhsExpr) is missing required inversion of assignments
 *
 * TODO: Add as a precondition that no signal accesses overlapping the lhs operand of the initial assignment exists on the rhs which should already be done by the caller but a safety to prevent invalid assignments generated by this simplifier
 * TODO: When inverting all active assignments during processing of operation node, we should not "deactivated" active assignments that operate on the same signal as the chosen one in the operation node - IMPORTANT
 * TODO: Are active assignments added to set determining conflicts
 * TODO: If a decision was prevented by learned conflict the generated expr could be further simplified in the parent operation node (i.e. b += (d - 2) was created when the learned conflict was d and could be simplified to b += d; b -= 2)
 *
 * TODO: If original rhs expr does only consist of invertible operations (with xor only defined for leaf nodes) fallback to expression split
 * TODO: Shift expressions are currently not handled since the shift amount is a number::ptr instead of an expression::ptr
 *
 *
 * TODO: Currently we have a problem to fine a correct metric to decide whether we should perform our "simple" or "complex" simplification algorithm if the assignment only contains reversible operations (its a problem since the "complex" algorithm leads to a larger code size due to a larger number of assignments being created)
 * TODO: IMPORTANT: When a conflict arises we should only remember the conflict at the earliest node to not prevent the reuse of assignment that could lead to conflicts but are "defused" by an assignment higher in the traversal queue
 * TODO: NICE-TO-HAVE: Try to perform constant propagation and further optimizations if value of any signal changes during simplifications
 *
 * TODO: Reordering sequences of assignment statements could lead to further optimization potential, see test case simplificationWithOnlyReversibleOpsAndUniqueSignalAccessHandlesRhsCorrectlyIfRhsCreatesNoAssignmentAndAssignmentOperationIsXorAndTopmostOperationOfRhsIsMinusAndAssignedtoSignalValueIsNotZero
 * TODO: Could the simplification (a - (b + c)) = (a - (c - b)) lead to further optimizations?
 *
 * TODO: Some cases could offer new optimizations: module main(out a(16), inout b(16), in c(16), in d(16)) a += (((b - c) + b) * d) [see simplification of previous point])
 *
 * TODO: IMPORTANT - When processing a rhs of an expression we cannot use any operand use in the lhs expr (how can we do this efficiently, does this check need to be done everytime)
 * TODO: IMPORTANT - Check whether we need to add additional tests for the the tie breaker flag is not specified and the simplified assignments of the original assignment cost less than the simplified ones
 * TODO: IMPORTANT - Check the metric chosen for the weighting, if our topmost expression has a nesting level of two but the simplified ones only have a nesting level of 1 but the latter is inverted once
 * (i.e.) a += ((b + c) + d) being the topmost assignment while the simplified ones are d += (b + c); a ^= d; d -= (b + c). [Also add tests for this]
 * TODO: IMPORTANT - The split of an simplified assignment (i.e. a -= (b + 2)) at the topmost level leads to the sequence a -= b; a -= 2 ... a += b; a += 2
 *  if the split would take place immediately after the creation of the assignment would lead to the sequence a += b; a += 2 ... a -= b; a -= 2
 *
 * TODO: Testcase 'simplifyWithOnlyReversibleOpsButNonUniqueSignalAccessWithAssignOperationBeingAdditionWithDegeneratedLhsSubASTOfLhsOfAssignmentExpr' is an example where the heuristic optimization of - (<subExpr_1> - <subExpr_2>) leads to a worse result
 *
 * TODO: Should the decisions for intermediate operation nodes (i.e. with non-leaf nodes be extendened from the simple left, right distinction to a lookup) ?
 *
 * TODO: IMPORTANT: Rework of conflict handling that conflicting decision could be remade when reset in by a parent decision (check detection of hot path, found earliest conflict node, etc.)
 * TODO: IMPORTANT: Tests that decision are remade not on hot path
 * TODO: IMPORTANT: Assignments using boxing (i.e. operand has bitwidth 5 instead of 4) should not be able to be processed
 * TODO: IMPORTANT: Assignment where the bitwidth is unknown will not use replacements
 */



// TODO: We should probably also validate that the optimized circuit that is created after a successful parse is also correct
// TODO: Correct update of reference counts for simplification of assignments with no additional lines

/*
 * REPLACEMENT GENERATOR TODOS:
 * - Correct reference count updates for new signals
 * - Correct insertion of new signals into symbol table
 * - Correct reference count updates when assignment is simplified (i.e. split into smaller subassignments)
 * - Fixed replacement generator for example ((a + b) + (a + b)) to generate replacement __x ^= a; ... and not __x ^= (a + b) [see test case 'simpleReplacementTest']
 */

/*
 * Ideas for the introduction of replacements:
 * - Replace signal accesses at operation nodes which are the cause of the conflict with a replacement
 * - Replace expressions with replacements (synthesizing the expression y += (a * (b + c)) is more costly than x ^= (b + c); y += (a * x)?
 * - Replacements should at first be looked for in existing signals that are unused in the expression and only if none are available should extra signals be introduced
 */
// TODO: CHECK TEST simplificationWithNoneReversibleOperationWithXorAssignOperationAndTopmostOperationOfRhsBeingAdditionOperationWithLhsGeneratingAssignmentAndRhsGeneratingAssignmentCreatesCorrectAssignment FOR FAILED ROLLBACK
noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::SimplificationResult::OwningReference noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::simplify(const syrec::AssignStatement& assignmentStatement, const SignalValueLookupCallback& signalValueLookupCallback) {
    resetInternals();
    if (!symbolTableReference) {
        return SimplificationResult::createOwningReferenceOf(SimplificationResult::asEmptyResult());
    }

    // TODO: For a binary expression with no nested expressions as operands, should we prefer that a signal access is always the lhs operand
    const std::shared_ptr<syrec::AssignStatement> transformedAssignmentStmt = transformAssignmentPriorToSimplification(assignmentStatement, true);
    if (!transformedAssignmentStmt) {
        return SimplificationResult::createOwningReferenceOf(SimplificationResult::asEmptyResult());
    }

    topmostAssignmentOperation = syrec_operation::tryMapAssignmentOperationFlagToEnum(transformedAssignmentStmt->op);
    if (!topmostAssignmentOperation.has_value()) {
        return SimplificationResult::createOwningReferenceOf(SimplificationResult::asEmptyResult());
    }

    expressionTraversalHelper->buildTraversalQueue(transformedAssignmentStmt->rhs, *symbolTableReference);
    disableValueLookup();
    const std::vector<syrec::VariableAccess::ptr> replacementCandidateRestrictionsStemmingFromAssignment = defineNotUsableReplacementCandidatesFromAssignmentForGenerator(*transformedAssignmentStmt);
    determinedBitWidthOfAssignmentToSimplify                                                             = determineBitwidthOfSignalAccess(*assignmentStatement.lhs);

    bool                                                               continueProcessingOperationNode = true;
    std::optional<OperationNodeSimplificationResult::OwningReference> simplificationResultOfTopmostOperationNode;
    while (continueProcessingOperationNode) {
        std::optional<ExpressionTraversalHelper::OperationNodeReference> topMostOperationNode = expressionTraversalHelper->getNextOperationNode();

        // TODO: If an expression is created for the rhs we can still try to split it if a binary operation with an assignment counterpart exists
        simplificationResultOfTopmostOperationNode = topMostOperationNode.has_value() ? handleOperationNode(*topMostOperationNode, signalValueLookupCallback) : std::nullopt;
        if (shouldBacktrackDueToConflict()) {
            markSourceOfConflictReached();
            backtrack(topMostOperationNode->get()->id, false);
        } else {
            continueProcessingOperationNode = !simplificationResultOfTopmostOperationNode.has_value();
        }
    }

    if (simplificationResultOfTopmostOperationNode.has_value()) {
        if (!simplificationResultOfTopmostOperationNode->get()->hasKnownValue()) {
            return SimplificationResult::createOwningReferenceOf(SimplificationResult::asEmptyResult());
        }

        const std::optional<syrec::Expression::ptr>& generatedExprForTopmostOperationRhsExpr = simplificationResultOfTopmostOperationNode->get()->getResultAsExpr();
        const std::optional<syrec::VariableAccess::ptr>& generatedLastAssignedToSignalOfRhsExpr  = simplificationResultOfTopmostOperationNode->get()->getResultAsSignalAccess();
        TemporaryAssignmentsContainer::OrderedAssignmentIdContainer dataDependenciesOfTopmostAssignmentStatement;

        syrec::VariableAccess::ptr generatedAssignmentAssignedToSignal = transformedAssignmentStmt->lhs;
        syrec::Expression::ptr     generatedAssignmentRhsExpr;
        if (generatedLastAssignedToSignalOfRhsExpr.has_value()) {
            generatedAssignmentRhsExpr = std::make_shared<syrec::VariableExpression>(*generatedLastAssignedToSignalOfRhsExpr);
            if (const std::optional<std::size_t>& idOfGeneratedAssignmentByTopmostAssignment = simplificationResultOfTopmostOperationNode->get()->getIdOfGeneratedAssignment(); idOfGeneratedAssignmentByTopmostAssignment.has_value()) {
                dataDependenciesOfTopmostAssignmentStatement.emplace(*idOfGeneratedAssignmentByTopmostAssignment);
            }
        } else {
            generatedAssignmentRhsExpr = *generatedExprForTopmostOperationRhsExpr;
            const std::vector<std::size_t>& dataDependenciesInheritedForTopmostAssignment = simplificationResultOfTopmostOperationNode->get()->getDataDependenciesAsIdsOfDependentAssignments();
            dataDependenciesOfTopmostAssignmentStatement.insert(dataDependenciesInheritedForTopmostAssignment.cbegin(), dataDependenciesInheritedForTopmostAssignment.cend());
        }

        unsigned int mappedToAssignmentOperationFlagValue = transformedAssignmentStmt->op;
        if (topmostAssignmentOperation.has_value()) {
            mappedToAssignmentOperationFlagValue = syrec_operation::tryMapAssignmentOperationEnumToFlag(*topmostAssignmentOperation).value_or(transformedAssignmentStmt->op);
        }
        if (const std::shared_ptr<syrec::AssignStatement> generatedAssignment = std::make_shared<syrec::AssignStatement>(generatedAssignmentAssignedToSignal, mappedToAssignmentOperationFlagValue, generatedAssignmentRhsExpr); generatedAssignment) {
            const std::optional<std::size_t> idOfTopmostAssignment = generatedAssignmentsContainer->storeActiveAssignment(generatedAssignment, std::nullopt, dataDependenciesOfTopmostAssignmentStatement, 0, std::nullopt);
            if (!idOfTopmostAssignment.has_value() || !std::all_of(dataDependenciesOfTopmostAssignmentStatement.cbegin(), dataDependenciesOfTopmostAssignmentStatement.cend(), [&](const std::size_t dataDependency) { return generatedAssignmentsContainer->invertAssignmentAndDataDependencies(dataDependency); })) {
                return SimplificationResult::createOwningReferenceOf(SimplificationResult::asEmptyResult());
            }
        }
        else {
            return SimplificationResult::createOwningReferenceOf(SimplificationResult::asEmptyResult());
        }
    }
    clearNotUsableReplacementCandidatesFromAssignmentForGenerator(replacementCandidateRestrictionsStemmingFromAssignment);

    bool                                                                   wasAnyAssignmentGeneratedDuringProcessing = true;
    std::vector<TemporaryAssignmentsContainer::AssignmentReferenceVariant> generatedAssignments;
    if (!generatedAssignmentsContainer->getNumberOfAssignments()) {
        if (const std::shared_ptr<syrec::AssignStatement> topMostAssignmentStmtIfNoOptimizationTookPlace = transformedAssignmentStmt ? transformedAssignmentStmt : std::make_shared<syrec::AssignStatement>(assignmentStatement); topMostAssignmentStmtIfNoOptimizationTookPlace) {
            generatedAssignments.emplace_back(topMostAssignmentStmtIfNoOptimizationTookPlace);
            wasAnyAssignmentGeneratedDuringProcessing = false;
        }
    } else {
        generatedAssignments = generatedAssignmentsContainer->getAssignments();
    }

    /*
     * If any assignments where generated by our more "complex" algorithm, try to determine the more viable alternative by comparing the cost of the simplified assignments generated
     * by the more "simple" algorithm (if applicable) to the ones generated by the "complex" one.
     *
     * NOTE: At this point the symbol table entries for the newly generated replacement signals might not exist yet if said signals were created during the current iteration.
     * The internal value lookup will not work for said signals and classes using this lookup must handle this case accordingly.
     */
    generatedAssignments = assignmentTransformer->simplify(generatedAssignments, signalValueLookupCallback);
    if (wasAnyAssignmentGeneratedDuringProcessing) {
        SimplificationResult::OwningReference finalSimplificationResultInCaseAnyAssignmentWereGenerated;
        if (std::optional<SimplificationResult::OwningCopiesOfAssignment> requiredInversionsOfValueResetsAfterUsageOfGeneratedReplacements = generatedAssignmentsContainer->getInvertedAssignmentsUndoingValueResetsOfGeneratedSubstitutions(); requiredInversionsOfValueResetsAfterUsageOfGeneratedReplacements.has_value()) {
            if (std::optional<SimplificationResult::OwningCopiesOfAssignment> owningCopiesOfGeneratedAssignments = createOwningCopiesOfAssignments(generatedAssignments); owningCopiesOfGeneratedAssignments.has_value()) {
                if (std::optional<SimplificationResult::OwningCopiesOfAssignment> requiredValueResetsPriorToUsageOfGeneratedReplacements = generatedAssignmentsContainer->getAssignmentsDefiningValueResetsOfGeneratedSubstitutions(); requiredValueResetsPriorToUsageOfGeneratedReplacements.has_value()) {
                    const syrec::Variable::vec newlyGeneratedReplacementCandidates = substitutionGenerator ? substitutionGenerator->getDefinitionsOfReplacementsCreatedFromNewlyGeneratedSignals() : syrec::Variable::vec();

                    SimplificationResult internalContainerOfSimplificationResult       = SimplificationResult();
                    internalContainerOfSimplificationResult.newlyGeneratedReplacementSignalDefinitions                              = newlyGeneratedReplacementCandidates;
                    internalContainerOfSimplificationResult.generatedAssignments                                                    = std::move(*owningCopiesOfGeneratedAssignments);
                    internalContainerOfSimplificationResult.requiredValueResetsForReplacementsTargetingExistingSignals              = std::move(*requiredValueResetsPriorToUsageOfGeneratedReplacements);
                    internalContainerOfSimplificationResult.requiredInversionsOfValuesResetsForReplacementsTargetingExistingSignals = std::move(*requiredInversionsOfValueResetsAfterUsageOfGeneratedReplacements);

                    finalSimplificationResultInCaseAnyAssignmentWereGenerated          = SimplificationResult::createOwningReferenceOf(std::move(internalContainerOfSimplificationResult));
                }
            }
        }
        if (const std::shared_ptr<syrec::AssignStatement>& transformedAssignmentStmtWithoutAppliedHeuristicsForSubassignmentGeneration = transformAssignmentPriorToSimplification(assignmentStatement, false); transformedAssignmentStmtWithoutAppliedHeuristicsForSubassignmentGeneration) {
            if (SimplificationResult::OwningReference mostViableAlternative = determineMostViableAlternativeBasedOnCost(finalSimplificationResultInCaseAnyAssignmentWereGenerated, transformedAssignmentStmtWithoutAppliedHeuristicsForSubassignmentGeneration, signalValueLookupCallback); mostViableAlternative) {
                return mostViableAlternative;
            }      
        }
    }

    if (std::optional<SimplificationResult::OwningCopyOfAssignment> owningCopyOfTransformedAssignment = transformedAssignmentStmt ? createOwningCopyOfAssignment(*transformedAssignmentStmt) : std::nullopt; owningCopyOfTransformedAssignment.has_value()) {
        return SimplificationResult::createOwningReferenceOf(SimplificationResult::asSingleStatement(std::move(*owningCopyOfTransformedAssignment)));
    }
    return SimplificationResult::createOwningReferenceOf(SimplificationResult::asEmptyResult());
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::resetForUsageInNewModule(const parser::SymbolTable::ptr& activeSymbolTableScope) {
    defineSymbolTable(activeSymbolTableScope);
    reloadGenerateableReplacementSignalName();
}

// START OF NON-PUBLIC FUNCTION IMPLEMENTATIONS
std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OperationNodeSimplificationResult::OwningReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleOperationNode(const ExpressionTraversalHelper::OperationNodeReference& operationNode, const SignalValueLookupCallback& signalValueLookupCallback) {
    logStartOfProcessingOfOperationNode(operationNode->id);
    operationNode->disableIsOneTimeOperationInversionFlag();
    std::optional<OperationNodeSimplificationResult::OwningReference> simplificationResult;
    if (!operationNode->hasAnyLeafOperandNodes()) {
        simplificationResult = handleOperationNodeWithNoLeafNodes(operationNode, signalValueLookupCallback);
    }
    else if (operationNode->areBothOperandsLeafNodes()) {
        simplificationResult = handleOperationNodeWithOnlyLeafNodes(operationNode, signalValueLookupCallback);
    } else {
        simplificationResult = handleOperationNodeWithOneLeafNode(operationNode, signalValueLookupCallback);
    }
    logEndOfProcessingOfOperationNode(operationNode->id);
    return simplificationResult;
}

// TODO: If the simplification of any non-leaf node did result in a conflict check whether another decision at a previous position is possible, see other functions handling operation node with one leaf node
std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OperationNodeSimplificationResult::OwningReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleOperationNodeWithNoLeafNodes(const ExpressionTraversalHelper::OperationNodeReference& operationNode, const SignalValueLookupCallback& signalValueLookupCallback) {
    std::optional<OperationNodeSimplificationResult::OwningReference>    owningLhsOperandSimplificationResult;
    std::optional<OperationNodeSimplificationResult::OwningReference>    owningRhsOperandSimplificationResult;
    syrec::Expression::ptr                                               expressionToConsiderForDecisionInSecondNode;

    std::size_t idOfLastActiveAssignmentPriorToProcessingOfLhsOperand;
    std::size_t idOfLastActiveAssignmentPriorToProcessingOfRhsOperand;
    bool continueProcessing = true;
    while (continueProcessing) {
        generatedAssignmentsContainer->markCutoffForInvertibleAssignments();
        expressionTraversalHelper->markOperationNodeAsPotentialBacktrackOption(operationNode->id);

        idOfLastActiveAssignmentPriorToProcessingOfLhsOperand        = generatedAssignmentsContainer->getIdOfLastGeneratedAssignment().value_or(0);
        OperationNodeProcessingResult lhsOperandSimplificationResult = processNextOperationNode(signalValueLookupCallback);
        if (lhsOperandSimplificationResult.isResultUnknown()) {
            generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
            return OperationNodeSimplificationResult::createAndOwnNewInstance(OperationNodeSimplificationResult::createAsUnknownResult(UnknownResultReason::Other));
        }
        if (lhsOperandSimplificationResult.derivedConflictInOtherNode) {
            generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
            return std::nullopt;
        }
        owningLhsOperandSimplificationResult = std::move(lhsOperandSimplificationResult.simplificationResult);

        /*
         * If the first non-leaf node created an expression instead of an assignment, we need also need to take this generated expression as well as all active assignments into consideration
         * when processing the second non-leaf-node
         */
        expressionToConsiderForDecisionInSecondNode = owningLhsOperandSimplificationResult->get()->getResultAsExpr().value_or(nullptr);
        considerExpressionInFutureDecisions(expressionToConsiderForDecisionInSecondNode);

        /*
         * TODO: Is this comment correct
         * If we do not quit the processing loop of the second non-leaf operation node, we would only never reprocess the first non-leaf operation node again.
         */
        /*OperationNodeProcessingResult secondOperandProcessingResult = processNextOperationNode(signalValueLookupCallback, true);
        if (secondOperandProcessingResult.derivedConflictInOtherNode || isOperationNodeSourceOfConflict(operationNode->id)) {
            return std::nullopt;
        }*/
        idOfLastActiveAssignmentPriorToProcessingOfRhsOperand        = generatedAssignmentsContainer->getIdOfLastGeneratedAssignment().value_or(0);
        OperationNodeProcessingResult rhsOperandSimplificationResult = processNextOperationNode(signalValueLookupCallback);
        if (rhsOperandSimplificationResult.isResultUnknown()) {
            // TODO: Do we need this rollback or this is already done during the processing of the operation node
            generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
            return OperationNodeSimplificationResult::createAndOwnNewInstance(OperationNodeSimplificationResult::createAsUnknownResult(UnknownResultReason::Other));
        }
        if (rhsOperandSimplificationResult.derivedConflictInOtherNode) {
            generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
            return std::nullopt;
        }
        continueProcessing = rhsOperandSimplificationResult.derivedConflictInThisNode;
        if (!continueProcessing) {
            owningRhsOperandSimplificationResult = std::move(rhsOperandSimplificationResult.simplificationResult);
        }
    }

    const std::optional<syrec_operation::operation> definedOperationOfOperationNodeConsideringConsideringInversionFlag = operationNode->getOperationConsideringWhetherMarkedAsInverted();
    if (!definedOperationOfOperationNodeConsideringConsideringInversionFlag)
        return OperationNodeSimplificationResult::createAndOwnNewInstance(OperationNodeSimplificationResult::createAsUnknownResult(UnknownResultReason::Other));

    const DecisionResult decisionResult = makeDecisionFor(operationNode->id, **owningLhsOperandSimplificationResult, *definedOperationOfOperationNodeConsideringConsideringInversionFlag, **owningRhsOperandSimplificationResult, idOfLastActiveAssignmentPriorToProcessingOfLhsOperand, idOfLastActiveAssignmentPriorToProcessingOfRhsOperand, signalValueLookupCallback);
    revokeConsiderationOfExpressionForFutureDecisions(expressionToConsiderForDecisionInSecondNode);

    if (decisionResult.reasonForUnknownResult.has_value()) {
        generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
    }
    else {
        expressionTraversalHelper->removeOperationNodeAsPotentialBacktrackOperation(operationNode->id);
        generatedAssignmentsContainer->popLastCutoffForInvertibleAssignments();        
    }
    return tryPerformTransformationOfDecisionResultToOperationNodeSimplificationResultWhenNoConflictWasDetected(operationNode->id, decisionResult);
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OperationNodeSimplificationResult::OwningReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleOperationNodeWithOneLeafNode(const ExpressionTraversalHelper::OperationNodeReference& operationNode, const SignalValueLookupCallback& signalValueLookupCallback) {
    expressionTraversalHelper->markOperationNodeAsPotentialBacktrackOption(operationNode->id);
    generatedAssignmentsContainer->markCutoffForInvertibleAssignments();

    const bool                                          wasLhsOperandLeafNode                               = operationNode->getLeafNodeOperandId().value() == operationNode->lhsOperand.id;
    const std::optional<syrec::VariableExpression::ptr> dataOfLeafNodeAsVariableExpr                        = expressionTraversalHelper->getOperandAsVariableExpr(wasLhsOperandLeafNode ? operationNode->lhsOperand.id : operationNode->rhsOperand.id);
    const std::size_t                                   idOfLastActiveAssignmentPriorToProcessingOfLeafNode = generatedAssignmentsContainer->getIdOfLastGeneratedAssignment().value_or(0);
    std::shared_ptr<syrec::VariableExpression>          castedLeafNodeAsVariableExpr                        = dataOfLeafNodeAsVariableExpr.has_value() ? std::dynamic_pointer_cast<syrec::VariableExpression>(*dataOfLeafNodeAsVariableExpr) : nullptr;

    // A conflict detected via the usage of the lhs operand can only stem from an operation node with an id lower than the one of the current operation node
    if (castedLeafNodeAsVariableExpr && wasLhsOperandLeafNode) {
        const std::vector<TemporaryAssignmentsContainer::SearchSpaceIntervalBounds> searchSpaceForActiveAssignments(1, TemporaryAssignmentsContainer::SearchSpaceIntervalBounds(0, operationNode->id));
        if (const std::optional<std::size_t> idOfActiveAssignmentOverlappingLeafNode = generatedAssignmentsContainer->getOverlappingActiveAssignmentForSignalAccess(*castedLeafNodeAsVariableExpr->var, searchSpaceForActiveAssignments, *symbolTableReference); idOfActiveAssignmentOverlappingLeafNode.has_value()) {
            /*
             * Performing a dry-run of the replacement generation process to determine whether a replacement could be generated is not sufficient since during the processing of the non-leaf node the potential replacement candidates could be
             * exhausted and thus no replacement generated in the decision making function for this operation node thus validating the promise that was made here that a replacement could be generated.
             * If no replacement can be generated we have derived a conflict. We moved this conflict check that is again done in the decision making process to not start processing of the non-leaf node if we can derive a conflict from the leaf node
             * with the condition that the leaf node is the lhs operand.
             */
            if (const std::optional<syrec::VariableAccess::ptr> generatedReplacementForLeafNode = createReplacementForLeafNodeOperand(operationNode->id, Decision::ChoosenOperand::Left, castedLeafNodeAsVariableExpr, signalValueLookupCallback); !generatedReplacementForLeafNode.has_value()) {
                handleConflict(operationNode->id, Decision::ChoosenOperand::Left, *castedLeafNodeAsVariableExpr->var);
                return std::nullopt;      
            }
        }
    }

    std::variant<OperationNodeSimplificationResult::IdAndAssignmentTuple, syrec::Expression::ptr> simplificationResultDataOfLeafNode;
    if (castedLeafNodeAsVariableExpr) {
        simplificationResultDataOfLeafNode = std::make_pair(0, castedLeafNodeAsVariableExpr->var);
    } else {
        simplificationResultDataOfLeafNode = *expressionTraversalHelper->getOperandAsExpr(wasLhsOperandLeafNode ? operationNode->lhsOperand.id : operationNode->rhsOperand.id);
    }
    OperationNodeSimplificationResult simplificationResultOfLeafNode = OperationNodeSimplificationResult::createManuallyFromLeafNode(simplificationResultDataOfLeafNode);
    std::optional<OperationNodeSimplificationResult::OwningReference> simplificationResultOfOperationNodeOperand;

    OperationNodeProcessingResult resultOfNonLeafNode = processNextOperationNode(signalValueLookupCallback);
    if (resultOfNonLeafNode.isResultUnknown()) {
        generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
        return OperationNodeSimplificationResult::createAndOwnNewInstance(OperationNodeSimplificationResult::createAsUnknownResult(UnknownResultReason::Other));
    }
    if (resultOfNonLeafNode.derivedConflictInOtherNode) {
        generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
        return std::nullopt;
    }
    simplificationResultOfOperationNodeOperand = std::move(resultOfNonLeafNode.simplificationResult);
    const syrec::Expression::ptr expressionFromNonLeafNodeToBeConsideredWhenTryingToCreateAssignment = simplificationResultOfOperationNodeOperand->get()->getResultAsExpr().value_or(nullptr);
    considerExpressionInFutureDecisions(expressionFromNonLeafNodeToBeConsideredWhenTryingToCreateAssignment);

    const std::optional<syrec_operation::operation> definedOperationOfOperationNodeConsideringConsideringInversionFlag = operationNode->getOperationConsideringWhetherMarkedAsInverted();
    if (!definedOperationOfOperationNodeConsideringConsideringInversionFlag)
        return OperationNodeSimplificationResult::createAndOwnNewInstance(OperationNodeSimplificationResult::createAsUnknownResult(UnknownResultReason::Other));

    DecisionResult decisionResult;
    if (wasLhsOperandLeafNode) {
        decisionResult = makeDecisionFor(operationNode->id, simplificationResultOfLeafNode, *definedOperationOfOperationNodeConsideringConsideringInversionFlag, **simplificationResultOfOperationNodeOperand, idOfLastActiveAssignmentPriorToProcessingOfLeafNode, idOfLastActiveAssignmentPriorToProcessingOfLeafNode, signalValueLookupCallback);
    } else {
        decisionResult = makeDecisionFor(operationNode->id, **simplificationResultOfOperationNodeOperand, *definedOperationOfOperationNodeConsideringConsideringInversionFlag, simplificationResultOfLeafNode, idOfLastActiveAssignmentPriorToProcessingOfLeafNode, idOfLastActiveAssignmentPriorToProcessingOfLeafNode, signalValueLookupCallback);
    }
    revokeConsiderationOfExpressionForFutureDecisions(expressionFromNonLeafNodeToBeConsideredWhenTryingToCreateAssignment);

    if (decisionResult.reasonForUnknownResult.has_value()) {
        generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
    } else {
        expressionTraversalHelper->removeOperationNodeAsPotentialBacktrackOperation(operationNode->id);
        generatedAssignmentsContainer->popLastCutoffForInvertibleAssignments();
    }
    return tryPerformTransformationOfDecisionResultToOperationNodeSimplificationResultWhenNoConflictWasDetected(operationNode->id, decisionResult);
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OperationNodeSimplificationResult::OwningReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleOperationNodeWithOnlyLeafNodes(const ExpressionTraversalHelper::OperationNodeReference& operationNode, const SignalValueLookupCallback& signalValueLookupCallback) {
    generatedAssignmentsContainer->markCutoffForInvertibleAssignments();
    const std::size_t idOfLastActiveAssignmentPriorToProcessingOfOperationNode = generatedAssignmentsContainer->getIdOfLastGeneratedAssignment().value_or(0);

    std::optional<std::variant<OperationNodeSimplificationResult::IdAndAssignmentTuple, syrec::Expression::ptr>> simplificationResultOfLhsOperand;
    if (const std::optional<syrec::VariableExpression::ptr> fetchedDataOfAccessedSignalPartsOfLhsOperand = expressionTraversalHelper->getOperandAsVariableExpr(operationNode->lhsOperand.id); fetchedDataOfAccessedSignalPartsOfLhsOperand.has_value()) {
        if (const std::shared_ptr<syrec::VariableExpression> castedFetchedDataOfAccessedSignalPartsOfLhsOperand = std::dynamic_pointer_cast<syrec::VariableExpression>(*fetchedDataOfAccessedSignalPartsOfLhsOperand); castedFetchedDataOfAccessedSignalPartsOfLhsOperand) {
            simplificationResultOfLhsOperand = std::make_pair(0, castedFetchedDataOfAccessedSignalPartsOfLhsOperand->var);
        }
    }
    if (!simplificationResultOfLhsOperand.has_value()) {
        simplificationResultOfLhsOperand = expressionTraversalHelper->getOperandAsExpr(operationNode->lhsOperand.id);
    }

    std::optional<std::variant<OperationNodeSimplificationResult::IdAndAssignmentTuple, syrec::Expression::ptr>> simplificationResultOfRhsOperand;
    if (const std::optional<syrec::VariableExpression::ptr> fetchedDataOfAccessedSignalPartsOfRhsOperand = expressionTraversalHelper->getOperandAsVariableExpr(operationNode->rhsOperand.id); fetchedDataOfAccessedSignalPartsOfRhsOperand.has_value()) {
        if (const std::shared_ptr<syrec::VariableExpression> castedFetchedDataOfAccessedSignalPartsOfRhsOperand = std::dynamic_pointer_cast<syrec::VariableExpression>(*fetchedDataOfAccessedSignalPartsOfRhsOperand); castedFetchedDataOfAccessedSignalPartsOfRhsOperand) {
            simplificationResultOfRhsOperand = std::make_pair(0, castedFetchedDataOfAccessedSignalPartsOfRhsOperand->var);
        }
    }
    if (!simplificationResultOfRhsOperand.has_value()) {
        simplificationResultOfRhsOperand = expressionTraversalHelper->getOperandAsExpr(operationNode->rhsOperand.id);
    }

    if (!simplificationResultOfLhsOperand.has_value() || !simplificationResultOfRhsOperand.has_value()) {
        return OperationNodeSimplificationResult::createAndOwnNewInstance(OperationNodeSimplificationResult::createAsUnknownResult(UnknownResultReason::Other));
    }

    const DecisionResult decisionResult = makeDecisionFor(operationNode->id, OperationNodeSimplificationResult::createManuallyFromLeafNode(*simplificationResultOfLhsOperand), operationNode->operation, OperationNodeSimplificationResult::createManuallyFromLeafNode(*simplificationResultOfRhsOperand), idOfLastActiveAssignmentPriorToProcessingOfOperationNode, idOfLastActiveAssignmentPriorToProcessingOfOperationNode, signalValueLookupCallback);
    generatedAssignmentsContainer->popLastCutoffForInvertibleAssignments();
    return tryPerformTransformationOfDecisionResultToOperationNodeSimplificationResultWhenNoConflictWasDetected(operationNode->id, decisionResult);
}

inline bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesAssignmentToSignalLeadToConflict(const syrec::VariableAccess& assignedToSignal) const {
    return generatedAssignmentsContainer->existsOverlappingAssignmentFor(assignedToSignal, *symbolTableReference);
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryGetDecisionForOperationNode(std::size_t operationNodeId) const {
    const auto& matchingDecisionForOperationNode = std::find_if(
            pastDecisions.cbegin(),
            pastDecisions.cend(),
            [&operationNodeId](const DecisionReference& pastDecision) {
                return pastDecision->operationNodeId == operationNodeId;
            });
    if (matchingDecisionForOperationNode != pastDecisions.cend()) {
        return *matchingDecisionForOperationNode;
    }
    return std::nullopt;
}


std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryGetOrConstructDefaultDecisionForOperationNode(std::size_t operationNodeId) {
    if (std::optional<DecisionReference> existingReferenceToDecision = tryGetDecisionForOperationNode(operationNodeId); existingReferenceToDecision.has_value()) {
        return existingReferenceToDecision;
    }
    return constructAndRecordDefaultDecision(operationNodeId);
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::isOperationNodeSourceOfConflict(std::size_t operationNodeId) const {
    return operationNodeCausingConflictAndBacktrack.has_value() && *operationNodeCausingConflictAndBacktrack == operationNodeId;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::markOperationNodeAsSourceOfConflict(std::size_t operationNodeId) {
    operationNodeCausingConflictAndBacktrack = operationNodeId;
    logMarkingOfOperationNodeAsSourceOfConflict(operationNodeId);
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::markSourceOfConflictReached() {
    operationNodeCausingConflictAndBacktrack.reset();
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::wereAccessedSignalPartsModifiedByActiveAssignment(const syrec::VariableAccess& accessedSignalParts) const {
    return generatedAssignmentsContainer->existsOverlappingAssignmentFor(accessedSignalParts, *symbolTableReference);
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineEarliestDecisionsOverlappingAccessedSignalPartsOmittingAlreadyRecordedOnes(const syrec::VariableAccess& accessedSignalParts) const {
    DecisionReference earliestDecisionOverlappingAccessedSignalParts;
    /*
     * Since we are looking for the earliest decision (i.e. earliest in the processing order and thus with smaller the operation node is the earlier the decision [when excluding decision where the operand data was inherited from another decision]),
     * a simply traversal of the sorted decision container (sorted ascending by the operation node id) is sufficient.
     */
    for (const DecisionReference& decision : pastDecisions) {
        if (decision->choosenOperand == Decision::ChoosenOperand::None || decision->inheritedOperandDataForChoice) {
            continue;
        }

        const std::optional<ExpressionTraversalHelper::OperationNodeReference>& referenceOperationNode = expressionTraversalHelper->getOperationNodeById(decision->operationNodeId);
        if (!referenceOperationNode.has_value()) {
            continue;
        }

        const std::size_t                    signalAccessOperandId = decision->choosenOperand == Decision::ChoosenOperand::Left ? referenceOperationNode->get()->lhsOperand.id : referenceOperationNode->get()->rhsOperand.id;
        if (const syrec::VariableExpression::ptr expressionHoldingSignalAccessOperandData = expressionTraversalHelper->getOperandAsVariableExpr(signalAccessOperandId).value_or(nullptr); expressionHoldingSignalAccessOperandData) {
            const LearnedConflictsLookupKey key = LearnedConflictsLookupKey(decision->operationNodeId, decision->choosenOperand);
            if (const auto& operandAsSignalAccess = std::dynamic_pointer_cast<syrec::VariableExpression>(expressionHoldingSignalAccessOperandData); operandAsSignalAccess && !learnedConflictsLookup->count(key)) {
                const SignalAccessUtils::SignalAccessEquivalenceResult& equalityResult = SignalAccessUtils::areSignalAccessesEqual(
                        *operandAsSignalAccess->var, accessedSignalParts,
                        SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::DimensionAccess::Overlapping,
                        SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::BitRange::Overlapping,
                        *symbolTableReference);
                if (!(equalityResult.isResultCertain && equalityResult.equality == SignalAccessUtils::SignalAccessEquivalenceResult::NotEqual)) {
                    if (!earliestDecisionOverlappingAccessedSignalParts || decision.get()->operationNodeId <= earliestDecisionOverlappingAccessedSignalParts->operationNodeId) {
                        earliestDecisionOverlappingAccessedSignalParts = decision;
                        break;
                    }
                }
            }
        }
    }
    return earliestDecisionOverlappingAccessedSignalParts ? std::make_optional(earliestDecisionOverlappingAccessedSignalParts) : std::nullopt;
}

/*
 * TODO: Review search for earliest operation node involved in conflict (line 712) with test 'simplifyWithOnlyReversibleOpsButNonUniqueSignalAccessWithAssignOperationBeingAdditionWithDegeneratedLhsSubASTOfLhsOfAssignmentExpr'
 *
 * When another choice along the hot path could be possible, why not choose it instead (if no other choice is possible at the original operation node)
 */
void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleConflict(std::size_t associatedOperationNodeIdOfAccessedSignalPartsOperand, Decision::ChoosenOperand chosenOperandLeadingToDetectionOfConflict, const syrec::VariableAccess& accessedSignalPartsUsedInCheckForConflict) {
    constexpr std::size_t                  earliestPossibleOperationNodeId               = 0;
    const std::optional<DecisionReference> earliestDecisionInvolvedInConflict            = determineEarliestDecisionsOverlappingAccessedSignalPartsOmittingAlreadyRecordedOnes(accessedSignalPartsUsedInCheckForConflict);
    std::size_t                            idOfEarliestOperationNodeIdInvolvedInConflict = earliestPossibleOperationNodeId;

    if (earliestDecisionInvolvedInConflict.has_value()) {
        idOfEarliestOperationNodeIdInvolvedInConflict = earliestDecisionInvolvedInConflict->get()->operationNodeId;
        rememberConflict(earliestDecisionInvolvedInConflict->get()->operationNodeId, earliestDecisionInvolvedInConflict->get()->choosenOperand);
    }

    if (!associatedOperationNodeIdOfAccessedSignalPartsOperand) {
        int x = 0;
    }

    logConflict(associatedOperationNodeIdOfAccessedSignalPartsOperand, chosenOperandLeadingToDetectionOfConflict, accessedSignalPartsUsedInCheckForConflict, idOfEarliestOperationNodeIdInvolvedInConflict);

    std::unordered_set<std::size_t> hotPathFromSourceOfConflictToLocationWhereConflictWasDetected                                 = {};
    const std::size_t idOfEarliestSharedParentOperationNodeBetweenSourceOfConflictAndDetectionOfOriginOperationNode = determineEarliestSharedParentOperationNodeIdBetweenCurrentAndConflictOperationNodeId(idOfEarliestOperationNodeIdInvolvedInConflict, associatedOperationNodeIdOfAccessedSignalPartsOperand, hotPathFromSourceOfConflictToLocationWhereConflictWasDetected);
    markOperationNodeAsSourceOfConflict(idOfEarliestSharedParentOperationNodeBetweenSourceOfConflictAndDetectionOfOriginOperationNode);
    forceReuseOfPreviousDecisionsOnceAtAllDecisionsForChildrenOfNodeButExcludeHotpath(associatedOperationNodeIdOfAccessedSignalPartsOperand, hotPathFromSourceOfConflictToLocationWhereConflictWasDetected, idOfEarliestSharedParentOperationNodeBetweenSourceOfConflictAndDetectionOfOriginOperationNode);
}

/*
* Try to find the first shared operation node by the operation node containing the conflict as well as the operation node for which the conflict was detected. Furthermore, the parent of the found shared parent operation node is returned.
*/
std::size_t noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineEarliestSharedParentOperationNodeIdBetweenCurrentAndConflictOperationNodeId(std::size_t operationNodeIdOfEarliestSourceOfConflict, std::size_t operationNodeIdWhereConflictCheckWasInitiated, std::unordered_set<std::size_t>& hotPathContainerFromSourceToSharedOrigin) const {
    constexpr std::size_t defaultSearchResultOperationNodeId = 0;
    if (!operationNodeIdOfEarliestSourceOfConflict) {
        return defaultSearchResultOperationNodeId;
    }
    std::optional<ExpressionTraversalHelper::OperationNodeReference> operationNodeOfInterest = expressionTraversalHelper->getOperationNodeById(operationNodeIdWhereConflictCheckWasInitiated);
    std::size_t                                                      currParentNodeId        = defaultSearchResultOperationNodeId;

    /*
     * Starting from the operation node where the conflict check was initiated, we traverse the operation node structure in reverse order until we reach the first operation node with an id smaller than the one in which
     * the source of the conflict was.
     */
    while (operationNodeOfInterest.has_value() && operationNodeOfInterest->get()->id) {
        currParentNodeId = operationNodeOfInterest->get()->id;
        if (currParentNodeId < operationNodeIdOfEarliestSourceOfConflict) {
            operationNodeOfInterest.reset();
        }
        else {
            // Since any generated operation node id is >= 1 we can assume that the lookup for an operation node with id 0 does not return any matching result
            operationNodeOfInterest = expressionTraversalHelper->getOperationNodeById(operationNodeOfInterest->get()->parentNodeId.value_or(defaultSearchResultOperationNodeId));
        }
    }

    /*
     * We can now determine the hot path by traversing the operation node structure in reverse starting from the operation node where the source of the conflict was located back to the found shared parent node.
     */
    std::size_t currOperationNodeIdForTraversalFromSourceOfConflictToSharedParent = operationNodeIdOfEarliestSourceOfConflict;
    operationNodeOfInterest                                                       = expressionTraversalHelper->getOperationNodeById(operationNodeIdOfEarliestSourceOfConflict);
    while (operationNodeOfInterest.has_value() && operationNodeOfInterest->get()->id) {
        currOperationNodeIdForTraversalFromSourceOfConflictToSharedParent = operationNodeOfInterest->get()->id;
        if (currOperationNodeIdForTraversalFromSourceOfConflictToSharedParent == currParentNodeId) {
            return currParentNodeId;
        }
        hotPathContainerFromSourceToSharedOrigin.emplace(currOperationNodeIdForTraversalFromSourceOfConflictToSharedParent);    
        operationNodeOfInterest = expressionTraversalHelper->getOperationNodeById(operationNodeOfInterest->get()->parentNodeId.value_or(defaultSearchResultOperationNodeId));
    }
    return defaultSearchResultOperationNodeId;
}

/*
 * TODO: Think this through more thorougly with the help of the test case conflictInOperationNodeWithOneLeafNodeWhereLeafIsRhsOperandNotResolvableByOtherChoiceInLhsOperandThatGeneratedAssignmentCreatesExprInstead
 */
void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::forceReuseOfPreviousDecisionsOnceAtAllDecisionsForChildrenOfNodeButExcludeHotpath(std::size_t idOfOperationNodeWhereConflictWasDetected, const std::unordered_set<std::size_t>& idOfOperationNodesOnHotPath, std::size_t idOfSharedParentOperationNode) const {
    std::size_t upperBoundOfSearchSpace = SIZE_MAX;
    if (idOfOperationNodeWhereConflictWasDetected) {
        std::optional<ExpressionTraversalHelper::OperationNodeReference> traversalNodeToFindRightmostNode = expressionTraversalHelper->getOperationNodeById(idOfOperationNodeWhereConflictWasDetected);
        while (traversalNodeToFindRightmostNode.has_value()) {
            if (traversalNodeToFindRightmostNode->get()->rhsOperand.isLeafNode()) {
                upperBoundOfSearchSpace = traversalNodeToFindRightmostNode->get()->id;
                traversalNodeToFindRightmostNode.reset();
            } else {
                traversalNodeToFindRightmostNode = expressionTraversalHelper->getOperationNodeById(*traversalNodeToFindRightmostNode->get()->rhsOperand.operationNodeId);
            }
        }   
    }
    const auto& firstPastDecisionToReuse = idOfSharedParentOperationNode
        ? std::find_if(pastDecisions.crbegin(), pastDecisions.crend(), [idOfSharedParentOperationNode](const DecisionReference& pastDecision) { return pastDecision->operationNodeId == idOfSharedParentOperationNode; })
        : pastDecisions.crend();

    const auto& lastPastDecisionToReuse = upperBoundOfSearchSpace != SIZE_MAX
        ? std::find_if(pastDecisions.crbegin(), pastDecisions.crend(), [upperBoundOfSearchSpace](const DecisionReference& pastDecision) { return pastDecision->operationNodeId == upperBoundOfSearchSpace; })
        : pastDecisions.crbegin();

    const std::size_t numDecisionsToReuse = pastDecisions.size() - std::distance(firstPastDecisionToReuse, lastPastDecisionToReuse);

    auto pastDecisionToReuseIterator = pastDecisions.begin();
    for (std::size_t i = 0; i < numDecisionsToReuse; ++i) {
        if (pastDecisionToReuseIterator->get()->shouldChoiceBeRepeated != Decision::ChoiceRepetition::Always && !idOfOperationNodesOnHotPath.count(pastDecisionToReuseIterator->get()->operationNodeId)
            && pastDecisionToReuseIterator->get()->choosenOperand != Decision::ChoosenOperand::None) {
            pastDecisionToReuseIterator->get()->shouldChoiceBeRepeated = Decision::ChoiceRepetition::UntilReset;
        }
        ++pastDecisionToReuseIterator;
    }
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::shouldBacktrackDueToConflict() const {
    return operationNodeCausingConflictAndBacktrack.has_value();
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::considerExpressionInFutureDecisions(const syrec::Expression::ptr& expr) const {
    if (temporaryExpressionsContainer && expr) {
        temporaryExpressionsContainer->activateExpression(expr);
    }
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::revokeConsiderationOfExpressionForFutureDecisions(const syrec::Expression::ptr& expr) const {
    if (temporaryExpressionsContainer && expr) {
        temporaryExpressionsContainer->deactivateExpression(expr);   
    }
}

std::vector<syrec::VariableAccess::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::defineNotUsableReplacementCandidatesFromAssignmentForGenerator(const syrec::AssignStatement& assignment) const {
    if (substitutionGenerator) {
        std::vector<syrec::VariableAccess::ptr> notUsableReplacementCandidatesForSubstitutionGenerator = determineSignalPartsNotUsableAsPotentialReplacementCandidates(*assignment.rhs, *symbolTableReference);
        notUsableReplacementCandidatesForSubstitutionGenerator.emplace_back(assignment.lhs);
        substitutionGenerator->updateRestrictions(notUsableReplacementCandidatesForSubstitutionGenerator, ExpressionSubstitutionGenerator::RestrictionLifetime::Temporary, ExpressionSubstitutionGenerator::RestrictionUpdate::Activation);
        return notUsableReplacementCandidatesForSubstitutionGenerator;
    }
    return {};
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::clearNotUsableReplacementCandidatesFromAssignmentForGenerator(const std::vector<syrec::VariableAccess::ptr>& replacementCandidateRestrictionsStemmingFromAssignment) const {
    if (substitutionGenerator) {
        substitutionGenerator->updateRestrictions(replacementCandidateRestrictionsStemmingFromAssignment, ExpressionSubstitutionGenerator::RestrictionLifetime::Temporary, ExpressionSubstitutionGenerator::Deactivation);
    }
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::isChoiceOfSignalAccessBlockedByAnyActiveExpression(const syrec::VariableAccess& chosenOperand) const {
    return temporaryExpressionsContainer && temporaryExpressionsContainer->existsAnyExpressionDefiningOverlappingSignalAccess(chosenOperand).value_or(true);
}

std::optional<syrec::VariableAccess::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::createReplacementForChosenOperand(const DecisionReference& decisionToReplace, const SignalValueLookupCallback& callbackForValueLookupOfExistingSymbolTableSignals) const {
    if (!determinedBitWidthOfAssignmentToSimplify.has_value() || !substitutionGenerator || !decisionToReplace || decisionToReplace->choosenOperand == Decision::ChoosenOperand::None) {
        return std::nullopt;
    }

    const std::optional<ExpressionTraversalHelper::OperationNodeReference> referencedOperationNode = expressionTraversalHelper->getOperationNodeById(decisionToReplace->operationNodeId);
    if (!referencedOperationNode.has_value() || !referencedOperationNode->get()->hasAnyLeafOperandNodes()) {
        return std::nullopt;
    }

    const std::optional<ExpressionSubstitutionGenerator::ReplacementResult> generatedReplacement = substitutionGenerator->generateReplacementFor(*determinedBitWidthOfAssignmentToSimplify, callbackForValueLookupOfExistingSymbolTableSignals);
    if (!generatedReplacement.has_value()) {
        return std::nullopt;
    }

    /*
     * Since a newly generated replacement signal will always have the initial value of 0 (assuming our replacement is generated as a local signal) thus the XOR assignment operation is sufficient to create the required substitution for the operand of the operation node.
     */
    const std::optional<unsigned int>           mappedToAssignmentOperation            = syrec_operation::tryMapAssignmentOperationEnumToFlag(syrec_operation::operation::XorAssign);
    const std::size_t                           idOfToBeReplacedOperandInOperationNode = decisionToReplace->choosenOperand == Decision::ChoosenOperand::Left ? referencedOperationNode->get()->lhsOperand.id : referencedOperationNode->get()->rhsOperand.id;
    const std::optional<syrec::Expression::ptr> generatedSubstitutionAssignmentRhsExpr = expressionTraversalHelper->getOperandAsVariableExpr(idOfToBeReplacedOperandInOperationNode);
    if (!mappedToAssignmentOperation.has_value() || !generatedSubstitutionAssignmentRhsExpr.has_value()) {
        return std::nullopt;
    }
    
    const syrec::VariableExpression::ptr generatedContainerForReplacementExpr = mappedToAssignmentOperation.has_value() ? std::make_shared<syrec::VariableExpression>(generatedReplacement->foundReplacement) : nullptr;
    const syrec::AssignStatement::ptr    generatedSubstitutionAssignment      = generatedContainerForReplacementExpr ? std::make_shared<syrec::AssignStatement>(generatedReplacement->foundReplacement, *mappedToAssignmentOperation, *generatedSubstitutionAssignmentRhsExpr) : nullptr;
    if (!generatedSubstitutionAssignment || !expressionTraversalHelper->updateOperandData(referencedOperationNode->get()->id, decisionToReplace->choosenOperand == Decision::ChoosenOperand::Left, generatedContainerForReplacementExpr)) {
        return std::nullopt;
    }
    if (generatedAssignmentsContainer->storeInitializationForReplacementOfLeafNode(generatedSubstitutionAssignment, generatedReplacement->requiredResetOfReplacement)) {
        return generatedReplacement->foundReplacement;
    }
    return std::nullopt;
}

std::optional<syrec::VariableAccess::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::createReplacementForLeafNodeOperand(std::size_t operationNodeId, Decision::ChoosenOperand chosenOperandToBeReplaced, const syrec::Expression::ptr& leafNodeDataToReplace, const SignalValueLookupCallback& callbackForValueLookupOfExistingSymbolTableSignals) const {
    if (!substitutionGenerator || !determinedBitWidthOfAssignmentToSimplify.has_value() || !expressionTraversalHelper->getOperationNodeById(operationNodeId).has_value() || chosenOperandToBeReplaced == Decision::ChoosenOperand::None || !leafNodeDataToReplace) {
        return std::nullopt;
    }

    if (const auto& leafNodeDataExprAsNumericOne = std::dynamic_pointer_cast<syrec::NumericExpression>(leafNodeDataToReplace); leafNodeDataExprAsNumericOne) {
        if (leafNodeDataExprAsNumericOne->value->isCompileTimeConstantExpression()) {
            return std::nullopt;
        }
    }
    else if(!std::dynamic_pointer_cast<syrec::VariableExpression>(leafNodeDataToReplace)) {
        return std::nullopt;
    }

    const std::optional<unsigned int>                                       mappedToFlagValueForAssignmentEnumValue = syrec_operation::tryMapAssignmentOperationEnumToFlag(syrec_operation::operation::XorAssign);
    const std::optional<ExpressionSubstitutionGenerator::ReplacementResult> generatedReplacement = mappedToFlagValueForAssignmentEnumValue.has_value() ? substitutionGenerator->generateReplacementFor(*determinedBitWidthOfAssignmentToSimplify, callbackForValueLookupOfExistingSymbolTableSignals) : std::nullopt;
    if (!generatedReplacement.has_value()) {
        return std::nullopt;
    }

    // TODO: We could probably change the return value to indicate that the replacement of the operand data in the expression traversal helper failed and since this could leave said object in an undefined state (or invalid any previous data)
    // stop further processing of the assignment
    if (const syrec::VariableExpression::ptr containerForUpdatedLeafOperandData = std::make_shared<syrec::VariableExpression>(generatedReplacement->foundReplacement); containerForUpdatedLeafOperandData) {
        if (const std::shared_ptr<syrec::AssignStatement>& generatedAssignmentDefiningOperandReplacement = std::make_shared<syrec::AssignStatement>(generatedReplacement->foundReplacement, *mappedToFlagValueForAssignmentEnumValue, leafNodeDataToReplace); generatedAssignmentDefiningOperandReplacement) {
            if (generatedAssignmentsContainer->storeInitializationForReplacementOfLeafNode(generatedAssignmentDefiningOperandReplacement, generatedReplacement->requiredResetOfReplacement) 
                && expressionTraversalHelper->updateOperandData(operationNodeId, chosenOperandToBeReplaced == Decision::ChoosenOperand::Left, containerForUpdatedLeafOperandData)) {
                logCreationOfSubstitutionOfOperandOfOperationNode(operationNodeId, chosenOperandToBeReplaced, *generatedReplacement->foundReplacement);
                return generatedReplacement->foundReplacement;
            }
        }
    }
    return std::nullopt;
}


std::optional<std::pair<std::size_t, std::shared_ptr<syrec::AssignStatement>>> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::getAndActivateReplacementForOperationNode(std::size_t referencedOperationNodeId, syrec_operation::operation definedOperationInOperationNode, const OperationNodeSimplificationResult& lhsOperandDataChoicesAfterSimplification, const OperationNodeSimplificationResult& rhsOperandDataChoicesAfterSimplification, bool* wasExistingReplacementForOperationNodeEntryUpdated, const SignalValueLookupCallback& callbackForValueLookupOfExistingSymbolTableSignals) {
    if (!determinedBitWidthOfAssignmentToSimplify.has_value() || !substitutionGenerator || !expressionTraversalHelper->getOperationNodeById(referencedOperationNodeId).has_value()) {
        return std::nullopt;
    }
    
    const std::vector<std::size_t> dataDependenciesAsIdsOfDependentAssignmentsOfLhsOperand = (lhsOperandDataChoicesAfterSimplification.getResultAsSignalAccess().has_value() && !lhsOperandDataChoicesAfterSimplification.wasResultManuallyCreated()) ? std::vector(1, lhsOperandDataChoicesAfterSimplification.getIdOfGeneratedAssignment().value()) : lhsOperandDataChoicesAfterSimplification.getDataDependenciesAsIdsOfDependentAssignments();
    const std::vector<std::size_t> dataDependenciesAsIdsOfDependentAssignmentsOfRhsOperand = (rhsOperandDataChoicesAfterSimplification.getResultAsSignalAccess().has_value() && !rhsOperandDataChoicesAfterSimplification.wasResultManuallyCreated()) ? std::vector(1, rhsOperandDataChoicesAfterSimplification.getIdOfGeneratedAssignment().value()) : rhsOperandDataChoicesAfterSimplification.getDataDependenciesAsIdsOfDependentAssignments();
    if (wholeExpressionOfOperationNodeReplacementLookup.count(referencedOperationNodeId)) {
        /*
         * If the operands of the already existing assignment did not change, simply reuse said assignment again. Otherwise, update the operands. The operation of the rhs expression of the assignments should not change thus the type of the expression should also not change.
         */
        const std::shared_ptr<syrec::AssignStatement> existingReplacementForOperationNode = std::dynamic_pointer_cast<syrec::AssignStatement>(wholeExpressionOfOperationNodeReplacementLookup.at(referencedOperationNodeId));
        if (!existingReplacementForOperationNode) {
            wholeExpressionOfOperationNodeReplacementLookup.erase(referencedOperationNodeId);
            return std::nullopt;
        }

        std::optional<bool> didOperandsOfExistingAssignmentChange;
        if (const std::shared_ptr<syrec::BinaryExpression> existingAssignmentRhsExprAsBinaryExpr = std::dynamic_pointer_cast<syrec::BinaryExpression>(existingReplacementForOperationNode->rhs); existingAssignmentRhsExprAsBinaryExpr) {
            didOperandsOfExistingAssignmentChange = tryUpdateOperandsOfExistingReplacementForWholeBinaryExpressionIfChangedAndReturnWhetherUpdateTookPlace(*existingAssignmentRhsExprAsBinaryExpr, lhsOperandDataChoicesAfterSimplification, rhsOperandDataChoicesAfterSimplification);
        } else if (const std::shared_ptr<syrec::ShiftExpression> existingAssignmentRhsExprAsShiftExpr =  std::dynamic_pointer_cast<syrec::ShiftExpression>(existingReplacementForOperationNode->rhs); existingAssignmentRhsExprAsShiftExpr) {
            didOperandsOfExistingAssignmentChange = tryUpdateOperandsOfExistingReplacementForWholeShiftExpressionIfChangedAndReturnWhetherUpdateTookPlace(*existingAssignmentRhsExprAsShiftExpr, lhsOperandDataChoicesAfterSimplification, rhsOperandDataChoicesAfterSimplification);
        }

        if (!didOperandsOfExistingAssignmentChange.has_value()) {
            wholeExpressionOfOperationNodeReplacementLookup.erase(referencedOperationNodeId);
            return std::nullopt;
        }

        if (wasExistingReplacementForOperationNodeEntryUpdated) {
            *wasExistingReplacementForOperationNodeEntryUpdated = *didOperandsOfExistingAssignmentChange;
        }
        
        TemporaryAssignmentsContainer::OrderedAssignmentIdContainer fusedDataDependencies;
        fusedDataDependencies.insert(dataDependenciesAsIdsOfDependentAssignmentsOfLhsOperand.cbegin(), dataDependenciesAsIdsOfDependentAssignmentsOfLhsOperand.cend());
        fusedDataDependencies.insert(dataDependenciesAsIdsOfDependentAssignmentsOfRhsOperand.cbegin(), dataDependenciesAsIdsOfDependentAssignmentsOfRhsOperand.cend());

        if (const std::optional<std::size_t>& idOfGeneratedAssignment = generatedAssignmentsContainer->storeActiveAssignment(existingReplacementForOperationNode, std::nullopt, fusedDataDependencies, referencedOperationNodeId, std::nullopt); idOfGeneratedAssignment.has_value()) {
            return std::make_pair(*idOfGeneratedAssignment, existingReplacementForOperationNode);    
        }
        return std::nullopt;
    }

    const std::optional<syrec::Expression::ptr> fusedExpressionFromOperands = tryCreateExpressionFromOperationNodeOperandSimplifications(lhsOperandDataChoicesAfterSimplification, definedOperationInOperationNode, rhsOperandDataChoicesAfterSimplification);
    if (!fusedExpressionFromOperands.has_value()) {
        return std::nullopt;
    }

    const std::optional<unsigned int>                                       mappedToFlagForAssignmentEnumValue = syrec_operation::tryMapAssignmentOperationEnumToFlag(syrec_operation::operation::XorAssign);
    const std::optional<ExpressionSubstitutionGenerator::ReplacementResult> generatedReplacement               = mappedToFlagForAssignmentEnumValue.has_value() ? substitutionGenerator->generateReplacementFor(*determinedBitWidthOfAssignmentToSimplify, callbackForValueLookupOfExistingSymbolTableSignals) : std::nullopt;
    if (!generatedReplacement.has_value()) {
        return std::nullopt;
    }

    if (const std::shared_ptr<syrec::AssignStatement> assignmentFusingReplacementAndExpression = std::make_shared<syrec::AssignStatement>(generatedReplacement->foundReplacement, *mappedToFlagForAssignmentEnumValue, *fusedExpressionFromOperands); assignmentFusingReplacementAndExpression) {
        wholeExpressionOfOperationNodeReplacementLookup.insert(std::make_pair(referencedOperationNodeId, assignmentFusingReplacementAndExpression));
        /*
         * Since the operands of the generated assignment, fusing the generated replacement with the expression defining the substitution, rhs expression could potentially change, we need to store said assignment as an active assignment.
         * The optional reset of the replacement can be executed prior to any active assignment and will be stored accordingly in the generated assignment container.
         */
        TemporaryAssignmentsContainer::OrderedAssignmentIdContainer fusedDataDependencies;
        fusedDataDependencies.insert(dataDependenciesAsIdsOfDependentAssignmentsOfLhsOperand.cbegin(), dataDependenciesAsIdsOfDependentAssignmentsOfLhsOperand.cend());
        fusedDataDependencies.insert(dataDependenciesAsIdsOfDependentAssignmentsOfRhsOperand.cbegin(), dataDependenciesAsIdsOfDependentAssignmentsOfRhsOperand.cend());

        if (const std::optional<std::size_t>& idOfGeneratedAssignment = generatedAssignmentsContainer->storeReplacementAsActiveAssignment(referencedOperationNodeId, assignmentFusingReplacementAndExpression, fusedDataDependencies, generatedReplacement->requiredResetOfReplacement); idOfGeneratedAssignment.has_value()) {
            return std::make_pair(*idOfGeneratedAssignment, assignmentFusingReplacementAndExpression);    
        }
    }
    return std::nullopt;
}

std::optional<bool> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryUpdateOperandsOfExistingReplacementForWholeBinaryExpressionIfChangedAndReturnWhetherUpdateTookPlace(syrec::BinaryExpression& replacementRhsAsBinaryExpr, const OperationNodeSimplificationResult& potentiallyNewLhsOperandOfBinaryExpr, const OperationNodeSimplificationResult& potentiallyNewRhsOperandOfBinaryExpr) {
    bool didAnyOperandChange = false;
    if (!doesOperandSimplificationResultMatchExpression(potentiallyNewLhsOperandOfBinaryExpr, replacementRhsAsBinaryExpr.lhs)) {
        if (const std::optional<syrec::Expression::ptr> newLhsOperandOfBinaryExpr = tryCreateExpressionFromOperationNodeOperandSimplification(potentiallyNewLhsOperandOfBinaryExpr); newLhsOperandOfBinaryExpr.has_value()) {
            replacementRhsAsBinaryExpr.lhs = *newLhsOperandOfBinaryExpr;
            didAnyOperandChange            = true;
        }
        else {
            return std::nullopt;
        }
    }
    if (!doesOperandSimplificationResultMatchExpression(potentiallyNewRhsOperandOfBinaryExpr, replacementRhsAsBinaryExpr.rhs)) {
        if (const std::optional<syrec::Expression::ptr> newRhsOperandOfBinaryExpr = tryCreateExpressionFromOperationNodeOperandSimplification(potentiallyNewRhsOperandOfBinaryExpr); newRhsOperandOfBinaryExpr.has_value()) {
            replacementRhsAsBinaryExpr.rhs = *newRhsOperandOfBinaryExpr;
            didAnyOperandChange            = true;
        } else {
            return std::nullopt;
        }
    }
    return didAnyOperandChange;
}

std::optional<bool> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryUpdateOperandsOfExistingReplacementForWholeShiftExpressionIfChangedAndReturnWhetherUpdateTookPlace(syrec::ShiftExpression& replacementRhsAsShiftExpr, const OperationNodeSimplificationResult& potentiallyNewLhsOperandOfShiftExpr, const OperationNodeSimplificationResult& potentiallyNewRhsOperandOfShiftExpr) {
    bool didAnyOperandChange = false;
    if (!doesOperandSimplificationResultMatchExpression(potentiallyNewLhsOperandOfShiftExpr, replacementRhsAsShiftExpr.lhs)) {
        if (const std::optional<syrec::Expression::ptr> newLhsOperandOfBinaryExpr = tryCreateExpressionFromOperationNodeOperandSimplification(potentiallyNewLhsOperandOfShiftExpr); newLhsOperandOfBinaryExpr.has_value()) {
            replacementRhsAsShiftExpr.lhs = *newLhsOperandOfBinaryExpr;
            didAnyOperandChange           = true;
        } else {
            return std::nullopt;
        }
    }
    if (!doesOperandSimplificationResultMatchNumber(potentiallyNewRhsOperandOfShiftExpr, replacementRhsAsShiftExpr.rhs)) {
        if (const std::optional<syrec::Number::ptr> newRhsOperandOfBinaryExpr = tryCreateNumberFromOperationNodeOperandSimplification(potentiallyNewRhsOperandOfShiftExpr); newRhsOperandOfBinaryExpr.has_value()) {
            replacementRhsAsShiftExpr.rhs = *newRhsOperandOfBinaryExpr;
            didAnyOperandChange           = true;
        } else {
            return std::nullopt;
        }
    }
    return didAnyOperandChange;
}

// TODO: can probably be removed
bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::couldAnotherChoiceBeMadeAtPreviousDecision(const std::optional<std::size_t>& pastDecisionForOperationNodeWithIdToExclude) const {
    if (pastDecisions.empty()) {
        return false;
    }

    std::size_t lastDecisionOffset = 0;
    if (pastDecisionForOperationNodeWithIdToExclude.has_value() && *pastDecisionForOperationNodeWithIdToExclude == std::prev(pastDecisions.cend())->get()->operationNodeId) {
        ++lastDecisionOffset;
    }

    if (lastDecisionOffset >= pastDecisions.size()) {
        return false;
    }

    return std::any_of(
        std::next(pastDecisions.crbegin(), lastDecisionOffset + 1),
        pastDecisions.crend(),
        [&](const DecisionReference& pastDecision) {
                if (const auto& matchingAssignmentOperationForOperation = syrec_operation::getMatchingAssignmentOperationForOperation(*expressionTraversalHelper->getOperationOfOperationNode(pastDecision->operationNodeId)); matchingAssignmentOperationForOperation.has_value()) {
                    return pastDecision->choosenOperand == Decision::ChoosenOperand::Left && syrec_operation::isCommutative(*expressionTraversalHelper->getOperationOfOperationNode(pastDecision->operationNodeId));
                }
                return false;
            });
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::removeDecisionFor(std::size_t operationNodeId) {
    const auto& matchingDecisionForOperationNode = std::find_if(
        pastDecisions.cbegin(),
        pastDecisions.cend(),
        [&operationNodeId](const DecisionReference& decisionReference) {
            return decisionReference->operationNodeId == operationNodeId;
        });

    if (matchingDecisionForOperationNode != pastDecisions.cend()) {
        pastDecisions.erase(matchingDecisionForOperationNode);
    }
}

inline std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryGetLastDecision() const {
    if (pastDecisions.empty()) {
        return std::nullopt;
    }
    return *pastDecisions.begin();
}

inline std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryGetSecondToLastDecision() const {
    if (pastDecisions.size() < 2) {
        return std::nullopt;
    }
    return *std::next(pastDecisions.begin());
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::resetInternals() {
    pastDecisions.clear();
    generatedAssignmentsContainer->resetInternals();
    temporaryExpressionsContainer->resetInternals();
    expressionTraversalHelper->resetInternals();
    if (substitutionGenerator) {
        substitutionGenerator->resetInternals(false);
    }
    determinedBitWidthOfAssignmentToSimplify.reset();
    wholeExpressionOfOperationNodeReplacementLookup.clear();
    topmostAssignmentOperation.reset();
    enabledValueLookup();
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::defineSymbolTable(const parser::SymbolTable::ptr& activeSymbolTableScope) {
    symbolTableReference = activeSymbolTableScope;
    temporaryExpressionsContainer->defineSymbolTable(symbolTableReference);
    if (substitutionGenerator) {
        substitutionGenerator->defineSymbolTable(symbolTableReference);
    }
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::reloadGenerateableReplacementSignalName() {
    if (substitutionGenerator) {
        substitutionGenerator->loadLastNewlyGeneratedReplacementSignalInformation();
    }
}

std::unique_ptr<syrec::AssignStatement> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::transformAssignmentPriorToSimplification(const syrec::AssignStatement& assignmentToSimplify, bool applyHeuristicsForSubassignmentGeneration) const {
    if (std::unique_ptr<syrec::AssignStatement> owningCopyOfAssignmentStmt = copyUtils::createDeepCopyOfAssignmentStmt(assignmentToSimplify); owningCopyOfAssignmentStmt) {
        // TODO: Only for testing
        return owningCopyOfAssignmentStmt;

        tryConvertNumericToBinaryExpr(owningCopyOfAssignmentStmt->rhs);
        if (!doesExpressionDefineNestedSplitableExpr(*owningCopyOfAssignmentStmt->rhs)) {
            return nullptr;
        }

        /*
         * Try to convert an assignment of the form a -= (<lhsExpr> - <rhsExpr>) to a += (<rhsExpr> - <lhsExpr>) if the <lhsExpr> is a nested expression, to enable the optimization of converting an assignment of the form:
         * a += ... to a ^= 0 if the symbol table entry for the assigned to signal has the value 0
         */
        if (const auto& assignmentRhsExprAsBinaryExpr = std::dynamic_pointer_cast<syrec::BinaryExpression>(owningCopyOfAssignmentStmt->rhs); assignmentRhsExprAsBinaryExpr) {
            const std::optional<syrec_operation::operation> mappedToAssignmentOperationEnumFromFlag = syrec_operation::tryMapAssignmentOperationFlagToEnum(owningCopyOfAssignmentStmt->op);
            const std::optional<syrec_operation::operation> mappedToBinaryOperationEnumFromFlag     = syrec_operation::tryMapBinaryOperationFlagToEnum(assignmentRhsExprAsBinaryExpr->op);
            if (mappedToAssignmentOperationEnumFromFlag.has_value() && *mappedToAssignmentOperationEnumFromFlag == syrec_operation::operation::MinusAssign
                && mappedToBinaryOperationEnumFromFlag.has_value() && *mappedToBinaryOperationEnumFromFlag == syrec_operation::operation::Subtraction) {
                owningCopyOfAssignmentStmt->op                   = *syrec_operation::tryMapAssignmentOperationEnumToFlag(syrec_operation::operation::AddAssign);
                const syrec::Expression::ptr copyOfBinaryExprLhs = assignmentRhsExprAsBinaryExpr->lhs;
                assignmentRhsExprAsBinaryExpr->lhs               = assignmentRhsExprAsBinaryExpr->rhs;
                assignmentRhsExprAsBinaryExpr->rhs               = copyOfBinaryExprLhs;   
            }
        }
        transformExpressionPriorToSimplification(*owningCopyOfAssignmentStmt->rhs, applyHeuristicsForSubassignmentGeneration);
        return owningCopyOfAssignmentStmt;
    }
    return nullptr;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::transformExpressionPriorToSimplification(syrec::Expression& expr, bool applyHeuristicsForSubassignmentGeneration) const {
    if (auto* exprAsBinaryExpr = dynamic_cast<syrec::BinaryExpression*>(&expr); exprAsBinaryExpr) {
        tryConvertNumericToBinaryExpr(exprAsBinaryExpr->lhs);
        tryConvertNumericToBinaryExpr(exprAsBinaryExpr->rhs);
        transformExpressionPriorToSimplification(*exprAsBinaryExpr->lhs, applyHeuristicsForSubassignmentGeneration);

        const bool doesLhsOperandDefineNestedEpxr = doesExpressionDefineNestedSplitableExpr(*exprAsBinaryExpr->lhs);
        const std::optional<syrec_operation::operation> mappedToOperationOfParentExpr  = syrec_operation::tryMapBinaryOperationFlagToEnum(exprAsBinaryExpr->op);

        /*
         * Try to transform a binary expression of the form (<number> op <signalAccess>) to (<signalAccess> op <number>) if the defined operation is commutative, has a matching assignment operation and the defined signal access accesses a modifiable signal.
         */
        if (applyHeuristicsForSubassignmentGeneration && mappedToOperationOfParentExpr.has_value() && syrec_operation::isCommutative(*mappedToOperationOfParentExpr) && syrec_operation::getMatchingAssignmentOperationForOperation(*mappedToOperationOfParentExpr).has_value()
            && (doesExpressionDefineNumber(*exprAsBinaryExpr->lhs) || doesLhsOperandDefineNestedEpxr) && doesExprDefineSignalAccess(*exprAsBinaryExpr->rhs)) {
            const auto& rhsOperandAsSignalAccess = std::dynamic_pointer_cast<const syrec::VariableExpression>(exprAsBinaryExpr->rhs);
            if (rhsOperandAsSignalAccess && isAccessedSignalAssignable(rhsOperandAsSignalAccess->var->var->name)) {
                exprAsBinaryExpr->lhs.swap(exprAsBinaryExpr->rhs);
            }
        }

        if (const std::shared_ptr<syrec::BinaryExpression> rhsExprAsBinaryExpr = std::dynamic_pointer_cast<syrec::BinaryExpression>(exprAsBinaryExpr->rhs); rhsExprAsBinaryExpr) {
            const std::optional<syrec_operation::operation> mappedToOperationOfRhsExpr    = syrec_operation::tryMapBinaryOperationFlagToEnum(rhsExprAsBinaryExpr->op);

            /*
             * Try to transform an expression of the form (a - (b - c)) to (a + (c - b)) only if b is not a signal access. The latter condition is heuristic as the transformation could prevent the creation of an assignment
             * of the form b -= c.
             */
            if (applyHeuristicsForSubassignmentGeneration && mappedToOperationOfParentExpr.has_value() && mappedToOperationOfRhsExpr.has_value() && *mappedToOperationOfRhsExpr == syrec_operation::operation::Subtraction) {
                if (*mappedToOperationOfParentExpr == syrec_operation::operation::Subtraction) {
                /*
                 * TODO: Could a similar transformation take place during the processing of the operation nodes (i.e. when the constellation or something similar (<sigAcc_1> - (<subExpr_1> - <sigAcc_2>)) is encountered?
                 * Try to convert an expression of the form (<subExpr_1> - (<subExpr_2> - <subExpr_3>)) to (<subExpr_1> + (<subExpr_3> - <subExpr_2)).
                 * We do not apply this transformation if <subExpr_2> defines a signal access while <subExpr_3> defines a nested expressions as this could prevent the generation of the assignment <subExpr_2> -= <subExpr_3>.
                 * NOTE: We try to not prevent any future assignments by this transformation, but could implicitly block some by our transformation due to a conflict later during preprocessing.
                 */
                    if (!doesExprDefineSignalAccess(*rhsExprAsBinaryExpr->lhs) || doesExprDefineSignalAccess(*rhsExprAsBinaryExpr->rhs)) {
                        exprAsBinaryExpr->op                    = *syrec_operation::tryMapBinaryOperationEnumToFlag(syrec_operation::operation::Addition);
                        const auto backupOfNestedExprLhsOperand = rhsExprAsBinaryExpr->lhs;
                        rhsExprAsBinaryExpr->lhs                = rhsExprAsBinaryExpr->rhs;
                        rhsExprAsBinaryExpr->rhs                = backupOfNestedExprLhsOperand;
                    }
                /*
                 * TODO: Add tests for this behaviour and could this transformation also be done during the processing of the operation nodes itself ?
                 * Try to convert an expression of the form (<subExpr_1> + (<subExpr_with_op_without_assignmentCounterPart> - <assignableSignalAccess>) to (<subExpr_1> - (<assignableSignalAccess> - <subExpr_with_op_without_assignmentCounterPart>)
                 * where the subexpression that defines an operation without assignment counterpart can also be either a number of a readonly signal access.
                 *
                 * Apply the same transformation if the rhs operand defines an expression with an operation that has an assignment counterpart.
                 * E.g.: (<subExpr_1> + (<notSplitableExprNumberOrReadonlySignalAccess> - <splitableExpr>)) to (<subExpr_1> - (<splitableExpr> - <notSplitableExprNumberOfReadonlySignalAccess>))
                 */
                } else if (*mappedToOperationOfParentExpr == syrec_operation::operation::Addition) {
                    const auto& rhsOperandAsSignalAccess = std::dynamic_pointer_cast<const syrec::VariableExpression>(rhsExprAsBinaryExpr->rhs);
                    const auto& lhsOperandAsSignalAccess                   = std::dynamic_pointer_cast<const syrec::VariableExpression>(rhsExprAsBinaryExpr->lhs);
                    const bool  doesLhsOperandDefineAssignableSignalAccess = lhsOperandAsSignalAccess && isAccessedSignalAssignable(lhsOperandAsSignalAccess->var->var->name);

                    if ((!doesExpressionDefineNestedSplitableExpr(*rhsExprAsBinaryExpr->lhs) && rhsOperandAsSignalAccess && isAccessedSignalAssignable(rhsOperandAsSignalAccess->var->var->name)) 
                        || (!doesLhsOperandDefineAssignableSignalAccess && doesExpressionDefineNestedSplitableExpr(*rhsExprAsBinaryExpr->lhs))) {
                        if (!doesLhsOperandDefineAssignableSignalAccess) {
                            rhsExprAsBinaryExpr->lhs.swap(rhsExprAsBinaryExpr->rhs);
                            exprAsBinaryExpr->op = *syrec_operation::tryMapBinaryOperationEnumToFlag(syrec_operation::operation::Subtraction);
                        }
                    }
                }
            }  
        }
        transformExpressionPriorToSimplification(*exprAsBinaryExpr->rhs, applyHeuristicsForSubassignmentGeneration);
    } else if (auto* exprAsShiftExpr = dynamic_cast<syrec::ShiftExpression*>(&expr); exprAsShiftExpr) {
        tryConvertNumericToBinaryExpr(exprAsShiftExpr->lhs);
        transformExpressionPriorToSimplification(*exprAsShiftExpr->lhs, applyHeuristicsForSubassignmentGeneration);
        // TODO: Simplification of number
    }
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::rememberConflict(std::size_t operationNodeId, Decision::ChoosenOperand chosenOperandAtOperationNode) const {
    const LearnedConflictsLookupKey lookupKey = LearnedConflictsLookupKey(operationNodeId, chosenOperandAtOperationNode);
    learnedConflictsLookup->emplace(lookupKey);
    logLearnedConflict(operationNodeId, chosenOperandAtOperationNode);
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::didPreviousDecisionMatchingChoiceCauseConflict(const LearnedConflictsLookupKey& lookupKeyRepresentingSearchedForPreviousDecision) const {
    return learnedConflictsLookup->count(lookupKeyRepresentingSearchedForPreviousDecision);
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::disableValueLookup() {
    disabledValueLookupToggle = true;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::enabledValueLookup() {
    disabledValueLookupToggle = false;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::backtrack(std::size_t operationNodeIdAtOriginOfBacktrack, bool onlyUpToOperationNode) const {
    if (onlyUpToOperationNode) {
        expressionTraversalHelper->backtrackToNode(operationNodeIdAtOriginOfBacktrack);
    }
    else {
        expressionTraversalHelper->backtrackOnePastNode(operationNodeIdAtOriginOfBacktrack);
    }
    const std::optional<ExpressionTraversalHelper::OperationNodeReference> peekedNextOperationNodeAfterFinishOfBacktrack = expressionTraversalHelper->peekNextOperationNode();
    const std::size_t                                                      peekedNextOperationNodeToBeProcessedAfterBacktracking = peekedNextOperationNodeAfterFinishOfBacktrack.has_value() ? peekedNextOperationNodeAfterFinishOfBacktrack.value()->id : 0;
    logBacktrackingResult(operationNodeIdAtOriginOfBacktrack, peekedNextOperationNodeToBeProcessedAfterBacktracking);
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::recordDecision(const DecisionReference& decision) {
    /*const auto& insertPosition = std::find_if(pastDecisions.cbegin(), pastDecisions.cend(), [&decision](const DecisionReference& pastDecision) { return pastDecision->operationNodeId < decision->operationNodeId; });
    if (insertPosition != pastDecisions.cend()) {
        pastDecisions.insert(insertPosition, decision);
    }
    else {
        pastDecisions.emplace(decision);
    }*/
    pastDecisions.emplace(decision);
}

noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OperationNodeProcessingResult noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::processNextOperationNode(const SignalValueLookupCallback& signalValueLookupCallback) {
    std::optional<ExpressionTraversalHelper::OperationNodeReference>   dataOfOperationNode;
    std::optional<OperationNodeSimplificationResult::OwningReference> simplificationResultOfOperationNode;

    bool continueProcessing = true;
    while (continueProcessing) {
        dataOfOperationNode = expressionTraversalHelper->getNextOperationNode();
        if (!dataOfOperationNode.has_value()) {
            return OperationNodeProcessingResult::fromUnknownResult();
        }

        const std::size_t idOfOperationNodeToBeProcessed = dataOfOperationNode->get()->id;
        simplificationResultOfOperationNode              = handleOperationNode(*dataOfOperationNode, signalValueLookupCallback);
        if (shouldBacktrackDueToConflict()) {
            const bool isThisOperationNodeSourceOfConflict = isOperationNodeSourceOfConflict(idOfOperationNodeToBeProcessed);
            if (isThisOperationNodeSourceOfConflict) {
                markSourceOfConflictReached();
            }
            backtrack(idOfOperationNodeToBeProcessed, false);
            if (!isThisOperationNodeSourceOfConflict) {
                return OperationNodeProcessingResult::fromConflictInOtherNode();
            }
        } else {
            continueProcessing = false;
        }
    }

    if (!simplificationResultOfOperationNode.has_value() || !simplificationResultOfOperationNode->get()->hasKnownValue()) {
        return OperationNodeProcessingResult::fromUnknownResult();
    }

    if (!simplificationResultOfOperationNode.has_value()) {
        const std::size_t idOfOperationNodeToBeProcessed = dataOfOperationNode->get()->id;
        if (couldAnotherChoiceBeMadeAtPreviousDecision(idOfOperationNodeToBeProcessed)) {
            generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
            backtrack(idOfOperationNodeToBeProcessed, false);
            return OperationNodeProcessingResult::fromUnknownResult();
        }
        const std::size_t            operationNodeIdOfFirstOperand = *expressionTraversalHelper->getOperandNodeIdOfNestedOperation(*dataOfOperationNode->get()->parentNodeId, dataOfOperationNode->get()->id);
        const syrec::Expression::ptr operandAsExpr                 = *expressionTraversalHelper->getOperandAsExpr(operationNodeIdOfFirstOperand);
        simplificationResultOfOperationNode                        = OperationNodeSimplificationResult::createAndOwnNewInstance(OperationNodeSimplificationResult::createFromNonLeafNode(idOfOperationNodeToBeProcessed, operandAsExpr, {}));
    }
    return OperationNodeProcessingResult::fromResult(std::move(simplificationResultOfOperationNode));
}


bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::canAlternativeBeChosenInOperationNode(std::size_t operationNodeId, Decision::ChoosenOperand toBeChosenAlternative, const syrec::VariableAccess& signalAccess, const syrec::VariableAccess& alternativeToCheckAsSignalAccess, const parser::SymbolTable& symbolTable) const {
    return expressionTraversalHelper->canSignalBeUsedOnAssignmentLhs(signalAccess.var->name)
        && !didPreviousDecisionMatchingChoiceCauseConflict(LearnedConflictsLookupKey(operationNodeId, toBeChosenAlternative))
        && !doSignalAccessesOverlap(alternativeToCheckAsSignalAccess, signalAccess, symbolTable)
        && !isChoiceOfSignalAccessBlockedByAnyActiveExpression(signalAccess);
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::canAlternativeBeChosenInOperationNode(std::size_t operationNodeId, Decision::ChoosenOperand toBeChosenAlternative, const syrec::VariableAccess& signalAccess, const syrec::Expression& alternativeToCheckAsExpr, const parser::SymbolTable& symbolTable) const {
    return expressionTraversalHelper->canSignalBeUsedOnAssignmentLhs(signalAccess.var->name)
        && !didPreviousDecisionMatchingChoiceCauseConflict(LearnedConflictsLookupKey(operationNodeId, toBeChosenAlternative))
        && !doesExprContainOverlappingAccessOnGivenSignalAccess(alternativeToCheckAsExpr, signalAccess, symbolTable)
        && !isChoiceOfSignalAccessBlockedByAnyActiveExpression(signalAccess);
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::isAccessedSignalAssignable(const std::string_view& accessedSignalIdent) const {
    return symbolTableReference && symbolTableReference->canSignalBeAssignedTo(accessedSignalIdent).value_or(false);
}


std::optional<double> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineCostOfExpr(const syrec::Expression& expr, std::size_t currentNestingLevel) const {
    if (const auto& exprAsBinaryExpr = dynamic_cast<const syrec::BinaryExpression*>(&expr); exprAsBinaryExpr) {
        ++currentNestingLevel;
        const std::optional<double> costOfLhsExpr = determineCostOfExpr(*exprAsBinaryExpr->lhs, currentNestingLevel);
        const std::optional<double> costOfRhsExpr = costOfLhsExpr.has_value() ? determineCostOfExpr(*exprAsBinaryExpr->rhs, currentNestingLevel) : std::nullopt;

        if (costOfRhsExpr.has_value()) {
            return (internalConfig.expressionNestingPenaltyScalingPerNestingLevel * currentNestingLevel * internalConfig.expressionNestingPenalty) + *costOfLhsExpr + *costOfRhsExpr;
        }
        return std::nullopt;
    }
    if (const auto& exprAsShiftExpr = dynamic_cast<const syrec::ShiftExpression*>(&expr); exprAsShiftExpr) {
        ++currentNestingLevel;
        const std::optional<double> costOfToBeShiftedExpr = determineCostOfExpr(*exprAsShiftExpr->lhs, currentNestingLevel);
        const std::optional<double> costOfShiftAmount     = costOfToBeShiftedExpr.has_value() ? determineCostOfNumber(*exprAsShiftExpr->rhs, currentNestingLevel) : std::nullopt;

        if (costOfShiftAmount.has_value()) {
            return (internalConfig.expressionNestingPenaltyScalingPerNestingLevel * currentNestingLevel * internalConfig.expressionNestingPenalty) + *costOfToBeShiftedExpr + *costOfShiftAmount;
        }
        return std::nullopt;
    }
    if (const auto& exprAsNumericExpr = dynamic_cast<const syrec::NumericExpression*>(&expr); exprAsNumericExpr) {
        return determineCostOfNumber(*exprAsNumericExpr->value, currentNestingLevel + 1);
    }
    if (const auto& exprAsVariableExpr = dynamic_cast<const syrec::VariableExpression*>(&expr); exprAsVariableExpr) {
        return 1;
    }
    return std::nullopt;
}

std::optional<double> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineCostOfAssignment(const syrec::AssignStatement& assignment) const {
    return determineCostOfExpr(*assignment.rhs, 0);
}

std::optional<double> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineCostOfNumber(const syrec::Number& number, std::size_t currentNestingLevel) const {
    if (number.isCompileTimeConstantExpression()) {
        const std::optional<syrec::BinaryExpression::ptr> numericExprAsBinaryExpr = convertCompileTimeConstantExprToBinaryExpr(number.getExpression(), 0);
        return numericExprAsBinaryExpr.has_value() ? determineCostOfExpr(**numericExprAsBinaryExpr, currentNestingLevel + 1) : std::nullopt;
    }
    return 1;
}

std::optional<double> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineCostOfAssignments(const std::vector<AssignmentTransformer::SharedAssignmentReference>& assignmentsToCheck) const {
    std::optional<double> sumOfCosts = 0;
    for (auto&& assignment: assignmentsToCheck) {
        if (!sumOfCosts.has_value()) {
            break;
        }

        if (std::holds_alternative<std::shared_ptr<syrec::AssignStatement>>(assignment)) {
            const std::shared_ptr<syrec::AssignStatement> assignmentCastedAsBinaryOne = std::get<std::shared_ptr<syrec::AssignStatement>>(assignment);
            tryAddCosts(sumOfCosts, determineCostOfAssignment(*assignmentCastedAsBinaryOne));
        } else if (std::holds_alternative<std::shared_ptr<syrec::UnaryStatement>>(assignment)) {
            tryAddCosts(sumOfCosts, 1);
        } else {
            sumOfCosts.reset();
        }
    }
    return sumOfCosts;
}

std::optional<double> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineCostOfAssignments(SimplificationResult::OwningCopiesOfAssignment& assignments) const {
    std::optional<double> sumOfCosts = 0;
    for (auto&& assignment : assignments){
        if (!sumOfCosts.has_value()) {
            break;
        }

        if (std::holds_alternative<std::unique_ptr<syrec::AssignStatement>>(assignment)) {
            std::unique_ptr<syrec::AssignStatement> temporarilyOwningBinaryAssignment = std::move(std::get<std::unique_ptr<syrec::AssignStatement>>(assignment));
            tryAddCosts(sumOfCosts, determineCostOfAssignment(*temporarilyOwningBinaryAssignment));
            assignment = std::move(temporarilyOwningBinaryAssignment);
        }
        else if (std::holds_alternative<std::unique_ptr<syrec::UnaryStatement>>(assignment)) {
            tryAddCosts(sumOfCosts, 1);
        }
        else {
            sumOfCosts.reset();
        }
    }
    return sumOfCosts;
}

noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::SimplificationResult::OwningReference noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineMostViableAlternativeBasedOnCost(SimplificationResult::OwningReference& generatedSimplifiedAssignments, const std::shared_ptr<syrec::AssignStatement>& originalAssignmentUnoptimized, const SignalValueLookupCallback& signalValueCallback) const {
    SimplificationResult::OwningReference endResult = SimplificationResult::createOwningReferenceOf(SimplificationResult::asEmptyResult());
    if (!endResult || internalConfig.preferAssignmentsGeneratedByChoiceRegardlessOfCost) {
        return std::move(generatedSimplifiedAssignments);
    }
    
    /*if (!generatedSimplifiedAssignments.empty() && (!doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(*originalAssignmentUnoptimized->rhs) || internalConfig.preferAssignmentsGeneratedByChoiceRegardlessOfCost)) {
        return generatedSimplifiedAssignments;
    }*/

    auto containerForUnoptimizedOriginalAssignment = std::vector<AssignmentTransformer::SharedAssignmentReference>(1, originalAssignmentUnoptimized);
    containerForUnoptimizedOriginalAssignment      = assignmentTransformer->simplify(containerForUnoptimizedOriginalAssignment, signalValueCallback);

    const std::optional<std::size_t> costOfUnoptimizedAssignment                                 = determineCostOfAssignments(containerForUnoptimizedOriginalAssignment);
    const std::optional<std::size_t> costOfRequiredValueResetsOfOptimizedAssignments             = costOfUnoptimizedAssignment.has_value() ? determineCostOfAssignments(generatedSimplifiedAssignments->requiredValueResetsForReplacementsTargetingExistingSignals) : std::nullopt;
    const std::optional<std::size_t> costOfOptimizedAssignments                                  = costOfRequiredValueResetsOfOptimizedAssignments.has_value() ? determineCostOfAssignments(generatedSimplifiedAssignments->generatedAssignments) : std::nullopt;
    const std::optional<std::size_t> costOfRequiredInversionsOfValueResetsOfOptimizedAssignments = costOfOptimizedAssignments.has_value() ? determineCostOfAssignments(generatedSimplifiedAssignments->requiredInversionsOfValuesResetsForReplacementsTargetingExistingSignals) : std::nullopt;

    std::optional<double> sumOfCostsOfOptimizedAssignments = 0;
    tryAddCosts(sumOfCostsOfOptimizedAssignments, costOfRequiredValueResetsOfOptimizedAssignments);
    tryAddCosts(sumOfCostsOfOptimizedAssignments, costOfOptimizedAssignments);
    tryAddCosts(sumOfCostsOfOptimizedAssignments, costOfRequiredInversionsOfValueResetsOfOptimizedAssignments);

    if (sumOfCostsOfOptimizedAssignments.has_value() && costOfOptimizedAssignments.has_value() && *sumOfCostsOfOptimizedAssignments < *costOfUnoptimizedAssignment) {
        return std::move(generatedSimplifiedAssignments);
    }

    if (std::optional<SimplificationResult::OwningCopiesOfAssignment> owningCopiesOfAssignmentsOfTransformedOriginalAssignment = createOwningCopiesOfAssignments(containerForUnoptimizedOriginalAssignment); owningCopiesOfAssignmentsOfTransformedOriginalAssignment.has_value()) {
        endResult->generatedAssignments = std::move(*owningCopiesOfAssignmentsOfTransformedOriginalAssignment);
    }
    return endResult;
}

/*
 * Notes for implementation:
 * When trying to make a decision which operand to choose:
 * I.  When choosing operand X check in the inactive data dependencies and expressions of the operand Y whether an inactive data dependency exists that overlaps with operand X and would cause a conflict when being replayed
 * II. Check for the inactive data dependencies of the operand Y that is not chosen whether a replay of this assignment overlaps with any active assignment
 *  => The conflict should then originate in the data dependency and not the active assignment (could also be in the active assignment)
 * III. Check for any active data dependency whether the replay of its nested inactive data dependencies would overlap with any active assignment (omitting the active assignment in the path to operand X)
 *      active data dependencies itself do not need to be checked for overlaps since this should already be covered by the "normal" conflict check
 * IV. If both operands are expressions, theses checks can be omitted. The same holds if both operands are signal accesses that were not inherited from its child nodes
 *
 */
std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OverlappingSignalAccessDuringReplayOrInversionResult> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::areAssignedToSignalPartsAccessedDuringReplayOrInversionOfDataDependencies(std::size_t operationNodeId, Decision::ChoosenOperand toBeChosenOperandForAssignedToSignalParts, const syrec::VariableAccess& assignedToSignalParts, const TemporaryAssignmentsContainer::OrderedAssignmentIdContainer& dataDependenciesOfAssignmentRhs) const {
    if (toBeChosenOperandForAssignedToSignalParts == Decision::ChoosenOperand::None) {
        return OverlappingSignalAccessDuringReplayOrInversionResult::asNoOverlapFound();
    }
    
    for (const std::size_t assignmentIdOfDataDependency: dataDependenciesOfAssignmentRhs) {
        if (std::optional<OverlappingSignalAccessDuringReplayOrInversionResult> searchForOverlapInDataDependencyResult = areAssignedToSignalPartsAccessedDuringReplayOrInversionOfAssignmentOrItsDataDependencies(assignedToSignalParts, assignmentIdOfDataDependency); searchForOverlapInDataDependencyResult.has_value()) {
            if (searchForOverlapInDataDependencyResult->overlapSearchResult != OverlapSearchResult::NoneFound) {
                return searchForOverlapInDataDependencyResult;
            }
        } else {
            break;
        }
    }   
    return OverlappingSignalAccessDuringReplayOrInversionResult::asNoOverlapFound();
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OverlappingSignalAccessDuringReplayOrInversionResult> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::areAssignedToSignalPartsAccessedDuringReplayOrInversionOfAssignmentOrItsDataDependencies(const syrec::VariableAccess& signalPartsForWhichOverlapShallBeFound, std::size_t assignmentId) const {
    const std::optional<TemporaryAssignmentsContainer::IsAssignmentLiveAndTypeInformation>& additionalAssignmentInformation = generatedAssignmentsContainer->isAssignmentLiveAndInversionOfOtherAssignment(assignmentId);
    if (!additionalAssignmentInformation.has_value()) {
        return std::nullopt;
    }

    OverlappingSignalAccessDuringReplayOrInversionResult searchResult                      = OverlappingSignalAccessDuringReplayOrInversionResult::asNoOverlapFound();
    const std::optional<syrec::VariableAccess::ptr>&     assignedToSignalPartsOfAssignment = generatedAssignmentsContainer->getAssignedToSignalPartsOfAssignmentById(assignmentId);
    /*
     * We can restrict this check to only inactive assignments since we assume that a prior conflict check was already performed checking whether the assigned to signal parts do not overlap with an other active assignment that is not on the current
     * inheritance chain
     */
    if (!additionalAssignmentInformation->isLive && !additionalAssignmentInformation->isInversionOfOtherAssignment && doSignalAccessesOverlap(signalPartsForWhichOverlapShallBeFound, **assignedToSignalPartsOfAssignment, *symbolTableReference)) {
        searchResult.idOfOperationNodeWhereOverlapOfAssignedToSignalPartsWasFound   = generatedAssignmentsContainer->getAssociatedOperationNodeIdForAssignmentById(assignmentId);
        searchResult.idOfLastAssignmentInInheritanceChainWithOverlappingSignalParts = assignmentId;
        searchResult.overlapSearchResult |= OverlapSearchResult::AssignedToSignalPartsOverlapped;
    }

    /*
     * We check whether any assignable signal parts defined in the assignment rhs expression overlap with the to be chosen assigned to signal parts before the data dependencies since this allows us
     * to to choose another operand at the current operation node instead of the chosen assigned to signal parts if no other to be replayed data dependency existed with an overlap in the assigned to signal parts
     */
    const std::vector<syrec::VariableAccess::ptr>& assignableSignalAccessesWhichAreNoDataDependenciesInAssignmentRhsExpr = generatedAssignmentsContainer->getSignalAccessesDefinedInAssignmentRhsExcludingDataDependencies(assignmentId);
    if (std::any_of(assignableSignalAccessesWhichAreNoDataDependenciesInAssignmentRhsExpr.cbegin(), assignableSignalAccessesWhichAreNoDataDependenciesInAssignmentRhsExpr.cend(), [&, signalPartsForWhichOverlapShallBeFound](const syrec::VariableAccess::ptr& assignableSignalParts) {
            return expressionTraversalHelper->canSignalBeUsedOnAssignmentLhs(assignableSignalParts->var->name) && doSignalAccessesOverlap(signalPartsForWhichOverlapShallBeFound, *assignableSignalParts, *symbolTableReference);
        })) {
        searchResult.idOfOperationNodeWhereOverlapOfNoneDataDependencyWasFound = generatedAssignmentsContainer->getAssociatedOperationNodeIdForAssignmentById(assignmentId);
        searchResult.idOfLastAssignmentInInheritanceChainWithOverlappingSignalParts = assignmentId;
        searchResult.overlapSearchResult |= OverlapSearchResult::NoneDataDependencyOverlapped;
        return searchResult;
    }

    const TemporaryAssignmentsContainer::OrderedAssignmentIdContainer dataDependencies = generatedAssignmentsContainer->getDataDependenciesOfAssignment(assignmentId);
    for (const std::size_t dataDependency: dataDependencies) {
        const std::optional<OverlappingSignalAccessDuringReplayOrInversionResult> overlapSearchResultInDataDependency = areAssignedToSignalPartsAccessedDuringReplayOrInversionOfAssignmentOrItsDataDependencies(signalPartsForWhichOverlapShallBeFound, dataDependency);
        if (!overlapSearchResultInDataDependency.has_value()) {
            return std::nullopt;
        }

        /*
         * When we find an overlap in the assigned to signal parts of the data dependency we have to choices, we either mark the choice in the data dependency as a conflict or try and choose another operand in the current operation node.
         * We override any previously found assignment id here to determine the earliest assignment (i.e. earliest in the processing order of the operation nodes) and thus also the first assignment in any inheritance chain.
         */
        if (overlapSearchResultInDataDependency->overlapSearchResult == OverlapSearchResult::AssignedToSignalPartsOverlapped) {
            searchResult.overlapSearchResult |= OverlapSearchResult::AssignedToSignalPartsOverlapped;
            searchResult.idOfOperationNodeWhereOverlapOfAssignedToSignalPartsWasFound = generatedAssignmentsContainer->getAssociatedOperationNodeIdForAssignmentById(dataDependency);
            if (searchResult.idOfLastAssignmentInInheritanceChainWithOverlappingSignalParts.value_or(0) < overlapSearchResultInDataDependency->idOfLastAssignmentInInheritanceChainWithOverlappingSignalParts.value_or(0)) {
                searchResult.idOfLastAssignmentInInheritanceChainWithOverlappingSignalParts = *overlapSearchResultInDataDependency->idOfLastAssignmentInInheritanceChainWithOverlappingSignalParts;
            }
            else {
                searchResult.idOfLastAssignmentInInheritanceChainWithOverlappingSignalParts = dataDependency;
            }
        }
        if (!(searchResult.overlapSearchResult & OverlapSearchResult::NoneDataDependencyOverlapped) && overlapSearchResultInDataDependency->overlapSearchResult == OverlapSearchResult::NoneDataDependencyOverlapped) {
            searchResult.overlapSearchResult |= OverlapSearchResult::NoneDataDependencyOverlapped;
            searchResult.idOfOperationNodeWhereOverlapOfNoneDataDependencyWasFound = generatedAssignmentsContainer->getAssociatedOperationNodeIdForAssignmentById(dataDependency);
        }
    }
    return searchResult;
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OverlappingSignalAccessDuringReplayOrInversionResult> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::areAssignedToSignalPartsOfAnyActiveAssignmentAccessedDuringReplayOrInversionOfDataDependencies(std::size_t operationNodeId, Decision::ChoosenOperand toBeChosenOperandForAssignedToSignalParts, const TemporaryAssignmentsContainer::OrderedAssignmentIdContainer& dataDependenciesOfAssignmentRhs) const {
    if (toBeChosenOperandForAssignedToSignalParts == Decision::ChoosenOperand::None) {
        return OverlappingSignalAccessDuringReplayOrInversionResult::asNoOverlapFound();
    }

    std::vector<TemporaryAssignmentsContainer::SearchSpaceIntervalBounds>        searchSpacesToConsider(1, TemporaryAssignmentsContainer::SearchSpaceIntervalBounds(0, operationNodeId));
    if (toBeChosenOperandForAssignedToSignalParts == Decision::ChoosenOperand::Left) {
        const std::size_t     additionalSearchSpaceLowerBound = expressionTraversalHelper->getOperationNodeIdOfRightOperand(operationNodeId).value_or(SIZE_MAX);
        constexpr std::size_t additionalSearchSpaceUpperBound = SIZE_MAX;
        searchSpacesToConsider.emplace_back(additionalSearchSpaceLowerBound, additionalSearchSpaceUpperBound);
    }
    else {
        searchSpacesToConsider.emplace_back(TemporaryAssignmentsContainer::SearchSpaceIntervalBounds(operationNodeId, expressionTraversalHelper->getOperationNodeIdOfRightOperand(operationNodeId).value_or(SIZE_MAX)));
    }

    const TemporaryAssignmentsContainer::OrderedBasicActiveAssignmentDataLookup& activeAssignmentsLookup = generatedAssignmentsContainer->getActiveAssignments(searchSpacesToConsider);
     for (const std::size_t assignmentIdOfDataDependency: dataDependenciesOfAssignmentRhs) {
        if (std::optional<OverlappingSignalAccessDuringReplayOrInversionResult> searchForOverlapInDataDependencyResult = areAssignedToSignalPartsOfAnyActiveAssignmentAccessedDuringReplayOrInversionOfDataDependencies(assignmentIdOfDataDependency, activeAssignmentsLookup); searchForOverlapInDataDependencyResult.has_value()) {
            if (searchForOverlapInDataDependencyResult->overlapSearchResult != OverlapSearchResult::NoneFound) {
                return searchForOverlapInDataDependencyResult;
            }
        } else {
            break;
        }
    }
    return OverlappingSignalAccessDuringReplayOrInversionResult::asNoOverlapFound();
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OverlappingSignalAccessDuringReplayOrInversionResult> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::areAssignedToSignalPartsOfAnyActiveAssignmentAccessedDuringReplayOrInversionOfDataDependencies(std::size_t assignmentId, const TemporaryAssignmentsContainer::OrderedBasicActiveAssignmentDataLookup& activeAssignmentsLookup) const {
    const std::optional<TemporaryAssignmentsContainer::IsAssignmentLiveAndTypeInformation>& additionalAssignmentInformation = generatedAssignmentsContainer->isAssignmentLiveAndInversionOfOtherAssignment(assignmentId);
    if (!additionalAssignmentInformation.has_value()) {
        return std::nullopt;
    }

    OverlappingSignalAccessDuringReplayOrInversionResult searchResult                      = OverlappingSignalAccessDuringReplayOrInversionResult::asNoOverlapFound();
    const std::optional<syrec::VariableAccess::ptr>&     assignedToSignalPartsOfAssignment = generatedAssignmentsContainer->getAssignedToSignalPartsOfAssignmentById(assignmentId);
    /*
     * We can restrict this check to only inactive assignments since we assume that a prior conflict check was already performed checking whether the assigned to signal parts do not overlap with an other active assignment that is not on the current
     * inheritance chain
     */
    if (!additionalAssignmentInformation->isLive && !additionalAssignmentInformation->isInversionOfOtherAssignment) {
        if (const std::optional<std::size_t>& idOfOverlappingActiveAssignment = getIdOfOverlappingActiveAssignmentForSignalPartsOfToBeReplayedAssignment(**assignedToSignalPartsOfAssignment, activeAssignmentsLookup); idOfOverlappingActiveAssignment.has_value()) {
            searchResult.idOfOperationNodeWhereOverlapOfAssignedToSignalPartsWasFound                   = activeAssignmentsLookup.at(*idOfOverlappingActiveAssignment).associatedOperationNodeId;
            searchResult.optionalOperationNodeIdOfOriginOfInheritanceChainOfOverlappingActiveAssignment = generatedAssignmentsContainer->getIdOfOperationNodeWhereOriginOfInheritanceChainIsLocated(*idOfOverlappingActiveAssignment);
            searchResult.overlapSearchResult |= OverlapSearchResult::AssignedToSignalPartsOverlapped;
        }
    }

    /*
     * We check whether any assignable signal parts defined in the assignment rhs expression overlap with the to be chosen assigned to signal parts before the data dependencies since this allows us
     * to to choose another operand at the current operation node instead of the chosen assigned to signal parts if no other to be replayed data dependency existed with an overlap in the assigned to signal parts
     */
    const std::vector<syrec::VariableAccess::ptr>& assignableSignalAccessesWhichAreNoDataDependenciesInAssignmentRhsExpr = generatedAssignmentsContainer->getSignalAccessesDefinedInAssignmentRhsExcludingDataDependencies(assignmentId);
    for (const syrec::VariableAccess::ptr& noneDataDependencySignalAccess: assignableSignalAccessesWhichAreNoDataDependenciesInAssignmentRhsExpr) {
        if (!expressionTraversalHelper->canSignalBeUsedOnAssignmentLhs(noneDataDependencySignalAccess->var->name))
            continue;

        if (const std::optional<std::size_t> idOfOverlappingActiveAssignment = getIdOfOverlappingActiveAssignmentForSignalPartsOfToBeReplayedAssignment(*noneDataDependencySignalAccess, activeAssignmentsLookup); idOfOverlappingActiveAssignment.has_value()) {
            searchResult.idOfOperationNodeWhereOverlapOfNoneDataDependencyWasFound                      = activeAssignmentsLookup.at(*idOfOverlappingActiveAssignment).associatedOperationNodeId;
            searchResult.optionalOperationNodeIdOfOriginOfInheritanceChainOfOverlappingActiveAssignment = generatedAssignmentsContainer->getIdOfOperationNodeWhereOriginOfInheritanceChainIsLocated(*idOfOverlappingActiveAssignment);
            searchResult.overlapSearchResult |= OverlapSearchResult::NoneDataDependencyOverlapped;
            return searchResult;
        }
    }

    const TemporaryAssignmentsContainer::OrderedAssignmentIdContainer dataDependencies = generatedAssignmentsContainer->getDataDependenciesOfAssignment(assignmentId);
    for (const std::size_t dataDependency: dataDependencies) {
        const std::optional<OverlappingSignalAccessDuringReplayOrInversionResult> overlapSearchResultInDataDependency = areAssignedToSignalPartsOfAnyActiveAssignmentAccessedDuringReplayOrInversionOfDataDependencies(dataDependency, activeAssignmentsLookup);
        if (!overlapSearchResultInDataDependency.has_value()) {
            return std::nullopt;
        }

        /*
         * When we find an overlap in the assigned to signal parts of the data dependency we have to choices, we either mark the choice in the data dependency as a conflict or try and choose another operand in the current operation node.
         * We override any previously found assignment id here to determine the earliest assignment (i.e. earliest in the processing order of the operation nodes) and thus also the first assignment in any inheritance chain.
         */
        if (overlapSearchResultInDataDependency->overlapSearchResult == OverlapSearchResult::AssignedToSignalPartsOverlapped) {
            searchResult.overlapSearchResult |= OverlapSearchResult::AssignedToSignalPartsOverlapped;
            searchResult.idOfOperationNodeWhereOverlapOfAssignedToSignalPartsWasFound = generatedAssignmentsContainer->getAssociatedOperationNodeIdForAssignmentById(dataDependency);
        }
        if (!(searchResult.overlapSearchResult & OverlapSearchResult::NoneDataDependencyOverlapped) && overlapSearchResultInDataDependency->overlapSearchResult == OverlapSearchResult::NoneDataDependencyOverlapped) {
            searchResult.overlapSearchResult |= OverlapSearchResult::NoneDataDependencyOverlapped;
            searchResult.idOfOperationNodeWhereOverlapOfNoneDataDependencyWasFound = generatedAssignmentsContainer->getAssociatedOperationNodeIdForAssignmentById(dataDependency);
        }
    }
    return searchResult;
}

std::optional<std::size_t> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::getIdOfOverlappingActiveAssignmentForSignalPartsOfToBeReplayedAssignment(const syrec::VariableAccess& assignedToSignalPartsWhichShouldNotOverlapActiveAssignment, const TemporaryAssignmentsContainer::OrderedBasicActiveAssignmentDataLookup& activeAssignmentsLookup) const {
    const auto& overlappingActiveAssignmentId = std::find_if(activeAssignmentsLookup.cbegin(), activeAssignmentsLookup.cend(), [&](const std::pair< std::size_t, TemporaryAssignmentsContainer::BasicActiveAssignmentData>& idAndBasicDataOfActiveAssignmentDataTuple) {
        return doSignalAccessesOverlap(assignedToSignalPartsWhichShouldNotOverlapActiveAssignment, *idAndBasicDataOfActiveAssignmentDataTuple.second.assignedToSignalParts, *symbolTableReference);
    });
    if (overlappingActiveAssignmentId != activeAssignmentsLookup.cend()) {
        return overlappingActiveAssignmentId->first;
    }
    return std::nullopt;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineWhetherConflictShouldBeTriggeredInCurrentOperationNodeOrOverlappingDataDependencyBasedOnInheritanceChainLength(std::size_t idOfAssignmentFromWhichAssignedToSignalPartsInCurrentOperationNodeWhereInherited, std::size_t idOfLastAssignmentInInheritanceChainOverlappingAssignedToSignalParts) const {
    return generatedAssignmentsContainer->determineLengthOfInheritanceChainLengthOfAssignment(idOfAssignmentFromWhichAssignedToSignalPartsInCurrentOperationNodeWhereInherited) < generatedAssignmentsContainer->determineLengthOfInheritanceChainLengthOfAssignment(idOfLastAssignmentInInheritanceChainOverlappingAssignedToSignalParts);
}

// TODO: This check should not be made if the chosen operand was inherited since said check should have already be done in the child node? or could any conflicting active assignment have been created in the meantime?
/*
 * TODO:
 * The current usage of the result of this function is to determine whether an assignment for the given operand can be generated due to an overlap with an inactive data dependency of an active assignment.
 * Since we know that the data dependency already created an assignment, we could either not chose the current operand to generate an assignment or trigger the conflict at the inactive data dependency.
 * The current heuristic uses the former.
 */
bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::existsActiveAssignmentWhereReplayOfAnyOfItsDataDependenciesAccessesSameSignalPartsAsChosenOperand(const syrec::VariableAccess& assignedToSignalPartsForWhichNoOverlappingActiveAssignmentShouldExist, std::size_t operationNodeWhereSearchIsTriggered, Decision::ChoosenOperand chosenOperandAtOperationNode) const {
    std::vector<TemporaryAssignmentsContainer::SearchSpaceIntervalBounds> searchSpacesToConsider(1, TemporaryAssignmentsContainer::SearchSpaceIntervalBounds(0, operationNodeWhereSearchIsTriggered));
    if (chosenOperandAtOperationNode == Decision::ChoosenOperand::Left) {
        const std::size_t     additionalSearchSpaceLowerBound = expressionTraversalHelper->getOperationNodeIdOfRightOperand(operationNodeWhereSearchIsTriggered).value_or(SIZE_MAX);
        constexpr std::size_t additionalSearchSpaceUpperBound = SIZE_MAX;
        searchSpacesToConsider.emplace_back(additionalSearchSpaceLowerBound, additionalSearchSpaceUpperBound);
    }

    const TemporaryAssignmentsContainer::OrderedBasicActiveAssignmentDataLookup activeAssignmentsToConsider = generatedAssignmentsContainer->getActiveAssignments(searchSpacesToConsider);
    for (const std::pair<const std::size_t, TemporaryAssignmentsContainer::BasicActiveAssignmentData>& activeAssignmentIdAndData : activeAssignmentsToConsider) {
        for (const std::size_t dataDependencyOfActiveAssignment : activeAssignmentIdAndData.second.dataDependencies) {
            if (activeAssignmentsToConsider.count(dataDependencyOfActiveAssignment)) {
                continue;
            }

            if (const std::optional<syrec::VariableAccess::ptr>& assignedToSignalParts = generatedAssignmentsContainer->getAssignedToSignalPartsOfAssignmentById(dataDependencyOfActiveAssignment); assignedToSignalParts.has_value()
                && doSignalAccessesOverlap(**assignedToSignalParts, assignedToSignalPartsForWhichNoOverlappingActiveAssignmentShouldExist, *symbolTableReference)) {
                return true;
            }
        }
    }
    return false;
}


/*
 * Is this check only relevant for operation nodes with one leaf node where the leaf node is now chosen.
 * Example I: c += (a - (b - (a - 2)))
 * Example II: d += (((b - (a + 2)) * (c + 2)) + (a + 2))
 *
 *
 * TODO: Add transformation of two subsequent subtraction operations as a new config parameter
 */
void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleConflictCausesByReplayOrInversion(std::size_t idOfOperationNodeWhereConflictCheckWasInitiated, const OverlappingSignalAccessDuringReplayOrInversionResult& conflictResult) {
    constexpr std::size_t            earliestPossibleOperationNodeId = 0;
    std::optional<DecisionReference> earliestDecisionInvolvedInConflict;
    switch (conflictResult.overlapSearchResult) {
        case OverlapSearchResult::NoneDataDependencyOverlapped:
            earliestDecisionInvolvedInConflict = tryGetDecisionForOperationNode(*conflictResult.optionalOperationNodeIdOfOriginOfInheritanceChainOfOverlappingActiveAssignment);
            break;
        case OverlapSearchResult::AssignedToSignalPartsOverlapped:
            earliestDecisionInvolvedInConflict = tryGetDecisionForOperationNode(*conflictResult.optionalOperationNodeIdOfOriginOfInheritanceChainOfOverlappingActiveAssignment);
            break;
        default:
            return;
    }

    std::size_t idOfEarliestOperationNodeIdInvolvedInConflict = earliestPossibleOperationNodeId;
    if (earliestDecisionInvolvedInConflict.has_value()) {
        idOfEarliestOperationNodeIdInvolvedInConflict = earliestDecisionInvolvedInConflict->get()->operationNodeId;
        rememberConflict(earliestDecisionInvolvedInConflict->get()->operationNodeId, earliestDecisionInvolvedInConflict->get()->choosenOperand);
    }

    if (conflictResult.overlapSearchResult == OverlapSearchResult::NoneDataDependencyOverlapped) {
        logReplayOfAssignmentConflictDueToOverlapWithNoneDataDependency(idOfOperationNodeWhereConflictCheckWasInitiated, *conflictResult.idOfOperationNodeWhereOverlapOfNoneDataDependencyWasFound, conflictResult.optionalNoneDataDependencySignalAccessWhereOverlapWasFound.value(), *conflictResult.optionalOperationNodeIdOfOriginOfInheritanceChainOfOverlappingActiveAssignment, earliestDecisionInvolvedInConflict->get()->choosenOperand);
    }
    else {
        const std::optional<DecisionReference>& decisionForNowInactiveDataDependency = tryGetDecisionForOperationNode(*conflictResult.idOfOperationNodeWhereOverlapOfAssignedToSignalPartsWasFound);
        logReplayOfAssignmentConflictDueToOverlapWithDataDependency(idOfOperationNodeWhereConflictCheckWasInitiated, *conflictResult.idOfOperationNodeWhereOverlapOfAssignedToSignalPartsWasFound, decisionForNowInactiveDataDependency->get()->choosenOperand, *conflictResult.optionalOperationNodeIdOfOriginOfInheritanceChainOfOverlappingActiveAssignment, earliestDecisionInvolvedInConflict->get()->choosenOperand);
    }
    
    std::unordered_set<std::size_t> hotPathFromSourceOfConflictToLocationWhereConflictWasDetected                                 = {};
    const std::size_t               idOfEarliestSharedParentOperationNodeBetweenSourceOfConflictAndDetectionOfOriginOperationNode = determineEarliestSharedParentOperationNodeIdBetweenCurrentAndConflictOperationNodeId(idOfEarliestOperationNodeIdInvolvedInConflict, idOfOperationNodeWhereConflictCheckWasInitiated, hotPathFromSourceOfConflictToLocationWhereConflictWasDetected);
    markOperationNodeAsSourceOfConflict(idOfEarliestSharedParentOperationNodeBetweenSourceOfConflictAndDetectionOfOriginOperationNode);
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleConflictCausedByOverlapOfInactiveDataDependencyWithInheritedChosenOperand(std::size_t idOfOperationNodeWhereDecisionWasMade, Decision::ChoosenOperand chosenOperationAtOperationNode, std::size_t idOfInheritedAssignmentInOperationNode, std::size_t idOfAssignmentWhereOverlappingSignalAccessInAssignedToSignalPartsWasDefined) {
    const std::size_t inheritanceChainLengthAtChosenOperandOfOperationNode = generatedAssignmentsContainer->determineLengthOfInheritanceChainLengthOfAssignment(idOfInheritedAssignmentInOperationNode);
    const std::size_t inheritanceChainLengthAtInactiveDataDependency       = generatedAssignmentsContainer->determineLengthOfInheritanceChainLengthOfAssignment(idOfAssignmentWhereOverlappingSignalAccessInAssignedToSignalPartsWasDefined);

    const std::size_t                operationNodeIdWhereOverlappingSignalPartsWhereDefined = *generatedAssignmentsContainer->getIdOfOperationNodeWhereOriginOfInheritanceChainIsLocated(idOfAssignmentWhereOverlappingSignalAccessInAssignedToSignalPartsWasDefined);
    const std::size_t                operationNodeIdWithOriginOfInheritanceChainAtCurrentOperationNode = *generatedAssignmentsContainer->getIdOfOperationNodeWhereOriginOfInheritanceChainIsLocated(idOfInheritedAssignmentInOperationNode);

    constexpr std::size_t            earliestPossibleOperationNodeId                        = 0;
    std::optional<DecisionReference> earliestDecisionInvolvedInConflict;
    
    if (!inheritanceChainLengthAtInactiveDataDependency && inheritanceChainLengthAtInactiveDataDependency < inheritanceChainLengthAtChosenOperandOfOperationNode) {
        earliestDecisionInvolvedInConflict = tryGetDecisionForOperationNode(operationNodeIdWhereOverlappingSignalPartsWhereDefined);
    }
    else {
        earliestDecisionInvolvedInConflict = tryGetDecisionForOperationNode(operationNodeIdWithOriginOfInheritanceChainAtCurrentOperationNode);
    }

    std::size_t idOfEarliestOperationNodeIdInvolvedInConflict = earliestPossibleOperationNodeId;
    if (earliestDecisionInvolvedInConflict.has_value()) {
        idOfEarliestOperationNodeIdInvolvedInConflict = earliestDecisionInvolvedInConflict->get()->operationNodeId;
        rememberConflict(earliestDecisionInvolvedInConflict->get()->operationNodeId, earliestDecisionInvolvedInConflict->get()->choosenOperand);
    }

    
    logReplayOfAssignmentConflictDueToOverlapWithDataDependencyAndConflictOriginChoiceBasedOnInheritanceChainLength(idOfOperationNodeWhereDecisionWasMade, chosenOperationAtOperationNode, inheritanceChainLengthAtChosenOperandOfOperationNode, operationNodeIdWhereOverlappingSignalPartsWhereDefined, inheritanceChainLengthAtInactiveDataDependency);
    std::unordered_set<std::size_t> hotPathFromSourceOfConflictToLocationWhereConflictWasDetected                                 = {};
    const std::size_t               idOfEarliestSharedParentOperationNodeBetweenSourceOfConflictAndDetectionOfOriginOperationNode = determineEarliestSharedParentOperationNodeIdBetweenCurrentAndConflictOperationNodeId(idOfEarliestOperationNodeIdInvolvedInConflict, idOfOperationNodeWhereDecisionWasMade, hotPathFromSourceOfConflictToLocationWhereConflictWasDetected);
    markOperationNodeAsSourceOfConflict(idOfEarliestSharedParentOperationNodeBetweenSourceOfConflictAndDetectionOfOriginOperationNode);
}


std::optional<syrec::Expression::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::fuseExpressions(const syrec::Expression::ptr& lhsOperand, syrec_operation::operation op, const syrec::Expression::ptr& rhsOperand) {
    if (syrec_operation::isOperationShiftOperation(op)) {
        if (const auto& rhsOperandAsNumericExpr = std::dynamic_pointer_cast<syrec::NumericExpression>(rhsOperand); rhsOperandAsNumericExpr) {
            const auto generatedShiftExpr = std::make_shared<syrec::ShiftExpression>(
                    lhsOperand,
                    *syrec_operation::tryMapShiftOperationEnumToFlag(op),
                    rhsOperandAsNumericExpr->value);
            return generatedShiftExpr;    
        }
        return std::nullopt;
    }
    const auto generatedBinaryExpr = std::make_shared<syrec::BinaryExpression>(lhsOperand, *syrec_operation::tryMapBinaryOperationEnumToFlag(op), rhsOperand);
    return generatedBinaryExpr;
}

std::optional<syrec::AssignStatement::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryCreateAssignmentForOperationNode(const syrec::VariableAccess::ptr& assignmentLhs, syrec_operation::operation op, const syrec::Expression::ptr& assignmentRhs) {
    if (const auto matchingAssignmentOperationForOperation = syrec_operation::getMatchingAssignmentOperationForOperation(op); matchingAssignmentOperationForOperation.has_value()) {
        const auto& mappedToAssignmentOperationFlag = syrec_operation::tryMapAssignmentOperationEnumToFlag(*matchingAssignmentOperationForOperation);
        const auto& generatedAssignment = std::make_shared<syrec::AssignStatement>(assignmentLhs, *mappedToAssignmentOperationFlag, assignmentRhs);
        return generatedAssignment;
    }
    return std::nullopt;
}

inline bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesExpressionDefineNestedSplitableExpr(const syrec::Expression& expr) {
    // We are assuming here that compile time constant expressions were already converted to binary expressions
    return dynamic_cast<const syrec::BinaryExpression*>(&expr) || dynamic_cast<const syrec::ShiftExpression*>(&expr);
}

inline bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesExpressionDefineNumber(const syrec::Expression& expr) {
    return dynamic_cast<const syrec::NumericExpression*>(&expr);
}

inline bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesExprDefineSignalAccess(const syrec::Expression& expr) {
    return dynamic_cast<const syrec::VariableExpression*>(&expr);
}

std::optional<syrec::Expression::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryCreateExpressionFromOperationNodeOperandSimplifications(const OperationNodeSimplificationResult& simplificationResultOfFirstOperand, syrec_operation::operation operationNodeOperation, const OperationNodeSimplificationResult& simplificationResultOfSecondOperand) {
    const std::optional<syrec::Expression::ptr> generatedLhsOperandExpr = tryCreateExpressionFromOperationNodeOperandSimplification(simplificationResultOfFirstOperand);
    if (const std::optional<syrec::Expression::ptr> generatedRhsOperandExpr = generatedLhsOperandExpr.has_value() ? tryCreateExpressionFromOperationNodeOperandSimplification(simplificationResultOfSecondOperand) : std::nullopt; generatedRhsOperandExpr.has_value()) {
        return fuseExpressions(*generatedLhsOperandExpr, operationNodeOperation, *generatedRhsOperandExpr);
    }
    return std::nullopt;
}

std::optional<syrec::Expression::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryCreateExpressionFromOperationNodeOperandSimplification(const OperationNodeSimplificationResult& simplificationResultOfOperand) {
    if (const std::optional<syrec::VariableAccess::ptr> lastAssignedToSignalOfFirstOperand = simplificationResultOfOperand.getResultAsSignalAccess(); lastAssignedToSignalOfFirstOperand.has_value()) {
        if (const syrec::Expression::ptr generatedVariableExpr = std::make_shared<syrec::VariableExpression>(*lastAssignedToSignalOfFirstOperand); generatedVariableExpr) {
            return generatedVariableExpr;
        }
    } else {
        if (std::optional<syrec::Expression::ptr> preexistingExpr = simplificationResultOfOperand.getResultAsExpr(); preexistingExpr.has_value()) {
            return preexistingExpr;
        }
    }
    return std::nullopt;
}

std::optional<syrec::Number::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryCreateNumberFromOperationNodeOperandSimplification(const OperationNodeSimplificationResult& simplificationResultOfOperand) {
    if (std::optional<syrec::Expression::ptr> preexistingExpr = simplificationResultOfOperand.getResultAsExpr(); preexistingExpr.has_value()) {
        if (const std::shared_ptr<syrec::NumericExpression>& exprAsNumericExpr = std::dynamic_pointer_cast<syrec::NumericExpression>(*preexistingExpr); exprAsNumericExpr) {
            return exprAsNumericExpr->value;
        }
    }
    return std::nullopt;
}


bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::areAssignedToSignalPartsZero(const syrec::VariableAccess& accessedSignalParts, const SignalValueLookupCallback& signalValueLookupCallback) {
    const std::optional<unsigned int> fetchedValueOfAccessedSignalParts = signalValueLookupCallback(accessedSignalParts);
    return fetchedValueOfAccessedSignalParts.has_value() && !*fetchedValueOfAccessedSignalParts;
}

// TODO: One could extend this condition to also include that non-reversible operations are only defined at operations nodes with only leaf nodes
bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(const syrec::Expression& expr) {
    if (const auto& exprAsNumericExpr = dynamic_cast<const syrec::NumericExpression*>(&expr); exprAsNumericExpr) {
        return !exprAsNumericExpr->value->isCompileTimeConstantExpression();
    }
    if (const auto& exprAsVariableExpr = dynamic_cast<const syrec::VariableExpression*>(&expr); exprAsVariableExpr) {
        return true;
    }
    if (const auto& exprAsBinaryExpr = dynamic_cast<const syrec::BinaryExpression*>(&expr); exprAsBinaryExpr) {
        const std::optional<syrec_operation::operation> mappedToBinaryOperationEnumValue = syrec_operation::tryMapBinaryOperationFlagToEnum(exprAsBinaryExpr->op);
        if (mappedToBinaryOperationEnumValue.has_value() && syrec_operation::getMatchingAssignmentOperationForOperation(*mappedToBinaryOperationEnumValue).has_value()) {
            if (*mappedToBinaryOperationEnumValue == syrec_operation::operation::BitwiseXor) {
                return !(doesExpressionDefineNestedSplitableExpr(*exprAsBinaryExpr->lhs) && doesExpressionDefineNestedSplitableExpr(*exprAsBinaryExpr->rhs))
                    && doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(*exprAsBinaryExpr->lhs) && doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(*exprAsBinaryExpr->rhs);
            }
            return doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(*exprAsBinaryExpr->lhs) && doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(*exprAsBinaryExpr->rhs);
        }
    }
    return false;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryConvertNumericToBinaryExpr(syrec::Expression::ptr& expr) {
    if (const auto& lhsExprAsNumericExpr = std::dynamic_pointer_cast<syrec::NumericExpression>(expr); lhsExprAsNumericExpr) {
        if (const auto& lhsNumericExprAsBinaryExpr = convertNumericExprToBinary(*lhsExprAsNumericExpr); lhsNumericExprAsBinaryExpr.has_value()) {
            expr = *lhsNumericExprAsBinaryExpr;
        }
    }
}


std::optional<syrec::BinaryExpression::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::convertNumericExprToBinary(const syrec::NumericExpression& numericExpr) {
    if (!numericExpr.value->isCompileTimeConstantExpression()) {
        return std::nullopt;
    }
    return convertCompileTimeConstantExprToBinaryExpr(numericExpr.value->getExpression(), numericExpr.bwidth);
}

std::optional<syrec_operation::operation> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryMapCompileTimeConstantExprOperationToBinaryOperation(syrec::Number::CompileTimeConstantExpression::Operation operation) {
    switch (operation) {
        case syrec::Number::CompileTimeConstantExpression::Addition:
            return syrec_operation::operation::Addition;
        case syrec::Number::CompileTimeConstantExpression::Subtraction:
            return syrec_operation::operation::Subtraction;
        case syrec::Number::CompileTimeConstantExpression::Multiplication:
            return syrec_operation::operation::Multiplication;
        case syrec::Number::CompileTimeConstantExpression::Division:
        default:
            return std::nullopt;
    }
}

syrec::Expression::ptr noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::convertNumberToExpr(const syrec::Number::ptr& number, unsigned int expectedBitwidth) {
    if (number->isCompileTimeConstantExpression()) {
        if (const std::optional<syrec::BinaryExpression::ptr> mappedToBinaryExpr = convertCompileTimeConstantExprToBinaryExpr(number->getExpression(), expectedBitwidth); mappedToBinaryExpr.has_value()) {
            return *mappedToBinaryExpr;
        }
        return nullptr;
    }

    const syrec::NumericExpression::ptr generatedExpr = std::make_shared<syrec::NumericExpression>(number, expectedBitwidth);
    return generatedExpr;
}

std::optional<syrec::BinaryExpression::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::convertCompileTimeConstantExprToBinaryExpr(const syrec::Number::CompileTimeConstantExpression& compileTimeConstantExpr, unsigned int expectedBitwidth) {
    const std::optional<syrec_operation::operation> mappedToOperation = tryMapCompileTimeConstantExprOperationToBinaryOperation(compileTimeConstantExpr.operation);
    if (!mappedToOperation.has_value()) {
        return std::nullopt;
    }

    const syrec::Expression::ptr& lhsOperandConverted = convertNumberToExpr(compileTimeConstantExpr.lhsOperand, expectedBitwidth);
    const syrec::Expression::ptr& rhsOperandConverted = convertNumberToExpr(compileTimeConstantExpr.rhsOperand, expectedBitwidth);
    if (!lhsOperandConverted || !rhsOperandConverted) {
        return std::nullopt;
    }

    const syrec::BinaryExpression::ptr generatedExpr = std::make_shared<syrec::BinaryExpression>(lhsOperandConverted, *syrec_operation::tryMapBinaryOperationEnumToFlag(*mappedToOperation), rhsOperandConverted);
    return generatedExpr;
}

syrec::Expression::ptr noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::transformExprBeforeProcessing(const syrec::Expression::ptr& initialExpr) {
    if (const auto& exprAsNumericExpr = std::dynamic_pointer_cast<syrec::NumericExpression>(initialExpr); exprAsNumericExpr) {
        if (const auto& exprConverted = convertNumericExprToBinary(*exprAsNumericExpr); exprConverted.has_value()) {
            return *exprConverted;
        }
    }
    return initialExpr;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesExprContainOverlappingAccessOnGivenSignalAccess(const syrec::Expression& expr, const syrec::VariableAccess& signalAccess, const parser::SymbolTable& symbolTable) {
    if (const auto& exprAsBinaryExpr = dynamic_cast<const syrec::BinaryExpression*>(&expr); exprAsBinaryExpr) {
        return doesExprContainOverlappingAccessOnGivenSignalAccess(*exprAsBinaryExpr->lhs, signalAccess, symbolTable) || doesExprContainOverlappingAccessOnGivenSignalAccess(*exprAsBinaryExpr->rhs, signalAccess, symbolTable);
    }
    if (const auto& exprAsShiftExpr = dynamic_cast<const syrec::ShiftExpression*>(&expr); exprAsShiftExpr) {
        return doesExprContainOverlappingAccessOnGivenSignalAccess(*exprAsShiftExpr->lhs, signalAccess, symbolTable) || doesNumberContainOverlappingAccessOnGivenSignalAccess(*exprAsShiftExpr->rhs, signalAccess, symbolTable);
    }
    if (const auto& exprAsVariableExpr = dynamic_cast<const syrec::VariableExpression*>(&expr); exprAsVariableExpr) {
        return doSignalAccessesOverlap(signalAccess, *exprAsVariableExpr->var, symbolTable);
    }
    if (const auto& exprAsNumericExpr = dynamic_cast<const syrec::NumericExpression*>(&expr); exprAsNumericExpr) {
        return doesNumberContainOverlappingAccessOnGivenSignalAccess(*exprAsNumericExpr->value, signalAccess, symbolTable);
    }
    return false;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesNumberContainOverlappingAccessOnGivenSignalAccess(const syrec::Number& number, const syrec::VariableAccess& signalAccess, const parser::SymbolTable& symbolTable) {
    if (!number.isCompileTimeConstantExpression()) {
        return false;
    }

    const auto& numericExprAsBinaryOne = convertCompileTimeConstantExprToBinaryExpr(number.getExpression(), 0);
    return numericExprAsBinaryOne.has_value() && doesExprContainOverlappingAccessOnGivenSignalAccess(**numericExprAsBinaryOne, signalAccess, symbolTable);
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doSignalAccessesOverlap(const syrec::VariableAccess& firstSignalAccess, const syrec::VariableAccess& otherSignalAccess, const parser::SymbolTable& symbolTable) {
    const SignalAccessUtils::SignalAccessEquivalenceResult equivalenceResult = SignalAccessUtils::areSignalAccessesEqual(
            firstSignalAccess, otherSignalAccess,
            SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::DimensionAccess::Overlapping,
            SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::BitRange::Overlapping,
            symbolTable);
    return !equivalenceResult.isResultCertain || equivalenceResult.equality != SignalAccessUtils::SignalAccessEquivalenceResult::NotEqual;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::areSignalAccessesSyntacticallyEquivalent(const syrec::VariableAccess& firstSignalAccess, const syrec::VariableAccess& otherSignalAccess, const parser::SymbolTable& symbolTable) {
    const SignalAccessUtils::SignalAccessEquivalenceResult equivalenceResult = SignalAccessUtils::areSignalAccessesEqual(
            firstSignalAccess, otherSignalAccess,
            SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::DimensionAccess::Equal,
            SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::BitRange::Equal,
            symbolTable);
    return equivalenceResult.isResultCertain && equivalenceResult.equality == SignalAccessUtils::SignalAccessEquivalenceResult::Equal;
}

std::optional<unsigned> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineBitwidthOfSignalAccess(const syrec::VariableAccess& signalAccess) {
    if (!signalAccess.range.has_value()) {
        return signalAccess.var->bitwidth;
    }

    const std::optional<unsigned int> bitRangeStartEvaluated = evaluateNumber(*signalAccess.range->first);
    const std::optional<unsigned int> bitRangeEndEvaluated   = evaluateNumber(*signalAccess.range->second);
    if (!bitRangeStartEvaluated.has_value() || !bitRangeEndEvaluated.has_value()) {
        return std::nullopt;
    }
    return (*bitRangeEndEvaluated - *bitRangeStartEvaluated) + 1;
}

std::optional<unsigned> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::evaluateNumber(const syrec::Number& numberToEvaluate) {
    return numberToEvaluate.isConstant() ? std::make_optional(numberToEvaluate.evaluate({})) : std::nullopt;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesOperandSimplificationResultMatchExpression(const OperationNodeSimplificationResult& operandSimplificationResult, const syrec::Expression::ptr& exprToCheck) {
    if (const std::optional<syrec::VariableAccess::ptr>& signalAccessDataOfOperand = operandSimplificationResult.getResultAsSignalAccess(); signalAccessDataOfOperand.has_value()) {
        if (const std::shared_ptr<syrec::VariableExpression>& exprAsVariableExpr = std::dynamic_pointer_cast<syrec::VariableExpression>(exprToCheck); exprAsVariableExpr) {
            return *signalAccessDataOfOperand == exprAsVariableExpr->var;
        }
    } else if (const std::optional<syrec::Expression::ptr>& exprDataOfOperand = operandSimplificationResult.getResultAsExpr(); exprDataOfOperand.has_value()) {
        return *exprDataOfOperand == exprToCheck;
    }
    return false;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesOperandSimplificationResultMatchNumber(const OperationNodeSimplificationResult& operandSimplificationResult, const syrec::Number::ptr& numberToCheck) {
    if (const std::optional<syrec::Expression::ptr>& exprDataOfOperand = operandSimplificationResult.getResultAsExpr(); exprDataOfOperand.has_value()) {
        if (const std::shared_ptr<syrec::NumericExpression>& exprAsNumericExpr = std::dynamic_pointer_cast<syrec::NumericExpression>(*exprDataOfOperand); exprAsNumericExpr) {
            return exprAsNumericExpr->value == numberToCheck;
        }
    }
    return false;
}


std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::SimplificationResult::OwningCopyOfAssignment> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::createOwningCopyOfAssignment(const syrec::AssignStatement& assignment) {
    if (auto owningCopyOfAssignment = std::make_unique<syrec::AssignStatement>(assignment); owningCopyOfAssignment) {
        return owningCopyOfAssignment;
    }
    return std::nullopt;
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::SimplificationResult::OwningCopyOfAssignment> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::createOwningCopyOfAssignment(const syrec::UnaryStatement& assignment) {
    if (auto owningCopyOfAssignment = std::make_unique<syrec::UnaryStatement>(assignment); owningCopyOfAssignment) {
        return owningCopyOfAssignment;
    }
    return std::nullopt;
}


std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::SimplificationResult::OwningCopiesOfAssignment> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::createOwningCopiesOfAssignments(const std::vector<TemporaryAssignmentsContainer::AssignmentReferenceVariant>& assignments) {
    SimplificationResult::OwningCopiesOfAssignment containerForCopies;
    containerForCopies.reserve(assignments.size());

    bool copyingSuccessful = true;
    for (std::size_t i = 0; i < assignments.size() && copyingSuccessful; ++i) {
        const TemporaryAssignmentsContainer::AssignmentReferenceVariant& statementToTreatAsAssignment = assignments.at(i);
        if (std::holds_alternative<std::shared_ptr<syrec::AssignStatement>>(statementToTreatAsAssignment)) {
            const std::shared_ptr<syrec::AssignStatement> castedStatementAsBinaryAssignment = std::get<std::shared_ptr<syrec::AssignStatement>>(statementToTreatAsAssignment);
            if (std::optional<SimplificationResult::OwningCopyOfAssignment> copyOfAssignment = createOwningCopyOfAssignment(*castedStatementAsBinaryAssignment); copyOfAssignment.has_value()) {
                containerForCopies.push_back(std::move(*copyOfAssignment));
                continue;
            }    
        }
        else if (std::holds_alternative<std::shared_ptr<syrec::UnaryStatement>>(statementToTreatAsAssignment)) {
            const std::shared_ptr<syrec::UnaryStatement> castedStatementAsUnaryAssignment = std::get<std::shared_ptr<syrec::UnaryStatement>>(statementToTreatAsAssignment);
            if (std::optional<SimplificationResult::OwningCopyOfAssignment> copyOfAssignment = createOwningCopyOfAssignment(*castedStatementAsUnaryAssignment); copyOfAssignment.has_value()) {
                containerForCopies.push_back(std::move(*copyOfAssignment));
                continue;
            }
        }
        copyingSuccessful = false;
    }
    return copyingSuccessful ? std::make_optional(std::move(containerForCopies)) : std::nullopt;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryAddCosts(std::optional<double>& currentSumOfCosts, const std::optional<double>& costsToAdd) {
    if (!costsToAdd.has_value() || !currentSumOfCosts.has_value()) {
        currentSumOfCosts.reset();
        return;
    }

    if (*costsToAdd < (UINT_MAX - *currentSumOfCosts)) {
        currentSumOfCosts = *currentSumOfCosts + *costsToAdd;
    } else {
        currentSumOfCosts.reset();
    }
}


std::vector<syrec::VariableAccess::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineSignalPartsNotUsableAsPotentialReplacementCandidates(const syrec::Expression& expr, const parser::SymbolTable& symbolTable) {
    if (const auto& exprAsBinaryExpr = dynamic_cast<const syrec::BinaryExpression*>(&expr); exprAsBinaryExpr) {
        std::vector<syrec::VariableAccess::ptr> notUsableCandidatesOfLhs = determineSignalPartsNotUsableAsPotentialReplacementCandidates(*exprAsBinaryExpr->lhs, symbolTable);
        const std::vector<syrec::VariableAccess::ptr> notUsableCandidatesOfRhs = determineSignalPartsNotUsableAsPotentialReplacementCandidates(*exprAsBinaryExpr->rhs, symbolTable);

        for (const syrec::VariableAccess::ptr& notUsableCandidateOfRhs : notUsableCandidatesOfRhs) {
            if (std::all_of(notUsableCandidatesOfLhs.cbegin(), notUsableCandidatesOfLhs.cend(), [&notUsableCandidateOfRhs, &symbolTable](const syrec::VariableAccess::ptr& notUsableCandidateOfLhs) { return !areSignalAccessesSyntacticallyEquivalent(*notUsableCandidateOfLhs, *notUsableCandidateOfRhs, symbolTable); })) {
                notUsableCandidatesOfLhs.emplace_back(notUsableCandidateOfRhs);
            }
        }
        return notUsableCandidatesOfLhs;
    }
    if (const auto& exprAsShiftExpr = dynamic_cast<const syrec::ShiftExpression*>(&expr); exprAsShiftExpr) {
        return determineSignalPartsNotUsableAsPotentialReplacementCandidates(*exprAsShiftExpr->lhs, symbolTable);
    }
    if (const auto& exprAsVariableExpr = dynamic_cast<const syrec::VariableExpression*>(&expr); exprAsVariableExpr) {
        if (symbolTable.canSignalBeAssignedTo(exprAsVariableExpr->var->var->name)) {
            return {exprAsVariableExpr->var};
        }
    }
    return {};
}


constexpr bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::shouldLogMessageBePrinted() {
    #ifndef NDEBUG
    return true;
    #else
    return false;
    #endif
}

std::string noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::stringifyChosenOperandForLogMessage(Decision::ChoosenOperand chosenOperand) {
    switch (chosenOperand) {
        case Decision::ChoosenOperand::Left:
            return "LEFT";
        case Decision::ChoosenOperand::Right:
            return "RIGHT";
        case Decision::ChoosenOperand::None:
            return "NONE";
        default:
            return "UNKNOWN";
    }
}

std::string noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::stringifyRepetitionOfChoice(Decision::ChoiceRepetition setRepetitionOfChoice) {
    switch (setRepetitionOfChoice) {
        case Decision::ChoiceRepetition::None:
            return "NONE";
        case Decision::ChoiceRepetition::UntilReset:
            return "UNTIL_RESET";
        case Decision::ChoiceRepetition::Always:
            return "ALWAYS";
        default:
            return "UNKNOWN";
    }
}


void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logDecision(const DecisionReference& madeDecision) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }
#ifndef NDEBUG
    logMessage(fmt::format("Decision @ operation node {:d} choose operand {:s} | Decision repetition flag: {:s} \n", madeDecision->operationNodeId, stringifyChosenOperandForLogMessage(madeDecision->choosenOperand), stringifyRepetitionOfChoice(madeDecision->shouldChoiceBeRepeated)));
#else
    return;
#endif
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logConflict(std::size_t operationNodeId, Decision::ChoosenOperand operandCausingConflict, const syrec::VariableAccess& signalAccessCausingConflict, const std::optional<std::size_t>& idOfEarliestDecisionInvolvedInConflict) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }

#ifndef NDEBUG
    const std::size_t printableIdOfEarliestOperationNodeInvolvedInConflict = idOfEarliestDecisionInvolvedInConflict.value_or(0);
    logMessage(fmt::format("Conflict @ operation node {:d} detected by usage of operand {:s} => signal access {:s} overlaps decision made in operation node {:d}\n", operationNodeId, stringifyChosenOperandForLogMessage(operandCausingConflict), signalAccessCausingConflict.var->name, printableIdOfEarliestOperationNodeInvolvedInConflict));
#else
    return;
#endif
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logStartOfProcessingOfOperationNode(std::size_t operationNodeId) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }

#ifndef NDEBUG
    logMessage(fmt::format("START Processing operation node {:d}\n", operationNodeId));
#else
    return;
#endif
    
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logEndOfProcessingOfOperationNode(std::size_t operationNodeId) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }
#ifndef NDEBUG
    logMessage(fmt::format("END Processing operation node {:d}\n", operationNodeId));
#else
    return;
#endif
    
}


void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logBacktrackingResult(std::size_t operationNodeIdAtStartOfBacktracking, std::size_t nextOperationNodeAfterBacktrackingFinished) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }
#ifndef NDEBUG
    logMessage(fmt::format("Backtracking started @ operation node with id {:d} | finished @ operation node with id {:d} as next to be processed\n", operationNodeIdAtStartOfBacktracking, nextOperationNodeAfterBacktrackingFinished));
#else
    return;
#endif
    
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logMarkingOfOperationNodeAsSourceOfConflict(std::size_t operationNodeId) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }
#ifndef NDEBUG
    logMessage(fmt::format("Marking operation node {:d} as source of conflict\n", operationNodeId));
#else
    return;
#endif

}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logMessage(const std::string& msg) {
#ifndef NDEBUG
    fmt::print(stdout, msg);
#else
    return;
#endif
    
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logCreationOfSubstitutionOfOperandOfOperationNode(std::size_t operationNodeId, Decision::ChoosenOperand substitutedOperand, const syrec::VariableAccess& generatedSubstitution) {
#ifndef NDEBUG
    logMessage(fmt::format("{:s} operand in operation node {:d} was replaced with {:s}\n", stringifyChosenOperandForLogMessage(substitutedOperand), operationNodeId, generatedSubstitution.var->name));
#else
    return;
#endif
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logLearnedConflict(std::size_t operationNodeId, Decision::ChoosenOperand learnedConflictingChoiceOfOperand) {
#ifndef NDEBUG
    logMessage(fmt::format("Remembering conflict @ operation node {:d} due to choice of operand {:s}\n", operationNodeId, stringifyChosenOperandForLogMessage(learnedConflictingChoiceOfOperand)));
#else
    return;
#endif
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logReplayOfAssignmentConflictDueToOverlapWithNoneDataDependency(std::size_t operationNodeIdWhereConflictCheckWasInitiated, std::size_t operationNodeWhereConflictDuringReplayWasDetected, const syrec::VariableAccess::ptr& noneDataDependencyWithOverlappingAssignment, std::size_t idOfOperationNodeBeingOriginOfInheritanceChainForActiveAssignment, Decision::ChoosenOperand chosenOperandAtOperationNodeOfOverlappingActiveAssignment) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }

#ifndef NDEBUG
    logMessage(fmt::format("Conflict @ operation node {:d} detected during check for overlap with active assignment in data dependency {:d} => signal access {:s} overlaps with decision made in operation node {:d} to chose operand {:s}\n", operationNodeIdWhereConflictCheckWasInitiated, operationNodeWhereConflictDuringReplayWasDetected, noneDataDependencyWithOverlappingAssignment->var->name, idOfOperationNodeBeingOriginOfInheritanceChainForActiveAssignment, stringifyChosenOperandForLogMessage(chosenOperandAtOperationNodeOfOverlappingActiveAssignment)));
#else
    return;
#endif
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logReplayOfAssignmentConflictDueToOverlapWithDataDependency(std::size_t operationNodeIdWhereConflictCheckWasInitiated, std::size_t operationNodeWhereConflictDuringReplayWasDetected, Decision::ChoosenOperand chosenOperandAtDataDependencyWhereOverlapWasDetectedDuringReplay, std::size_t idOfOperationNodeBeingOriginOfInheritanceChainForActiveAssignment, Decision::ChoosenOperand chosenOperandAtOperationNodeOfOverlappingActiveAssignment) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }

#ifndef NDEBUG
    logMessage(fmt::format("Conflict @ operation node {:d} detected during check for overlap with active assignment in data dependency to be replayed => decision to chose operand {:s} in operation node {:d} overlaps with decision made in operation node {:d} to chose operand {:s}\n", operationNodeIdWhereConflictCheckWasInitiated, stringifyChosenOperandForLogMessage(chosenOperandAtDataDependencyWhereOverlapWasDetectedDuringReplay), operationNodeWhereConflictDuringReplayWasDetected, idOfOperationNodeBeingOriginOfInheritanceChainForActiveAssignment, stringifyChosenOperandForLogMessage(chosenOperandAtOperationNodeOfOverlappingActiveAssignment)));
#else
    return;
#endif
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logReplayOfAssignmentConflictDueToOverlapWithDataDependencyAndConflictOriginChoiceBasedOnInheritanceChainLength(std::size_t operationNodeId, Decision::ChoosenOperand chosenOperand, std::size_t lengthOfInheritanceChainAtCurrentOperationNode, std::size_t idOfOperationNodeWhereOverlappingSignalPartsWereFound, std::size_t lengthOfInheritanceChainAtOperationNodeWhereOverlappingSignalPartsWereFound) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }

#ifndef NDEBUG
    if (lengthOfInheritanceChainAtCurrentOperationNode < lengthOfInheritanceChainAtOperationNodeWhereOverlappingSignalPartsWereFound) {
        logMessage(fmt::format("Conflict @ operation node {:d} detected because chosen operand {:s} (at operation node {:d}) had an inheritance chain of the length {:d} while the overlapping signal parts @ operation node {:d} had an inheritance chain of length {:d}\n", operationNodeId, stringifyChosenOperandForLogMessage(chosenOperand), operationNodeId, lengthOfInheritanceChainAtCurrentOperationNode, idOfOperationNodeWhereOverlappingSignalPartsWereFound, lengthOfInheritanceChainAtOperationNodeWhereOverlappingSignalPartsWereFound));
    } else {
        logMessage(fmt::format("Conflict @ operation node {:d} detected because chosen operand {:s} (at operation node {:d}) had an inheritance chain of the length {:d} while the overlapping signal parts @ operation node {:d} had an inheritance chain of length {:d}\n", idOfOperationNodeWhereOverlappingSignalPartsWereFound, stringifyChosenOperandForLogMessage(chosenOperand), operationNodeId, lengthOfInheritanceChainAtCurrentOperationNode, idOfOperationNodeWhereOverlappingSignalPartsWereFound, lengthOfInheritanceChainAtOperationNodeWhereOverlappingSignalPartsWereFound));
    }
#else
    return;
#endif
}


void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logCreationOfSubstitutionOfExprOfOperationNode(std::size_t operationNodeId, const std::string& replacementSignalIdent, bool wasExistingEntryUpdated) {
#ifndef NDEBUG
    if (wasExistingEntryUpdated) {
        logMessage(fmt::format("Updated existing replacement (defined by assignment to replacement signal {:s}) for whole expression of operation node with id {:d}\n", replacementSignalIdent, operationNodeId));
    } else {
        logMessage(fmt::format("Created replacement signal {:s} for whole expression of operation node with id {:d}\n", replacementSignalIdent, operationNodeId));
    }
#else
    return;
#endif
}

// TODO IMPORTANT - Sub assignment generation at topmost assignment node should not happen if the sub-assignments with the assigned to signal parts of the topmost assignment can be created
// TODO FURTHER - Replacement generation tests with generation of multiple assignments


// TODO: If the synthesis would support boxing, the replacement generated in this function could use smaller bitwidth than the one derived from the assigned to signal of the original assignment lhs operand
// TODO: Check whether replacement of whole expressions is implemented
// TODO: Inversion of data dependency overlapping with active assignment problem STILL REQUIRES IMPLEMENTATION
// TODO: Correct handling of transformation of two subsequent subtraction operations still requires checks whether correctly implementation and probabily does not work with the current backtracking implementation/replacement generation
// TODO: Implement conflicts being allowed at intermediate nodes by remembering which operand was chosen and from which operation node it was inherited (we should probably store the pointer of the chosen operand instead of the enum value)
// TODO: When replacing an operand with a replacement, should we also clear any existing learned conflicts for that operand in the operation node ?
noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionResult noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::makeDecisionFor(std::size_t operationNodeId, const OperationNodeSimplificationResult& lhsOperandSimplificationResult, syrec_operation::operation definedOperationOfOperationNode, const OperationNodeSimplificationResult& rhsOperandSimplificationResult, const std::optional<std::size_t>& idOfLastActiveAssignmentPriorToProcessingOfLhsOperand, const std::optional<std::size_t>& idOfLastActiveAssignmentPriorToProcessingOfRhsOperand, const SignalValueLookupCallback& signalValueLookupCallback) {
    const std::optional<syrec::Expression::ptr>& lhsOperandAsExpr         = lhsOperandSimplificationResult.getResultAsExpr();
    std::optional<syrec::VariableAccess::ptr>    lhsOperandAsSignalAccess = lhsOperandSimplificationResult.getResultAsSignalAccess();

    const std::optional<syrec::Expression::ptr>& rhsOperandAsExpr         = rhsOperandSimplificationResult.getResultAsExpr();
    std::optional<syrec::VariableAccess::ptr>    rhsOperandAsSignalAccess = rhsOperandSimplificationResult.getResultAsSignalAccess();

    DecisionReference                                                      previousDecisionForReferencedOperationNode = tryGetOrConstructDefaultDecisionForOperationNode(operationNodeId).value_or(nullptr);
    if (!previousDecisionForReferencedOperationNode) {
        return DecisionResult::fromUnknownResult(UnknownResultReason::Other);
    }

    const bool               isChosenOperandPreselected = previousDecisionForReferencedOperationNode->shouldChoiceBeRepeated == Decision::ChoiceRepetition::UntilReset;
    Decision::ChoosenOperand chosenOperand = previousDecisionForReferencedOperationNode->choosenOperand;
    if (previousDecisionForReferencedOperationNode->shouldChoiceBeRepeated != Decision::ChoiceRepetition::Always) {
        if (previousDecisionForReferencedOperationNode->shouldChoiceBeRepeated == Decision::ChoiceRepetition::None) {
            chosenOperand = Decision::ChoosenOperand::None;
            previousDecisionForReferencedOperationNode->choosenOperand = chosenOperand;
        }
        else {
            previousDecisionForReferencedOperationNode->shouldChoiceBeRepeated = Decision::ChoiceRepetition::None;    
        }
    }
    previousDecisionForReferencedOperationNode->inheritedOperandDataForChoice = nullptr;

    const std::optional<ExpressionTraversalHelper::OperationNodeReference> operationNodeReferenceForId                                      = expressionTraversalHelper->getOperationNodeById(operationNodeId);
    bool                                                                   detectedConflictByExistenceOfOverlappingAssignmentWithLhsOperand = false;
    bool                                                                   detectedConflictByExistenceOfOverlappingAssignmentWithRhsOperand = false;

    // We use the next to flags to prevent the creation of a replacement for an already existing replacement of a leaf-node operand in the current operation node
    bool wasOriginalLhsOperandModified = false;
    bool wasOriginalRhsOperandModified = false;
    if (lhsOperandAsSignalAccess.has_value() && lhsOperandSimplificationResult.wasResultManuallyCreated()) {
        // TODO: Use these updated search spaces in other functions
        // TODO: We apply a sort-of heuristic here is the generation of replacements is supported, by replacing the operand and not consider the possibility whether another choice at the conflict operation node where the overlap was defined would be possible? Is this ok?
        std::vector<TemporaryAssignmentsContainer::SearchSpaceIntervalBounds> searchSpacesToConsiderForActiveAssignments;
        searchSpacesToConsiderForActiveAssignments.reserve(2);
        searchSpacesToConsiderForActiveAssignments.emplace_back(TemporaryAssignmentsContainer::SearchSpaceIntervalBounds(0, operationNodeId));
        searchSpacesToConsiderForActiveAssignments.emplace_back(TemporaryAssignmentsContainer::SearchSpaceIntervalBounds(operationNodeReferenceForId->get()->rhsOperand.operationNodeId.value_or(SIZE_MAX), SIZE_MAX));
        detectedConflictByExistenceOfOverlappingAssignmentWithLhsOperand = generatedAssignmentsContainer->getOverlappingActiveAssignmentForSignalAccess(**lhsOperandAsSignalAccess, searchSpacesToConsiderForActiveAssignments, *symbolTableReference).has_value();

        if (detectedConflictByExistenceOfOverlappingAssignmentWithLhsOperand) {
            if (const syrec::Expression::ptr containerExprForSignalAccessLeaf = std::make_shared<syrec::VariableExpression>(*lhsOperandAsSignalAccess); containerExprForSignalAccessLeaf) {
                if (const std::optional<syrec::VariableAccess::ptr> generatedReplacementForLhsOperand = createReplacementForLeafNodeOperand(operationNodeId, Decision::ChoosenOperand::Left, containerExprForSignalAccessLeaf, signalValueLookupCallback); generatedReplacementForLhsOperand.has_value()) {
                    lhsOperandAsSignalAccess                                         = generatedReplacementForLhsOperand;
                    detectedConflictByExistenceOfOverlappingAssignmentWithLhsOperand = false;
                    wasOriginalLhsOperandModified                                    = true;
                }   
            }
        }
    }
    if (rhsOperandAsSignalAccess.has_value() && rhsOperandSimplificationResult.wasResultManuallyCreated()) {
        // TODO: Use these updated search spaces in other functions but should already be done
        // TODO: We apply a sort-of heuristic here is the generation of replacements is supported, by replacing the operand and not consider the possibility whether another choice at the conflict operation node where the overlap was defined would be possible? Is this ok?
        std::vector<TemporaryAssignmentsContainer::SearchSpaceIntervalBounds> searchSpacesToConsiderForActiveAssignments;
        searchSpacesToConsiderForActiveAssignments.reserve(2);
        searchSpacesToConsiderForActiveAssignments.emplace_back(TemporaryAssignmentsContainer::SearchSpaceIntervalBounds(0, operationNodeId));
        searchSpacesToConsiderForActiveAssignments.emplace_back(TemporaryAssignmentsContainer::SearchSpaceIntervalBounds(operationNodeReferenceForId->get()->lhsOperand.operationNodeId.value_or(SIZE_MAX), operationNodeReferenceForId->get()->rhsOperand.operationNodeId.value_or(SIZE_MAX)));
        detectedConflictByExistenceOfOverlappingAssignmentWithRhsOperand = generatedAssignmentsContainer->getOverlappingActiveAssignmentForSignalAccess(**rhsOperandAsSignalAccess, searchSpacesToConsiderForActiveAssignments, *symbolTableReference).has_value();

        if (detectedConflictByExistenceOfOverlappingAssignmentWithRhsOperand) {
            if (const syrec::Expression::ptr containerExprForSignalAccessLeaf = std::make_shared<syrec::VariableExpression>(*rhsOperandAsSignalAccess); containerExprForSignalAccessLeaf) {
                if (const std::optional<syrec::VariableAccess::ptr> generatedReplacementForRhsOperand = createReplacementForLeafNodeOperand(operationNodeId, Decision::ChoosenOperand::Right, containerExprForSignalAccessLeaf, signalValueLookupCallback); generatedReplacementForRhsOperand.has_value()) {
                    rhsOperandAsSignalAccess                                         = generatedReplacementForRhsOperand;
                    detectedConflictByExistenceOfOverlappingAssignmentWithRhsOperand = false;
                    wasOriginalRhsOperandModified                                    = true;
                }
            }
        }
    }
    const std::vector<std::size_t> dataDependenciesAsIdsOfDependentAssignmentsOfLhsOperand = (lhsOperandAsSignalAccess.has_value() && !lhsOperandSimplificationResult.wasResultManuallyCreated()) ? std::vector(1, lhsOperandSimplificationResult.getIdOfGeneratedAssignment().value()) : lhsOperandSimplificationResult.getDataDependenciesAsIdsOfDependentAssignments();
    const std::vector<std::size_t> dataDependenciesAsIdsOfDependentAssignmentsOfRhsOperand = (rhsOperandAsSignalAccess.has_value() && !rhsOperandSimplificationResult.wasResultManuallyCreated()) ? std::vector(1, rhsOperandSimplificationResult.getIdOfGeneratedAssignment().value()) : rhsOperandSimplificationResult.getDataDependenciesAsIdsOfDependentAssignments();

    // TODO: Handling of repetition of choice NONE when generation of replacements is disabled
    // Note: This conditional (the function canAlternativeByChosenInOperationNode) also handles the case that the two operands are leaf nodes and could potentially overlap and also handles the cases that the potentially chosen operand is not defined again in the other operands expression
    const std::optional<syrec_operation::operation> matchingAssignmentCounterpartForDefinedOperation = syrec_operation::getMatchingAssignmentOperationForOperation(definedOperationOfOperationNode);
    if (!isChosenOperandPreselected && chosenOperand == Decision::ChoosenOperand::None && matchingAssignmentCounterpartForDefinedOperation.has_value() && !(detectedConflictByExistenceOfOverlappingAssignmentWithLhsOperand || detectedConflictByExistenceOfOverlappingAssignmentWithRhsOperand)) {
        if (lhsOperandAsSignalAccess.has_value() && ((rhsOperandAsSignalAccess.has_value() && canAlternativeBeChosenInOperationNode(operationNodeId, Decision::ChoosenOperand::Left, **lhsOperandAsSignalAccess, **rhsOperandAsSignalAccess, *symbolTableReference)) 
            || (rhsOperandAsExpr.has_value() && canAlternativeBeChosenInOperationNode(operationNodeId, Decision::ChoosenOperand::Left, **lhsOperandAsSignalAccess, **rhsOperandAsExpr, *symbolTableReference)))) {
            
            chosenOperand = Decision::ChoosenOperand::Left;
            const TemporaryAssignmentsContainer::OrderedAssignmentIdContainer transformedRhsExprDataDependenciesContainer(dataDependenciesAsIdsOfDependentAssignmentsOfRhsOperand.cbegin(), dataDependenciesAsIdsOfDependentAssignmentsOfRhsOperand.cend());
            if (const std::optional<OverlappingSignalAccessDuringReplayOrInversionResult>& searchResultForOverlappingSignalAccessForLhsOperandInRhsDataDependencies = areAssignedToSignalPartsAccessedDuringReplayOrInversionOfDataDependencies(operationNodeId, Decision::ChoosenOperand::Left, **lhsOperandAsSignalAccess, transformedRhsExprDataDependenciesContainer); searchResultForOverlappingSignalAccessForLhsOperandInRhsDataDependencies.has_value()) {
                if (!(searchResultForOverlappingSignalAccessForLhsOperandInRhsDataDependencies->overlapSearchResult & OverlapSearchResult::NoneFound)) {
                    if (!lhsOperandSimplificationResult.wasResultManuallyCreated()) {
                        handleConflictCausedByOverlapOfInactiveDataDependencyWithInheritedChosenOperand(operationNodeId, Decision::ChoosenOperand::Left, *lhsOperandSimplificationResult.getIdOfGeneratedAssignment(), *searchResultForOverlappingSignalAccessForLhsOperandInRhsDataDependencies->idOfLastAssignmentInInheritanceChainWithOverlappingSignalParts);
                        return DecisionResult::fromUnknownResult(UnknownResultReason::Conflict);   
                    }
                    chosenOperand = Decision::ChoosenOperand::None;
                }
            } else {
                return DecisionResult::fromUnknownResult(UnknownResultReason::Other);
            }
        }
        if ((rhsOperandAsSignalAccess.has_value() && ((lhsOperandAsSignalAccess.has_value() && canAlternativeBeChosenInOperationNode(operationNodeId, Decision::ChoosenOperand::Right, **rhsOperandAsSignalAccess, **lhsOperandAsSignalAccess, *symbolTableReference)) 
            || (lhsOperandAsExpr.has_value() && canAlternativeBeChosenInOperationNode(operationNodeId, Decision::ChoosenOperand::Right, **rhsOperandAsSignalAccess, **lhsOperandAsExpr, *symbolTableReference))))) {
            constexpr Decision::ChoosenOperand potentialOperandChoiceForAlternative = Decision::ChoosenOperand::Right;
            /*
             * It could happen that with our choice of the operand that shall be used as the assigned to signal parts in the assignment created at the current operation node (and was inherited from one of its child nodes) that said signal parts are also used in one of the data dependencies and would again be accessed during the
             * replay of said data dependency and would now access a value that differs from the one used at the time of the creation of the assignment that resulted in the data dependency.
             * Example:
             *
             * d += (c + ((a - (b + 2)) * ((b + 2) + 2)))
             * This would create the following assignments in order:
             * I.   b += 2
             * II.  a -= b
             * III. b -= 2
             * IV.  b += 2
             * V.   b += 2
             * VI.  c += (a * b)
             *
             * If we would replay the data dependencies of the operand 'a' (i.e. the assignment I.) the replay of assignment I. would try to perform an assignment to the signal 'b' which was also modified in assignment IV. and V. and thus has no longer the initial
             * value that it had when assignment I. was created
             *
             */
            bool canRhsOperandBeConsideredBasedOnNoOverlapOfAssignedSignalPartsWithAnyInactiveDataDependencyOfFutureDataDependencies = true;
            const TemporaryAssignmentsContainer::OrderedAssignmentIdContainer transformedLhsExprDataDependenciesContainer(dataDependenciesAsIdsOfDependentAssignmentsOfLhsOperand.cbegin(), dataDependenciesAsIdsOfDependentAssignmentsOfLhsOperand.cend());
            if (const std::optional<OverlappingSignalAccessDuringReplayOrInversionResult>& searchForOverlappingSignalAccessForRhsOperandInLhsDataDependencies = areAssignedToSignalPartsAccessedDuringReplayOrInversionOfDataDependencies(operationNodeId, Decision::ChoosenOperand::Right, **rhsOperandAsSignalAccess, transformedLhsExprDataDependenciesContainer); searchForOverlappingSignalAccessForRhsOperandInLhsDataDependencies.has_value()) {
                if (!(searchForOverlappingSignalAccessForRhsOperandInLhsDataDependencies->overlapSearchResult & OverlapSearchResult::NoneFound)) {
                    if (!rhsOperandSimplificationResult.wasResultManuallyCreated()) {
                        handleConflictCausedByOverlapOfInactiveDataDependencyWithInheritedChosenOperand(operationNodeId, potentialOperandChoiceForAlternative, *rhsOperandSimplificationResult.getIdOfGeneratedAssignment(), *searchForOverlappingSignalAccessForRhsOperandInLhsDataDependencies->idOfLastAssignmentInInheritanceChainWithOverlappingSignalParts);
                        return DecisionResult::fromUnknownResult(UnknownResultReason::Conflict);
                    }
                    canRhsOperandBeConsideredBasedOnNoOverlapOfAssignedSignalPartsWithAnyInactiveDataDependencyOfFutureDataDependencies = false;
                }
            } else {
                return DecisionResult::fromUnknownResult(UnknownResultReason::Other);
            }   

            /*
             * Due to our preference the reuse existing assignment, we will switch the chosen operand that is currently set to be the lhs operand to the right one, if the signal access of the former was not inherited from an assignment
             * while the rhs operand was. This can of course only be done if the operation defined for the current operation node is also commutative.
             */
            if (canRhsOperandBeConsideredBasedOnNoOverlapOfAssignedSignalPartsWithAnyInactiveDataDependencyOfFutureDataDependencies) {
                if (syrec_operation::isCommutative(definedOperationOfOperationNode)) {
                    if (chosenOperand == Decision::ChoosenOperand::Left) {
                        if (lhsOperandSimplificationResult.wasResultManuallyCreated() && !rhsOperandSimplificationResult.wasResultManuallyCreated()) {
                            chosenOperand = potentialOperandChoiceForAlternative;
                        }
                    } else {
                        chosenOperand = potentialOperandChoiceForAlternative;
                    }
                } else if (chosenOperand == Decision::ChoosenOperand::None && definedOperationOfOperationNode == syrec_operation::operation::Subtraction && internalConfig.transformationOfSubtractionAndAdditionOperandsForSubAssignmentCreationEnabled) {
                    /*
                    * If no operand was chosen at this point we can try and perform the following two transformations:
                    * I.   (a - (b - c)) => (a + (c - b))
                    * II.  (a + (b - c)) => (a - (c - b))
                    *
                    * If any of the two transformations can be applied, we also have to update the operation of the parent node.
                    */
                    if (const std::optional<std::size_t> idOfParentOperationNode = operationNodeReferenceForId->get()->parentNodeId; idOfParentOperationNode.has_value()) {
                        if (const std::optional<ExpressionTraversalHelper::OperationNodeReference> parentNodeOfOperationNode = expressionTraversalHelper->getOperationNodeById(*idOfParentOperationNode); parentNodeOfOperationNode.has_value() && parentNodeOfOperationNode->get()->rhsOperand.operationNodeId.value_or(0) == operationNodeId) {
                            /*
                             * We opt to not modify the operand data, order or defined operation at the operation node since the switch of the operation is only relevant in the decision making process.
                             */
                            if (const std::optional<syrec_operation::operation> definedOperationAtParentOperationNodeConsideringInversionFlag = parentNodeOfOperationNode->get()->getOperationConsideringWhetherMarkedAsInverted(); definedOperationAtParentOperationNodeConsideringInversionFlag.has_value()
                                && (*definedOperationAtParentOperationNodeConsideringInversionFlag == syrec_operation::operation::Subtraction || *definedOperationAtParentOperationNodeConsideringInversionFlag == syrec_operation::operation::Addition)) {
                                parentNodeOfOperationNode->get()->enabledIsOneTimeOperationInversionFlag();
                                chosenOperand = potentialOperandChoiceForAlternative;
                            }
                        }
                    } else if (topmostAssignmentOperation.has_value() && operationNodeId == expressionTraversalHelper->getOperationNodeIdOfFirstEntryInQueue().value_or(0)) {
                        /*
                            * Both of the previously mentioned transformation can also be applied in the topmost operation node but now depend on the defined assignment operation instead of the operation of the parent operation node.
                            * I.   a -= (b - c) => a += (c - b)
                            * II.  a += (b - c) => a -= (c - b)
                            */
                        if (*topmostAssignmentOperation == syrec_operation::operation::MinusAssign) {
                            chosenOperand              = potentialOperandChoiceForAlternative;
                            topmostAssignmentOperation = syrec_operation::operation::AddAssign;
                        } else if (*topmostAssignmentOperation == syrec_operation::operation::AddAssign) {
                            chosenOperand              = potentialOperandChoiceForAlternative;
                            topmostAssignmentOperation = syrec_operation::operation::MinusAssign;
                        }
                    }
                }    
            }
        }
    }
    
    if (!isChosenOperandPreselected && chosenOperand == Decision::ChoosenOperand::None && matchingAssignmentCounterpartForDefinedOperation.has_value() && determinedBitWidthOfAssignmentToSimplify.has_value()) {
        constexpr Decision::ChoosenOperand operandSelectableByFirstAlternative = Decision::ChoosenOperand::Left;
        // Signal access operands can only be replaced in operation nodes with only leaf nodes
        if (lhsOperandAsSignalAccess.has_value() && lhsOperandSimplificationResult.wasResultManuallyCreated() && !wasOriginalLhsOperandModified) {
            if (const syrec::Expression::ptr containerExprForSignalAccessLeaf = std::make_shared<syrec::VariableExpression>(*lhsOperandAsSignalAccess); containerExprForSignalAccessLeaf) {
                if (const std::optional<syrec::VariableAccess::ptr> generatedReplacementForLhsOperand = createReplacementForLeafNodeOperand(operationNodeId, operandSelectableByFirstAlternative, containerExprForSignalAccessLeaf, signalValueLookupCallback); generatedReplacementForLhsOperand.has_value()) {
                    lhsOperandAsSignalAccess                                         = generatedReplacementForLhsOperand;
                    chosenOperand                                                    = operandSelectableByFirstAlternative;
                    detectedConflictByExistenceOfOverlappingAssignmentWithLhsOperand = false;
                }
            }
        } else if (lhsOperandAsExpr.has_value()) {
            /*
             * Any expression created here should have a bitwidth equal to the one assigned to signal parts, thus we can omit any checks or premature optimizations for the bitwidth of the to be generated replacement.
             * Furthermore, we should only generated replacements for non-compile time numeric expressions since any other type of expression should have already been replaced with their replacement during the processing of said expression
             */
            if (const std::shared_ptr<syrec::NumericExpression> lhsOperandAsNumericExpr = std::dynamic_pointer_cast<syrec::NumericExpression>(*lhsOperandAsExpr); lhsOperandAsNumericExpr && !lhsOperandAsNumericExpr->value->isCompileTimeConstantExpression()) {
                if (const std::optional<syrec::VariableAccess::ptr> generatedReplacementForLhsOperand = createReplacementForLeafNodeOperand(operationNodeId, operandSelectableByFirstAlternative, lhsOperandAsNumericExpr, signalValueLookupCallback); generatedReplacementForLhsOperand.has_value()) {
                    lhsOperandAsSignalAccess = generatedReplacementForLhsOperand;
                    chosenOperand            = operandSelectableByFirstAlternative;
                }
            }
        }
        
        if (chosenOperand == Decision::ChoosenOperand::None && syrec_operation::isCommutative(definedOperationOfOperationNode) && !wasOriginalRhsOperandModified) {
            constexpr Decision::ChoosenOperand operandSelectableBySecondAlternative = Decision::ChoosenOperand::Right;
            // Signal access operands can only be replaced in operation nodes with only leaf nodes
            if (rhsOperandAsSignalAccess.has_value() && rhsOperandSimplificationResult.wasResultManuallyCreated()) {
                if (const syrec::Expression::ptr containerExprForSignalAccessLeaf = std::make_shared<syrec::VariableExpression>(*rhsOperandAsSignalAccess); containerExprForSignalAccessLeaf) {
                    if (const std::optional<syrec::VariableAccess::ptr> generatedReplacementForRhsOperand = createReplacementForLeafNodeOperand(operationNodeId, operandSelectableBySecondAlternative, containerExprForSignalAccessLeaf, signalValueLookupCallback); generatedReplacementForRhsOperand.has_value()) {
                        rhsOperandAsSignalAccess                                         = generatedReplacementForRhsOperand;
                        chosenOperand                                                    = operandSelectableBySecondAlternative;
                        detectedConflictByExistenceOfOverlappingAssignmentWithRhsOperand = false;
                    }
                }
            } else if (rhsOperandAsExpr.has_value()) {
                /*
             * Any expression created here should have a bitwidth equal to the one assigned to signal parts, thus we can omit any checks or premature optimizations for the bitwidth of the to be generated replacement.
             * Furthermore, we should only generated replacements for non-compile time numeric expressions since any other type of expression should have already been replaced with their replacement during the processing of said expression
             */
                if (const std::shared_ptr<syrec::NumericExpression> rhsOperandAsNumericExpr = std::dynamic_pointer_cast<syrec::NumericExpression>(*rhsOperandAsExpr); rhsOperandAsNumericExpr && !rhsOperandAsNumericExpr->value->isCompileTimeConstantExpression()) {
                    if (const std::optional<syrec::VariableAccess::ptr> generatedReplacementForRhsOperand = createReplacementForLeafNodeOperand(operationNodeId, operandSelectableBySecondAlternative, rhsOperandAsNumericExpr, signalValueLookupCallback); generatedReplacementForRhsOperand.has_value()) {
                        rhsOperandAsSignalAccess = generatedReplacementForRhsOperand;
                        chosenOperand            = operandSelectableBySecondAlternative;
                    }
                }
            }
        }
    }

    if (detectedConflictByExistenceOfOverlappingAssignmentWithLhsOperand) {
        handleConflict(operationNodeId, Decision::ChoosenOperand::Left, **lhsOperandAsSignalAccess);
        return DecisionResult::fromUnknownResult(UnknownResultReason::Conflict);
    }
    if (detectedConflictByExistenceOfOverlappingAssignmentWithRhsOperand) {
        handleConflict(operationNodeId, Decision::ChoosenOperand::Right, **rhsOperandAsSignalAccess);
        return DecisionResult::fromUnknownResult(UnknownResultReason::Conflict);
    }

    if (chosenOperand != Decision::ChoosenOperand::None) {
        syrec::VariableAccess::ptr assignedToSignalParts;
        syrec::Expression::ptr     assignmentRhsExpr;
        TemporaryAssignmentsContainer::OrderedAssignmentIdContainer dataDependenciesOfGeneratedAssignmentRhs;
        std::optional<std::size_t>                                  idOfAssignmentFromWhichAssignedToSignalPartsAreInheritedFrom;

        if (chosenOperand == Decision::ChoosenOperand::Left) {
            assignedToSignalParts = *lhsOperandAsSignalAccess;
            idOfAssignmentFromWhichAssignedToSignalPartsAreInheritedFrom = lhsOperandSimplificationResult.getIdOfGeneratedAssignment();
            assignmentRhsExpr     = rhsOperandAsExpr.value_or(nullptr);
            if (!assignmentRhsExpr) {
                assignmentRhsExpr = std::make_shared<syrec::VariableExpression>(*rhsOperandAsSignalAccess);
            }
            dataDependenciesOfGeneratedAssignmentRhs.insert(dataDependenciesAsIdsOfDependentAssignmentsOfRhsOperand.cbegin(), dataDependenciesAsIdsOfDependentAssignmentsOfRhsOperand.cend());
        } else {
            assignedToSignalParts = *rhsOperandAsSignalAccess;
            idOfAssignmentFromWhichAssignedToSignalPartsAreInheritedFrom = rhsOperandSimplificationResult.getIdOfGeneratedAssignment();
            assignmentRhsExpr     = lhsOperandAsExpr.value_or(nullptr);
            if (!assignmentRhsExpr) {
                assignmentRhsExpr = std::make_shared<syrec::VariableExpression>(*lhsOperandAsSignalAccess);
            }
            dataDependenciesOfGeneratedAssignmentRhs.insert(dataDependenciesAsIdsOfDependentAssignmentsOfLhsOperand.cbegin(), dataDependenciesAsIdsOfDependentAssignmentsOfLhsOperand.cend());
        }

        if (assignmentRhsExpr) {
            if (const std::optional<OverlappingSignalAccessDuringReplayOrInversionResult> searchResultForOverlappingSignalPartsBetweenActiveAssignmentsAndInactiveDataDependencies = areAssignedToSignalPartsOfAnyActiveAssignmentAccessedDuringReplayOrInversionOfDataDependencies(operationNodeId, chosenOperand, dataDependenciesOfGeneratedAssignmentRhs); searchResultForOverlappingSignalPartsBetweenActiveAssignmentsAndInactiveDataDependencies.has_value()) {
                if (!(searchResultForOverlappingSignalPartsBetweenActiveAssignmentsAndInactiveDataDependencies->overlapSearchResult & OverlapSearchResult::NoneFound)) {
                    handleConflictCausesByReplayOrInversion(operationNodeId, *searchResultForOverlappingSignalPartsBetweenActiveAssignmentsAndInactiveDataDependencies);
                    return DecisionResult::fromUnknownResult(UnknownResultReason::Conflict);
                }
            }
            else {
                return DecisionResult::fromUnknownResult(UnknownResultReason::Other);
            }
            
            if (const std::shared_ptr<syrec::AssignStatement> generatedAssignment = std::make_shared<syrec::AssignStatement>(assignedToSignalParts, *syrec_operation::tryMapAssignmentOperationEnumToFlag(*matchingAssignmentCounterpartForDefinedOperation), assignmentRhsExpr); generatedAssignment) {
                if (const std::optional<std::size_t>& idOfGeneratedAssignment = generatedAssignmentsContainer->storeActiveAssignment(generatedAssignment, idOfAssignmentFromWhichAssignedToSignalPartsAreInheritedFrom, dataDependenciesOfGeneratedAssignmentRhs, operationNodeId, std::nullopt); idOfGeneratedAssignment.has_value()) {
                    if (!std::all_of(dataDependenciesOfGeneratedAssignmentRhs.cbegin(), dataDependenciesOfGeneratedAssignmentRhs.cend(), [&](const std::size_t dataDependency) { return generatedAssignmentsContainer->invertAssignmentAndDataDependencies(dataDependency); })) {
                        return DecisionResult::fromUnknownResult(UnknownResultReason::Other);
                    }
                    previousDecisionForReferencedOperationNode->choosenOperand = chosenOperand;

                    /*
                     * Since we try to learn conflicts at operation nodes where either or both operands are leaf nodes (learning a conflict at an operation node with no leaf nodes could prevent the usage of a
                     * now valid operand propagated from node N1 matching a previous conflict found in N2 using the same operand), decisions where an operand was inherited (i.e. the original operand was an expression
                     * was now transformed to an assignment), will not be considered as a source of a conflict to allow traversal to the child node causing the initial choice that will be propagated to said decision.
                     */
                    if (chosenOperand == Decision::ChoosenOperand::Left && !lhsOperandSimplificationResult.wasResultManuallyCreated()) {
                        previousDecisionForReferencedOperationNode->inheritedOperandDataForChoice = *lhsOperandAsSignalAccess;
                    } else if (chosenOperand == Decision::ChoosenOperand::Right && !rhsOperandSimplificationResult.wasResultManuallyCreated()) {
                        previousDecisionForReferencedOperationNode->inheritedOperandDataForChoice = *rhsOperandAsSignalAccess;
                    }
                    logDecision(previousDecisionForReferencedOperationNode);
                    return DecisionResult::fromGeneratedAssignment(generatedAssignment, *idOfGeneratedAssignment);
                }
            }
        }
    }
   // FUSE EXPRESSIONS
    const syrec::Expression::ptr generatedExprLhsExpr = lhsOperandAsExpr.has_value() ? *lhsOperandAsExpr : std::make_shared<syrec::VariableExpression>(*lhsOperandAsSignalAccess);
    const syrec::Expression::ptr generatedExprRhsExpr = rhsOperandAsExpr.has_value() ? *rhsOperandAsExpr : std::make_shared<syrec::VariableExpression>(*rhsOperandAsSignalAccess);
    if (generatedExprLhsExpr && generatedExprRhsExpr) {
        std::vector<std::size_t> fusedDataDependencies;
        fusedDataDependencies.reserve(dataDependenciesAsIdsOfDependentAssignmentsOfLhsOperand.size() + dataDependenciesAsIdsOfDependentAssignmentsOfRhsOperand.size());
        // TODO: What if this allocation fails?
        fusedDataDependencies.insert(fusedDataDependencies.end(), dataDependenciesAsIdsOfDependentAssignmentsOfLhsOperand.cbegin(), dataDependenciesAsIdsOfDependentAssignmentsOfLhsOperand.cend());
        fusedDataDependencies.insert(fusedDataDependencies.end(), dataDependenciesAsIdsOfDependentAssignmentsOfRhsOperand.cbegin(), dataDependenciesAsIdsOfDependentAssignmentsOfRhsOperand.cend());

        /*
         * Replacing the topmost expression via a replacement does not lead to any improvement and would only introduce unnecessary additional signals.
         * Furthermore, we assume that the topmost operation node has an id with value 0.
         */
        if (operationNodeId) {
            bool wasExistingReplacementUpdated = false;
            if (const std::optional<std::pair<std::size_t, std::shared_ptr<syrec::AssignStatement>>>& idAndDataOfGeneratedReplacementForWholeExpr = getAndActivateReplacementForOperationNode(operationNodeId, definedOperationOfOperationNode, lhsOperandSimplificationResult, rhsOperandSimplificationResult, &wasExistingReplacementUpdated, signalValueLookupCallback); idAndDataOfGeneratedReplacementForWholeExpr.has_value()) {
                if (!std::all_of(fusedDataDependencies.cbegin(), fusedDataDependencies.cend(), [&](const std::size_t dataDependencyOfFusedExpression) { return generatedAssignmentsContainer->invertAssignmentAndDataDependencies(dataDependencyOfFusedExpression); })) {
                    return DecisionResult::fromUnknownResult(UnknownResultReason::Other);
                }

                const std::shared_ptr<syrec::VariableAccess>& assignedToSignalParts = idAndDataOfGeneratedReplacementForWholeExpr.value().second->lhs;
                /*
                * Since we use the expression traversal helper to determine whether a signal ident refers to an assignable signal in our implementation of a decision, and due to the fact that said
                * lookup is initially built during the generation of the traversal data from the initial assignment right-hand side expression, we need to manually add the generated replacement signal
                * as an assignable signal.
                */
                expressionTraversalHelper->markSignalAsAssignable(assignedToSignalParts->var->name);
                logCreationOfSubstitutionOfExprOfOperationNode(operationNodeId, assignedToSignalParts->var->name, wasExistingReplacementUpdated);
                return DecisionResult::fromGeneratedAssignment(idAndDataOfGeneratedReplacementForWholeExpr.value().second, idAndDataOfGeneratedReplacementForWholeExpr.value().first);
            }
        }

        if (const std::optional<syrec::Expression::ptr> fusedExpression = fuseExpressions(generatedExprLhsExpr, definedOperationOfOperationNode, generatedExprRhsExpr); fusedExpression) {
            logDecision(previousDecisionForReferencedOperationNode);
            return DecisionResult::fromGeneratedExpression(*fusedExpression, fusedDataDependencies);
        }
    }
    return DecisionResult::fromUnknownResult(UnknownResultReason::Other);
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::constructAndRecordDefaultDecision(std::size_t operationNodeId) {
    if (DecisionReference generatedDefaultDecision = constructDefaultDecision(operationNodeId); generatedDefaultDecision) {
        pastDecisions.emplace(generatedDefaultDecision);
        return generatedDefaultDecision;
    }
    return std::nullopt;
}

noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::constructDefaultDecision(std::size_t operationNodeId) {
    return std::make_shared<Decision>(Decision({operationNodeId, 0, Decision::ChoosenOperand::None, Decision::ChoiceRepetition::None, nullptr}));
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OperationNodeSimplificationResult::OwningReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryPerformTransformationOfDecisionResultToOperationNodeSimplificationResultWhenNoConflictWasDetected(std::size_t operationNodeId, const DecisionResult& decisionResult) {
    if (decisionResult.data.has_value()) {
        if (const std::optional<syrec::Expression::ptr>& generatedExpressionByDecision = decisionResult.getGeneratedExpression(); generatedExpressionByDecision.has_value()) {
            return OperationNodeSimplificationResult::createAndOwnNewInstance(OperationNodeSimplificationResult::createFromNonLeafNode(operationNodeId, *generatedExpressionByDecision, decisionResult.dataDependenciesOfGeneratedResult));
        }
        const OperationNodeSimplificationResult::IdAndAssignmentTuple generatedAssignmentData = std::make_pair(*decisionResult.idOfGeneratedAssignment, *decisionResult.getAssignedToSignalParts());
        return OperationNodeSimplificationResult::createAndOwnNewInstance(OperationNodeSimplificationResult::createFromNonLeafNode(operationNodeId, generatedAssignmentData, decisionResult.dataDependenciesOfGeneratedResult));
    }
    if (decisionResult.reasonForUnknownResult.value_or(UnknownResultReason::Other) == UnknownResultReason::Conflict) {
        return std::nullopt;
    }
    return OperationNodeSimplificationResult::createAndOwnNewInstance(OperationNodeSimplificationResult::createAsUnknownResult(UnknownResultReason::Other));
}