#include "core/syrec/parser/optimizations/noAdditionalLineSynthesis/assignment_without_additional_lines_simplifier.hpp"
#include "core/syrec/parser/utils/copy_utils.hpp"
#include "core/syrec/parser/utils/signal_access_utils.hpp"

#ifndef NDEBUG
#include "fmt/format.h"
#endif

/*
 * TODO: IMPORTANT (testcase simplificationWithOnlyReversibleOpsAndUniqueSignalAccessesWithTopmostAssignmentBeingXorCorrectlyHandlesMixedOperationsInRhsExpr) is missing required inversion of assignments
 *
 * TODO: Add as a precondition that no signal accesses overlapping the lhs operand of the initial assignment exists on the rhs which should already be done by the caller but a safety to prevent invalid assignments generated by this simplifier
 * TODO: When inverting all active assignments during processing of operation node, we should not "deactivated" active assignments that operate on the same signal as the chosen one in the operation node - IMPORTANT
 * TODO: Are active assignments added to set determining conflicts
 * TODO: If a decision was prevented by learned conflict the generated expr could be further simplified in the parent operation node (i.e. b += (d - 2) was created when the learned conflict was d and could be simplified to b += d; b -= 2)
 *
 * TODO: If original rhs expr does only consist of invertible operations (with xor only defined for leaf nodes) fallback to expression split
 * TODO: Shift expressions are currently not handled since the shift amount is a number::ptr instead of an expression::ptr
 *
 *
 * TODO: Currently we have a problem to fine a correct metric to decide whether we should perform our "simple" or "complex" simplification algorithm if the assignment only contains reversible operations (its a problem since the "complex" algorithm leads to a larger code size due to a larger number of assignments being created)
 * TODO: IMPORTANT: When a conflict arises we should only remember the conflict at the earliest node to not prevent the reuse of assignment that could lead to conflicts but are "defused" by an assignment higher in the traversal queue
 * TODO: NICE-TO-HAVE: Try to perform constant propagation and further optimizations if value of any signal changes during simplifications
 *
 * TODO: Reordering sequences of assignment statements could lead to further optimization potential, see test case simplificationWithOnlyReversibleOpsAndUniqueSignalAccessHandlesRhsCorrectlyIfRhsCreatesNoAssignmentAndAssignmentOperationIsXorAndTopmostOperationOfRhsIsMinusAndAssignedtoSignalValueIsNotZero
 * TODO: Could the simplification (a - (b + c)) = (a - (c - b)) lead to further optimizations?
 *
 * TODO: Some cases could offer new optimizations: module main(out a(16), inout b(16), in c(16), in d(16)) a += (((b - c) + b) * d) [see simplification of previous point])
 *
 * TODO: IMPORTANT - When processing a rhs of an expression we cannot use any operand use in the lhs expr (how can we do this efficiently, does this check need to be done everytime)
 * TODO: IMPORTANT - Check whether we need to add additional tests for the the tie breaker flag is not specified and the simplified assignments of the original assignment cost less than the simplified ones
 * TODO: IMPORTANT - Check the metric chosen for the weighting, if our topmost expression has a nesting level of two but the simplified ones only have a nesting level of 1 but the latter is inverted once
 * (i.e.) a += ((b + c) + d) being the topmost assignment while the simplified ones are d += (b + c); a ^= d; d -= (b + c). [Also add tests for this]
 * TODO: IMPORTANT - The split of an simplified assignment (i.e. a -= (b + 2)) at the topmost level leads to the sequence a -= b; a -= 2 ... a += b; a += 2
 *  if the split would take place immediately after the creation of the assignment would lead to the sequence a += b; a += 2 ... a -= b; a -= 2
 *
 * TODO: Testcase 'simplifyWithOnlyReversibleOpsButNonUniqueSignalAccessWithAssignOperationBeingAdditionWithDegeneratedLhsSubASTOfLhsOfAssignmentExpr' is an example where the heuristic optimization of - (<subExpr_1> - <subExpr_2>) leads to a worse result
 *
 * TODO: Should the decisions for intermediate operation nodes (i.e. with non-leaf nodes be extendened from the simple left, right distinction to a lookup) ?
 *
 * TODO: IMPORTANT: Rework of conflict handling that conflicting decision could be remade when reset in by a parent decision (check detection of hot path, found earliest conflict node, etc.)
 * TODO: IMPORTANT: Tests that decision are remade not on hot path
 * TODO: IMPORTANT: Assignments using boxing (i.e. operand has bitwidth 5 instead of 4) should not be able to be processed
 * TODO: IMPORTANT: Assignment where the bitwidth is unknown will not use replacements
 */




// TODO: We should probably also validate that the optimized circuit that is created after a successful parse is also correct
// TODO: Correct update of reference counts for simplification of assignments with no additional lines

/*
 * REPLACEMENT GENERATOR TODOS:
 * - Correct reference count updates for new signals
 * - Correct insertion of new signals into symbol table
 * - Correct reference count updates when assignment is simplified (i.e. split into smaller subassignments)
 * - Fixed replacement generator for example ((a + b) + (a + b)) to generate replacement __x ^= a; ... and not __x ^= (a + b) [see test case 'simpleReplacementTest']
 */

/*
 * Ideas for the introduction of replacements:
 * - Replace signal accesses at operation nodes which are the cause of the conflict with a replacement
 * - Replace expressions with replacements (synthesizing the expression y += (a * (b + c)) is more costly than x ^= (b + c); y += (a * x)?
 * - Replacements should at first be looked for in existing signals that are unused in the expression and only if none are available should extra signals be introduced
 */
// TODO: CHECK TEST simplificationWithNoneReversibleOperationWithXorAssignOperationAndTopmostOperationOfRhsBeingAdditionOperationWithLhsGeneratingAssignmentAndRhsGeneratingAssignmentCreatesCorrectAssignment FOR FAILED ROLLBACK
noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::SimplificationResult::OwningReference noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::simplify(const syrec::AssignStatement& assignmentStatement, const SignalValueLookupCallback& signalValueLookupCallback) {
    resetInternals();
    if (!symbolTableReference) {
        return SimplificationResult::createOwningReferenceOf(SimplificationResult::asEmptyResult());
    }

    // TODO: For a binary expression with no nested expressions as operands, should we prefer that a signal access is always the lhs operand
    const std::shared_ptr<syrec::AssignStatement> transformedAssignmentStmt = transformAssignmentPriorToSimplification(assignmentStatement, true);
    if (!transformedAssignmentStmt) {
        return SimplificationResult::createOwningReferenceOf(SimplificationResult::asEmptyResult());
    }

    expressionTraversalHelper->buildTraversalQueue(transformedAssignmentStmt->rhs, *symbolTableReference);
    disableValueLookup();
    const std::vector<syrec::VariableAccess::ptr> replacementCandidateRestrictionsStemmingFromAssignment = defineNotUsableReplacementCandidatesFromAssignmentForGenerator(*transformedAssignmentStmt);
    determinedBitWidthOfAssignmentToSimplify                                                             = determineBitwidthOfSignalAccess(*assignmentStatement.lhs);

    bool                                                               continueProcessingOperationNode = true;
    std::optional<OperationNodeSimplificationResult::OwningReference> simplificationResultOfTopmostOperationNode;
    while (continueProcessingOperationNode) {
        std::optional<ExpressionTraversalHelper::OperationNodeReference> topMostOperationNode = expressionTraversalHelper->getNextOperationNode();

        // TODO: If an expression is created for the rhs we can still try to split it if a binary operation with an assignment counterpart exists
        simplificationResultOfTopmostOperationNode = topMostOperationNode.has_value() ? handleOperationNode(*topMostOperationNode, signalValueLookupCallback) : std::nullopt;
        if (shouldBacktrackDueToConflict()) {
            markSourceOfConflictReached();
            backtrack(topMostOperationNode->get()->id, false);
        } else {
            continueProcessingOperationNode = !simplificationResultOfTopmostOperationNode.has_value();
        }
    }

    if (simplificationResultOfTopmostOperationNode.has_value()) {
        if (!simplificationResultOfTopmostOperationNode->get()->hasKnownValue()) {
            return SimplificationResult::createOwningReferenceOf(SimplificationResult::asEmptyResult());
        }

        const std::optional<syrec::Expression::ptr>& generatedExprForTopmostOperationRhsExpr = simplificationResultOfTopmostOperationNode->get()->getResultAsExpr();
        const std::optional<syrec::VariableAccess::ptr>& generatedLastAssignedToSignalOfRhsExpr  = simplificationResultOfTopmostOperationNode->get()->getResultAsSignalAccess();
        TemporaryAssignmentsContainer::OrderedAssignmentIdContainer dataDependenciesOfTopmostAssignmentStatement;

        syrec::VariableAccess::ptr generatedAssignmentAssignedToSignal = transformedAssignmentStmt->lhs;
        syrec::Expression::ptr     generatedAssignmentRhsExpr;
        if (generatedLastAssignedToSignalOfRhsExpr.has_value()) {
            generatedAssignmentRhsExpr = std::make_shared<syrec::VariableExpression>(*generatedLastAssignedToSignalOfRhsExpr);
            if (const std::optional<std::size_t>& idOfGeneratedAssignmentByTopmostAssignment = simplificationResultOfTopmostOperationNode->get()->getIdOfGeneratedAssignment(); idOfGeneratedAssignmentByTopmostAssignment.has_value()) {
                dataDependenciesOfTopmostAssignmentStatement.emplace(*idOfGeneratedAssignmentByTopmostAssignment);
            }
        } else {
            generatedAssignmentRhsExpr = *generatedExprForTopmostOperationRhsExpr;
        }

        if (const std::shared_ptr<syrec::AssignStatement> generatedAssignment = std::make_shared<syrec::AssignStatement>(generatedAssignmentAssignedToSignal,transformedAssignmentStmt->op,generatedAssignmentRhsExpr); generatedAssignment){
            const std::optional<std::size_t> idOfTopmostAssignment = generatedAssignmentsContainer->storeActiveAssignment(generatedAssignment, std::nullopt, dataDependenciesOfTopmostAssignmentStatement, 0, std::nullopt);
            if (!idOfTopmostAssignment.has_value() || !generatedAssignmentsContainer->invertAssignmentsWithIdInRange(0, idOfTopmostAssignment.value())) {
                return SimplificationResult::createOwningReferenceOf(SimplificationResult::asEmptyResult());
            }
        }
        else {
            return SimplificationResult::createOwningReferenceOf(SimplificationResult::asEmptyResult());
        }
    }
    clearNotUsableReplacementCandidatesFromAssignmentForGenerator(replacementCandidateRestrictionsStemmingFromAssignment);

    bool                                                                   wasAnyAssignmentGeneratedDuringProcessing = true;
    std::vector<TemporaryAssignmentsContainer::AssignmentReferenceVariant> generatedAssignments;
    if (!generatedAssignmentsContainer->getNumberOfAssignments()) {
        if (const std::shared_ptr<syrec::AssignStatement> topMostAssignmentStmtIfNoOptimizationTookPlace = transformedAssignmentStmt ? transformedAssignmentStmt : std::make_shared<syrec::AssignStatement>(assignmentStatement); topMostAssignmentStmtIfNoOptimizationTookPlace) {
            generatedAssignments.emplace_back(topMostAssignmentStmtIfNoOptimizationTookPlace);
            wasAnyAssignmentGeneratedDuringProcessing = false;
        }
    } else {
        generatedAssignments = generatedAssignmentsContainer->getAssignments();
    }

    /*
     * If any assignments where generated by our more "complex" algorithm, try to determine the more viable alternative by comparing the cost of the simplified assignments generated
     * by the more "simple" algorithm (if applicable) to the ones generated by the "complex" one.
     *
     * NOTE: At this point the symbol table entries for the newly generated replacement signals might not exist yet if said signals were created during the current iteration.
     * The internal value lookup will not work for said signals and classes using this lookup must handle this case accordingly.
     */
    generatedAssignments = assignmentTransformer->simplify(generatedAssignments, signalValueLookupCallback);
    if (wasAnyAssignmentGeneratedDuringProcessing) {
        SimplificationResult::OwningReference finalSimplificationResultInCaseAnyAssignmentWereGenerated;
        if (std::optional<SimplificationResult::OwningCopiesOfAssignment> requiredInversionsOfValueResetsAfterUsageOfGeneratedReplacements = generatedAssignmentsContainer->getInvertedAssignmentsUndoingValueResetsOfGeneratedSubstitutions(); requiredInversionsOfValueResetsAfterUsageOfGeneratedReplacements.has_value()) {
            if (std::optional<SimplificationResult::OwningCopiesOfAssignment> owningCopiesOfGeneratedAssignments = createOwningCopiesOfAssignments(generatedAssignments); owningCopiesOfGeneratedAssignments.has_value()) {
                if (std::optional<SimplificationResult::OwningCopiesOfAssignment> requiredValueResetsPriorToUsageOfGeneratedReplacements = generatedAssignmentsContainer->getAssignmentsDefiningValueResetsOfGeneratedSubstitutions(); requiredValueResetsPriorToUsageOfGeneratedReplacements.has_value()) {
                    const syrec::Variable::vec newlyGeneratedReplacementCandidates = substitutionGenerator ? substitutionGenerator->getDefinitionsOfReplacementsCreatedFromNewlyGeneratedSignals() : syrec::Variable::vec();

                    SimplificationResult internalContainerOfSimplificationResult       = SimplificationResult();
                    internalContainerOfSimplificationResult.newlyGeneratedReplacementSignalDefinitions                              = newlyGeneratedReplacementCandidates;
                    internalContainerOfSimplificationResult.generatedAssignments                                                    = std::move(*owningCopiesOfGeneratedAssignments);
                    internalContainerOfSimplificationResult.requiredValueResetsForReplacementsTargetingExistingSignals              = std::move(*requiredValueResetsPriorToUsageOfGeneratedReplacements);
                    internalContainerOfSimplificationResult.requiredInversionsOfValuesResetsForReplacementsTargetingExistingSignals = std::move(*requiredInversionsOfValueResetsAfterUsageOfGeneratedReplacements);

                    finalSimplificationResultInCaseAnyAssignmentWereGenerated          = SimplificationResult::createOwningReferenceOf(std::move(internalContainerOfSimplificationResult));
                }
            }
        }
        if (const std::shared_ptr<syrec::AssignStatement>& transformedAssignmentStmtWithoutAppliedHeuristicsForSubassignmentGeneration = transformAssignmentPriorToSimplification(assignmentStatement, false); transformedAssignmentStmtWithoutAppliedHeuristicsForSubassignmentGeneration) {
            if (SimplificationResult::OwningReference mostViableAlternative = determineMostViableAlternativeBasedOnCost(finalSimplificationResultInCaseAnyAssignmentWereGenerated, transformedAssignmentStmtWithoutAppliedHeuristicsForSubassignmentGeneration, signalValueLookupCallback); mostViableAlternative) {
                return mostViableAlternative;
            }      
        }
    }

    if (std::optional<SimplificationResult::OwningCopyOfAssignment> owningCopyOfTransformedAssignment = transformedAssignmentStmt ? createOwningCopyOfAssignment(*transformedAssignmentStmt) : std::nullopt; owningCopyOfTransformedAssignment.has_value()) {
        return SimplificationResult::createOwningReferenceOf(SimplificationResult::asSingleStatement(std::move(*owningCopyOfTransformedAssignment)));
    }
    return SimplificationResult::createOwningReferenceOf(SimplificationResult::asEmptyResult());
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::resetForUsageInNewModule(const parser::SymbolTable::ptr& activeSymbolTableScope) {
    defineSymbolTable(activeSymbolTableScope);
    reloadGenerateableReplacementSignalName();
}

// START OF NON-PUBLIC FUNCTION IMPLEMENTATIONS
std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OperationNodeSimplificationResult::OwningReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleOperationNode(const ExpressionTraversalHelper::OperationNodeReference& operationNode, const SignalValueLookupCallback& signalValueLookupCallback) {
    logStartOfProcessingOfOperationNode(operationNode->id);
    std::optional<OperationNodeSimplificationResult::OwningReference> simplificationResult;
    if (!operationNode->hasAnyLeafOperandNodes()) {
        simplificationResult = handleOperationNodeWithNoLeafNodes(operationNode, signalValueLookupCallback);
    }
    else if (operationNode->areBothOperandsLeafNodes()) {
        simplificationResult = handleOperationNodeWithOnlyLeafNodes(operationNode, signalValueLookupCallback);
    } else {
        simplificationResult = handleOperationNodeWithOneLeafNode(operationNode, signalValueLookupCallback);
    }
    logEndOfProcessingOfOperationNode(operationNode->id);
    return simplificationResult;
}

// TODO: If the simplification of any non-leaf node did result in a conflict check whether another decision at a previous position is possible, see other functions handling operation node with one leaf node
std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OperationNodeSimplificationResult::OwningReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleOperationNodeWithNoLeafNodes(const ExpressionTraversalHelper::OperationNodeReference& operationNode, const SignalValueLookupCallback& signalValueLookupCallback) {
    std::optional<OperationNodeSimplificationResult::OwningReference>    owningLhsOperandSimplificationResult;
    std::optional<OperationNodeSimplificationResult::OwningReference>    owningRhsOperandSimplificationResult;
    syrec::Expression::ptr                                               expressionToConsiderForDecisionInSecondNode;

    std::size_t idOfLastActiveAssignmentPriorToProcessingOfLhsOperand;
    std::size_t idOfLastActiveAssignmentPriorToProcessingOfRhsOperand;
    bool continueProcessing = true;
    while (continueProcessing) {
        generatedAssignmentsContainer->markCutoffForInvertibleAssignments();
        expressionTraversalHelper->markOperationNodeAsPotentialBacktrackOption(operationNode->id);

        idOfLastActiveAssignmentPriorToProcessingOfLhsOperand        = generatedAssignmentsContainer->getIdOfLastGeneratedAssignment().value_or(0);
        OperationNodeProcessingResult lhsOperandSimplificationResult = processNextOperationNode(signalValueLookupCallback);
        if (lhsOperandSimplificationResult.isResultUnknown()) {
            generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
            return OperationNodeSimplificationResult::createAndOwnNewInstance(OperationNodeSimplificationResult::createAsUnknownResult(UnknownResultReason::Other));
        }
        if (lhsOperandSimplificationResult.derivedConflictInOtherNode) {
            generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
            return std::nullopt;
        }
        owningLhsOperandSimplificationResult = std::move(lhsOperandSimplificationResult.simplificationResult);

        /*
         * If the first non-leaf node created an expression instead of an assignment, we need also need to take this generated expression as well as all active assignments into consideration
         * when processing the second non-leaf-node
         */
        expressionToConsiderForDecisionInSecondNode = owningLhsOperandSimplificationResult->get()->getResultAsExpr().value_or(nullptr);
        considerExpressionInFutureDecisions(expressionToConsiderForDecisionInSecondNode);

        /*
         * TODO: Is this comment correct
         * If we do not quit the processing loop of the second non-leaf operation node, we would only never reprocess the first non-leaf operation node again.
         */
        /*OperationNodeProcessingResult secondOperandProcessingResult = processNextOperationNode(signalValueLookupCallback, true);
        if (secondOperandProcessingResult.derivedConflictInOtherNode || isOperationNodeSourceOfConflict(operationNode->id)) {
            return std::nullopt;
        }*/
        idOfLastActiveAssignmentPriorToProcessingOfRhsOperand        = generatedAssignmentsContainer->getIdOfLastGeneratedAssignment().value_or(0);
        OperationNodeProcessingResult rhsOperandSimplificationResult = processNextOperationNode(signalValueLookupCallback);
        if (rhsOperandSimplificationResult.isResultUnknown()) {
            // TODO: Do we need this rollback or this is already done during the processing of the operation node
            generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
            return OperationNodeSimplificationResult::createAndOwnNewInstance(OperationNodeSimplificationResult::createAsUnknownResult(UnknownResultReason::Other));
        }
        if (rhsOperandSimplificationResult.derivedConflictInOtherNode) {
            generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
            return std::nullopt;
        }
        continueProcessing = rhsOperandSimplificationResult.derivedConflictInThisNode;
        if (!continueProcessing) {
            owningRhsOperandSimplificationResult = std::move(rhsOperandSimplificationResult.simplificationResult);
        }
    }

    const DecisionResult decisionResult = makeDecisionFor(operationNode->id, **owningLhsOperandSimplificationResult, operationNode->operation, **owningRhsOperandSimplificationResult, idOfLastActiveAssignmentPriorToProcessingOfLhsOperand, idOfLastActiveAssignmentPriorToProcessingOfRhsOperand, signalValueLookupCallback);
    revokeConsiderationOfExpressionForFutureDecisions(expressionToConsiderForDecisionInSecondNode);

    if (decisionResult.reasonForUnknownResult.has_value()) {
        generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
    }
    else {
        expressionTraversalHelper->removeOperationNodeAsPotentialBacktrackOperation(operationNode->id);
        generatedAssignmentsContainer->popLastCutoffForInvertibleAssignments();        
    }
    return tryPerformTransformationOfDecisionResultToOperationNodeSimplificationResultWhenNoConflictWasDetected(operationNode->id, decisionResult);
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OperationNodeSimplificationResult::OwningReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleOperationNodeWithOneLeafNode(const ExpressionTraversalHelper::OperationNodeReference& operationNode, const SignalValueLookupCallback& signalValueLookupCallback) {
    expressionTraversalHelper->markOperationNodeAsPotentialBacktrackOption(operationNode->id);
    generatedAssignmentsContainer->markCutoffForInvertibleAssignments();

    const bool                                          wasLhsOperandLeafNode        = operationNode->getLeafNodeOperandId().value() == operationNode->lhsOperand.id;
    const std::optional<syrec::VariableExpression::ptr> dataOfLeafNodeAsVariableExpr = expressionTraversalHelper->getOperandAsVariableExpr(wasLhsOperandLeafNode ? operationNode->lhsOperand.id : operationNode->rhsOperand.id);
    const std::size_t                                   idOfLastActiveAssignmentPriorToProcessingOfLeafNode = generatedAssignmentsContainer->getIdOfLastGeneratedAssignment().value_or(0);

    if (const std::shared_ptr<syrec::VariableExpression> castedExprDefiningDataOfLeafNode = dataOfLeafNodeAsVariableExpr.has_value() && wasLhsOperandLeafNode ? std::dynamic_pointer_cast<syrec::VariableExpression>(*dataOfLeafNodeAsVariableExpr) : nullptr; castedExprDefiningDataOfLeafNode) {
        const std::size_t searchForActiveAssignmentExclusionRangeForLowerBoundDefinedByAssociatedOperationNodeId = operationNode->id;
        const std::size_t searchForActiveAssignmentExclusionRangeForUpperBoundDefinedByAssociatedOperationNodeId = operationNode->rhsOperand.operationNodeId.value_or(SIZE_MAX) - 1;
        if (const std::optional<std::size_t>& idOfAssignmentOverlappingWithGivenSignalAccess = generatedAssignmentsContainer->getOverlappingActiveAssignmentForSignalAccessWithIdNotInRange(*castedExprDefiningDataOfLeafNode->var, searchForActiveAssignmentExclusionRangeForLowerBoundDefinedByAssociatedOperationNodeId, searchForActiveAssignmentExclusionRangeForUpperBoundDefinedByAssociatedOperationNodeId, *symbolTableReference); idOfAssignmentOverlappingWithGivenSignalAccess.has_value()
            && !generatedAssignmentsContainer->existsActiveAssignmentHavingGivenAssignmentAsDataDependency(*idOfAssignmentOverlappingWithGivenSignalAccess)) {
            handleConflict(operationNode->id, Decision::ChoosenOperand::Left, *castedExprDefiningDataOfLeafNode->var);
            return std::nullopt;
        }   
    }

    std::optional<OperationNodeSimplificationResult::OwningReference> simplificationResultOfOperationNodeOperand;
    bool continueProcessingOfNonLeafNode = true;
    while (continueProcessingOfNonLeafNode) {
       OperationNodeProcessingResult resultOfNonLeafNode = processNextOperationNode(signalValueLookupCallback);
        if (resultOfNonLeafNode.isResultUnknown()) {
           generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
            return OperationNodeSimplificationResult::createAndOwnNewInstance(OperationNodeSimplificationResult::createAsUnknownResult(UnknownResultReason::Other));      
        }
        if (resultOfNonLeafNode.derivedConflictInOtherNode) {
           generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
           return std::nullopt;
        }
        simplificationResultOfOperationNodeOperand = std::move(resultOfNonLeafNode.simplificationResult);
        /*
        * We need to perform our conflict check twice, once prior to the processing of the subexpression define in one of the operands of this operation and also
        * after we have processed said subexpression, to determine whether the value of the leaf node was not changed in any of the sub-assignments generated during the processing
        * of said subexpression
        */
        if (dataOfLeafNodeAsVariableExpr.has_value()) {
            const auto& accessedSignalPartsOfLeafNode = std::dynamic_pointer_cast<syrec::VariableExpression>(*dataOfLeafNodeAsVariableExpr);
            if (wereAccessedSignalPartsModifiedByActiveAssignment(*accessedSignalPartsOfLeafNode->var)) {
                handleConflict(operationNode->id, wasLhsOperandLeafNode ? Decision::ChoosenOperand::Left : Decision::ChoosenOperand::Right, *accessedSignalPartsOfLeafNode->var);
                const bool isCurrentOperationNodeSourceOfConflict = isOperationNodeSourceOfConflict(operationNode->id);
                
                generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(!isCurrentOperationNodeSourceOfConflict);
                backtrack(operationNode->id, isCurrentOperationNodeSourceOfConflict);
                if (isCurrentOperationNodeSourceOfConflict) {
                    markSourceOfConflictReached();
                    simplificationResultOfOperationNodeOperand.reset();
                } else {
                    return std::nullopt;
                }
            }
        }
        continueProcessingOfNonLeafNode = !simplificationResultOfOperationNodeOperand.has_value();
    }
    
    DecisionResult                                                                                decisionResult;
    std::variant<OperationNodeSimplificationResult::IdAndAssignmentTuple, syrec::Expression::ptr> simplificationResultDataOfLeafNode;
    if (dataOfLeafNodeAsVariableExpr.has_value()) {
        simplificationResultDataOfLeafNode = std::make_pair(0, std::dynamic_pointer_cast<syrec::VariableExpression>(*dataOfLeafNodeAsVariableExpr)->var);
    } else {
        simplificationResultDataOfLeafNode = *expressionTraversalHelper->getOperandAsExpr(wasLhsOperandLeafNode ? operationNode->lhsOperand.id : operationNode->rhsOperand.id);
    }
    OperationNodeSimplificationResult simplificationResultOfLeafNode = OperationNodeSimplificationResult::createManuallyFromLeafNode(simplificationResultDataOfLeafNode);

    // TODO: Semantic check for prior to assingment generation
    if (simplificationResultOfOperationNodeOperand.has_value()) {
        const syrec::Expression::ptr temporaryExpressionToConsiderForDecision = simplificationResultOfOperationNodeOperand->get()->getResultAsExpr().value_or(nullptr);
        considerExpressionInFutureDecisions(temporaryExpressionToConsiderForDecision);
        if (wasLhsOperandLeafNode) {
            decisionResult = makeDecisionFor(operationNode->id, simplificationResultOfLeafNode, operationNode->operation, **simplificationResultOfOperationNodeOperand, idOfLastActiveAssignmentPriorToProcessingOfLeafNode, idOfLastActiveAssignmentPriorToProcessingOfLeafNode, signalValueLookupCallback);
        } else {
            decisionResult = makeDecisionFor(operationNode->id, **simplificationResultOfOperationNodeOperand, operationNode->operation, simplificationResultOfLeafNode, idOfLastActiveAssignmentPriorToProcessingOfLeafNode, idOfLastActiveAssignmentPriorToProcessingOfLeafNode, signalValueLookupCallback);
        }
        revokeConsiderationOfExpressionForFutureDecisions(temporaryExpressionToConsiderForDecision);
    } else {
        const std::size_t operandIdOfNonLeafNode   = wasLhsOperandLeafNode ? operationNode->rhsOperand.id : operationNode->lhsOperand.id;
        simplificationResultOfOperationNodeOperand = OperationNodeSimplificationResult::createAndOwnNewInstance(OperationNodeSimplificationResult::createFromNonLeafNode(operationNode->id, *expressionTraversalHelper->getOperandAsExpr(operandIdOfNonLeafNode), {}));
    }

     if (decisionResult.reasonForUnknownResult.has_value()) {
        generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
    } else {
        expressionTraversalHelper->removeOperationNodeAsPotentialBacktrackOperation(operationNode->id);
        generatedAssignmentsContainer->popLastCutoffForInvertibleAssignments();
    }
    return tryPerformTransformationOfDecisionResultToOperationNodeSimplificationResultWhenNoConflictWasDetected(operationNode->id, decisionResult);
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OperationNodeSimplificationResult::OwningReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleOperationNodeWithOnlyLeafNodes(const ExpressionTraversalHelper::OperationNodeReference& operationNode, const SignalValueLookupCallback& signalValueLookupCallback) {
    generatedAssignmentsContainer->markCutoffForInvertibleAssignments();
    const std::size_t idOfLastActiveAssignmentPriorToProcessingOfOperationNode = generatedAssignmentsContainer->getIdOfLastGeneratedAssignment().value_or(0);

    std::optional<std::variant<OperationNodeSimplificationResult::IdAndAssignmentTuple, syrec::Expression::ptr>> simplificationResultOfLhsOperand;
    if (const std::optional<syrec::VariableExpression::ptr> fetchedDataOfAccessedSignalPartsOfLhsOperand = expressionTraversalHelper->getOperandAsVariableExpr(operationNode->lhsOperand.id); fetchedDataOfAccessedSignalPartsOfLhsOperand.has_value()) {
        if (const std::shared_ptr<syrec::VariableExpression> castedFetchedDataOfAccessedSignalPartsOfLhsOperand = std::dynamic_pointer_cast<syrec::VariableExpression>(*fetchedDataOfAccessedSignalPartsOfLhsOperand); castedFetchedDataOfAccessedSignalPartsOfLhsOperand) {
            simplificationResultOfLhsOperand = std::make_pair(0, castedFetchedDataOfAccessedSignalPartsOfLhsOperand->var);
        }
    }
    if (!simplificationResultOfLhsOperand.has_value()) {
        simplificationResultOfLhsOperand = expressionTraversalHelper->getOperandAsExpr(operationNode->lhsOperand.id);
    }

    std::optional<std::variant<OperationNodeSimplificationResult::IdAndAssignmentTuple, syrec::Expression::ptr>> simplificationResultOfRhsOperand;
    if (const std::optional<syrec::VariableExpression::ptr> fetchedDataOfAccessedSignalPartsOfRhsOperand = expressionTraversalHelper->getOperandAsVariableExpr(operationNode->rhsOperand.id); fetchedDataOfAccessedSignalPartsOfRhsOperand.has_value()) {
        if (const std::shared_ptr<syrec::VariableExpression> castedFetchedDataOfAccessedSignalPartsOfRhsOperand = std::dynamic_pointer_cast<syrec::VariableExpression>(*fetchedDataOfAccessedSignalPartsOfRhsOperand); castedFetchedDataOfAccessedSignalPartsOfRhsOperand) {
            simplificationResultOfRhsOperand = std::make_pair(0, castedFetchedDataOfAccessedSignalPartsOfRhsOperand->var);
        }
    }
    if (!simplificationResultOfRhsOperand.has_value()) {
        simplificationResultOfRhsOperand = expressionTraversalHelper->getOperandAsExpr(operationNode->rhsOperand.id);
    }

    if (!simplificationResultOfLhsOperand.has_value() || !simplificationResultOfRhsOperand.has_value()) {
        return OperationNodeSimplificationResult::createAndOwnNewInstance(OperationNodeSimplificationResult::createAsUnknownResult(UnknownResultReason::Other));
    }

    const DecisionResult decisionResult = makeDecisionFor(operationNode->id, OperationNodeSimplificationResult::createManuallyFromLeafNode(*simplificationResultOfLhsOperand), operationNode->operation, OperationNodeSimplificationResult::createManuallyFromLeafNode(*simplificationResultOfRhsOperand), idOfLastActiveAssignmentPriorToProcessingOfOperationNode, idOfLastActiveAssignmentPriorToProcessingOfOperationNode, signalValueLookupCallback);
    generatedAssignmentsContainer->popLastCutoffForInvertibleAssignments();
    return tryPerformTransformationOfDecisionResultToOperationNodeSimplificationResultWhenNoConflictWasDetected(operationNode->id, decisionResult);
}

inline bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesAssignmentToSignalLeadToConflict(const syrec::VariableAccess& assignedToSignal) const {
    return generatedAssignmentsContainer->existsOverlappingAssignmentFor(assignedToSignal, *symbolTableReference);
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryGetDecisionForOperationNode(const std::size_t& operationNodeId) const {
    const auto& matchingDecisionForOperationNode = std::find_if(
            pastDecisions.cbegin(),
            pastDecisions.cend(),
            [&operationNodeId](const DecisionReference& pastDecision) {
                return pastDecision->operationNodeId == operationNodeId;
            });
    if (matchingDecisionForOperationNode != pastDecisions.cend()) {
        return *matchingDecisionForOperationNode;
    }
    return std::nullopt;
}

// TODO: When replacing an operand with a replacement, should we also clear any existing learned conflicts for that operand in the operation node ?
//noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::makeDecision(const ExpressionTraversalHelper::OperationNodeReference& operationNode, OperationOperandSimplificationResult& simplificationResultOfFirstOperand, OperationOperandSimplificationResult& simplificationResultOfSecondOperand, const SignalValueLookupCallback& callbackForValueLookupOfExistingSymbolTableSignals) {
//    const std::optional<DecisionReference>          previousDecisionForOperationNode = tryGetDecisionForOperationNode(operationNode->id);
//    const bool                                      wasAssignmentGeneratedByLhsOperand = simplificationResultOfFirstOperand.getAssignedToSignalOfAssignment().has_value();
//    const bool                                      wasAssignmentGeneratedByRhsOperand = simplificationResultOfSecondOperand.getAssignedToSignalOfAssignment().has_value();
//    const std::optional<syrec_operation::operation> matchingAssignmentOperationForOperationNode = syrec_operation::getMatchingAssignmentOperationForOperation(operationNode->operation);
//    const bool                                      isAnyChoiceBetweenOperandsPossible          = matchingAssignmentOperationForOperationNode.has_value() && (wasAssignmentGeneratedByLhsOperand || wasAssignmentGeneratedByRhsOperand);
//
//    DecisionReference madeDecision;
//    if (previousDecisionForOperationNode.has_value()) {
//        madeDecision = *previousDecisionForOperationNode;
//        madeDecision->numExistingAssignmentsPriorToDecision = generatedAssignmentsContainer->getNumberOfAssignments();
//        if (madeDecision->shouldChoiceBeRepeated == Decision::ChoiceRepetition::UntilReset) {
//            logDecision(madeDecision);
//            madeDecision->shouldChoiceBeRepeated = Decision::ChoiceRepetition::None;
//            return madeDecision;
//        }
//        if (madeDecision->shouldChoiceBeRepeated == Decision::ChoiceRepetition::Always) {
//            logDecision(madeDecision);
//            return madeDecision;
//        }
//        madeDecision->choosenOperand                = Decision::ChoosenOperand::None;
//        madeDecision->inheritedOperandDataForChoice = nullptr;
//    }
//    else {
//        madeDecision = std::make_shared<Decision>(Decision{operationNode->id, generatedAssignmentsContainer->getNumberOfAssignments(), Decision::ChoosenOperand::None, Decision::ChoiceRepetition::None, nullptr});
//        recordDecision(madeDecision);
//    }
//
//    if (!isAnyChoiceBetweenOperandsPossible) {
//        madeDecision->choosenOperand = Decision::ChoosenOperand::None;
//        logDecision(madeDecision);
//        return madeDecision;
//    }
//
//    std::optional<syrec::VariableAccess::ptr> firstOperandAsVariableAccess  = simplificationResultOfFirstOperand.getAssignedToSignalOfAssignment();
//    std::optional<syrec::Expression::ptr>     firstOperandAsExpr            = simplificationResultOfFirstOperand.getGeneratedExpr();
//    std::optional<syrec::VariableAccess::ptr> secondOperandAsVariableAccess = simplificationResultOfSecondOperand.getAssignedToSignalOfAssignment();
//    std::optional<syrec::Expression::ptr>     secondOperandAsExpr           = simplificationResultOfSecondOperand.getGeneratedExpr();
//
//    /*
//     * We have a preference to start our decision process by choosing the lhs operand first, but in case that no assignment was generated only by the rhs operand, we would like
//     * to reuse said assignment if the given operation is commutative.
//     */
//    const bool shouldOperandsBeSwappedDueToPreferenceForReuseOfExistingAssignmentOfRhs = (simplificationResultOfFirstOperand.wasResultManuallyCreated() || firstOperandAsExpr.has_value()) && !simplificationResultOfSecondOperand.wasResultManuallyCreated()
//        && secondOperandAsVariableAccess.has_value() && syrec_operation::isCommutative(operationNode->operation);
//
//    if (shouldOperandsBeSwappedDueToPreferenceForReuseOfExistingAssignmentOfRhs) {
//        firstOperandAsVariableAccess.swap(secondOperandAsVariableAccess);
//        firstOperandAsExpr.swap(secondOperandAsExpr);
//    }
//
//    /*
//     * Our decision follows the pattern:
//     * I.   Try to select one of the operands as a potential choice with a higher preference for the left operand as a first choice.
//     * II.  Check whether the decision can actually be used on the left-hand side of an assignment and does not lead to a conflict (this includes a check if any previous conflicts were already learned for the selected choice at the given operation node and that no overlapping signal access is defined in the second alternative)
//     * III. If our first choice failed, try to repeat the steps but choose the right operand if possible (i.e. the operation is commutative).
//     * IV.  If no operand could be selected as a candidate, the whole expression will be selected as our final decision.
//     *
//     * We will also remember any conflicts that we derive during this check and will not reset them during our parsing of the further parts of the initial assignment
//     * since these learned conflicts are valid for the whole duration of the assignment parsing.
//     */
//    if (firstOperandAsVariableAccess.has_value()) {
//        constexpr Decision::ChoosenOperand toBeChosenOperand = Decision::ChoosenOperand::Left;
//        if (secondOperandAsVariableAccess.has_value() && canAlternativeByChosenInOperationNode(operationNode->id, toBeChosenOperand, **firstOperandAsVariableAccess, **secondOperandAsVariableAccess, *symbolTableReference)) {
//            madeDecision->choosenOperand = toBeChosenOperand;
//        } else if (secondOperandAsExpr.has_value() && canAlternativeByChosenInOperationNode(operationNode->id, toBeChosenOperand, **firstOperandAsVariableAccess, **secondOperandAsExpr, *symbolTableReference)) {
//            madeDecision->choosenOperand = toBeChosenOperand;
//        }
//    }
//    
//    if (madeDecision->choosenOperand == Decision::ChoosenOperand::None && syrec_operation::isCommutative(operationNode->operation) && secondOperandAsVariableAccess.has_value()) {
//        constexpr Decision::ChoosenOperand toBeChosenOperand = Decision::ChoosenOperand::Right;
//        if (firstOperandAsVariableAccess.has_value() && canAlternativeByChosenInOperationNode(operationNode->id, toBeChosenOperand, **secondOperandAsVariableAccess, **firstOperandAsVariableAccess, *symbolTableReference)) {
//            madeDecision->choosenOperand = toBeChosenOperand;
//        } else if (firstOperandAsExpr.has_value() && canAlternativeByChosenInOperationNode(operationNode->id, toBeChosenOperand, **secondOperandAsVariableAccess, **firstOperandAsExpr, *symbolTableReference)) {
//            madeDecision->choosenOperand = toBeChosenOperand;
//        }
//    }
//
//    if (madeDecision->choosenOperand != Decision::ChoosenOperand::None) {
//        if (shouldOperandsBeSwappedDueToPreferenceForReuseOfExistingAssignmentOfRhs) {
//            madeDecision->choosenOperand = madeDecision->choosenOperand == Decision::ChoosenOperand::Left ? Decision::ChoosenOperand::Right : Decision::ChoosenOperand::Left;
//        }
//
//        if (madeDecision->choosenOperand == Decision::ChoosenOperand::Left && !operationNode->lhsOperand.isLeafNode()) {
//            madeDecision->inheritedOperandDataForChoice = shouldOperandsBeSwappedDueToPreferenceForReuseOfExistingAssignmentOfRhs ? *secondOperandAsVariableAccess : *firstOperandAsVariableAccess;
//        } else if (madeDecision->choosenOperand == Decision::ChoosenOperand::Right && !operationNode->rhsOperand.isLeafNode()) {
//            madeDecision->inheritedOperandDataForChoice = shouldOperandsBeSwappedDueToPreferenceForReuseOfExistingAssignmentOfRhs ? *firstOperandAsVariableAccess : *secondOperandAsVariableAccess;
//        }
//    }
//    /*
//     * If case that no decision could be made we try to create a substitute for the/one of the defined signal accesses. Furthermore, the latter wil also replace the signal access data with the generated substitute in the
//     * expression traversal object.
//     *
//     * TODO: Reference count updates ?
//     * TODO: How are generated replacements made available to the caller?
//     *
//     * When we encounter a decision node defining an operation without assignment counterpart we should only generate the substitution and store it in a lookup but generate the required assignment
//     * every time anew (since the operand data could change due to backtracking, etc.).
//     */
//    else if (firstOperandAsVariableAccess.has_value()) {
//        madeDecision->choosenOperand = shouldOperandsBeSwappedDueToPreferenceForReuseOfExistingAssignmentOfRhs ? Decision::ChoosenOperand::Right: Decision::ChoosenOperand::Left;
//        if (const std::optional<syrec::VariableAccess::ptr> generatedSubstitution = createReplacementForChosenOperand(madeDecision, callbackForValueLookupOfExistingSymbolTableSignals); generatedSubstitution.has_value()) {
//            logCreationOfSubstitutionOfOperandOfOperationNode(madeDecision->operationNodeId, madeDecision->choosenOperand, **generatedSubstitution);
//            madeDecision->shouldChoiceBeRepeated = Decision::ChoiceRepetition::Always;
//            /*
//             * We do not only need to update the data of the operand in the operation node but also in the given input data
//             */
//            if (madeDecision->choosenOperand == Decision::ChoosenOperand::Left) {
//                simplificationResultOfFirstOperand.updateData(*generatedSubstitution);
//            }
//            else {
//                simplificationResultOfSecondOperand.updateData(*generatedSubstitution);
//            }
//        }
//        else {
//            madeDecision->choosenOperand = Decision::ChoosenOperand::None;
//        }
//    }
//
//    logDecision(madeDecision);
//    return madeDecision;
//}

std::optional<std::size_t> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineOperationNodeIdCausingConflict(const syrec::VariableAccess& choiceOfAssignedToSignalTriggeringSearchForCauseOfConflict) const {
    for (auto decisionIterator = pastDecisions.rbegin(); decisionIterator != pastDecisions.rend(); ++decisionIterator) {
        const DecisionReference& decision = *decisionIterator;
        if (decision->choosenOperand == Decision::ChoosenOperand::None || decision->inheritedOperandDataForChoice) {
            continue;
        }

        const auto& referenceOperationNode = expressionTraversalHelper->getOperationNodeById(decision->operationNodeId);
        if (!referenceOperationNode.has_value()) {
            continue;
        }

        /*syrec::VariableExpression::ptr selectedOperandData;
        if (decision->inheritedOperandDataForChoice) {
            selectedOperandData = std::make_shared<syrec::VariableExpression>(decision->inheritedOperandDataForChoice);
        } else {
            selectedOperandData = decision->choosenOperand == Decision::ChoosenOperand::Left ? expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->lhsOperand.id).value_or(nullptr) : expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->rhsOperand.id).value_or(nullptr);
        }*/

        syrec::VariableExpression::ptr selectedOperandData = decision->choosenOperand == Decision::ChoosenOperand::Left
            ? expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->lhsOperand.id).value_or(nullptr)
            : expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->rhsOperand.id).value_or(nullptr);

        if (!selectedOperandData) {
            return std::nullopt;
        }

        // TODO: if the made choice was inherited from an assignment, the call getOperandAsVariableExpr will not return anything (pastDecision needs to have additional field [inheritedOperand])
        if (const auto& operandAsSignalAccess = std::dynamic_pointer_cast<syrec::VariableExpression>(selectedOperandData); operandAsSignalAccess) {
            const auto& accessedSignalIdentOfDecision = operandAsSignalAccess->var->var->name;

            if (accessedSignalIdentOfDecision == choiceOfAssignedToSignalTriggeringSearchForCauseOfConflict.var->name) {
                const auto& equalityResult = SignalAccessUtils::areSignalAccessesEqual(
                        *operandAsSignalAccess->var, choiceOfAssignedToSignalTriggeringSearchForCauseOfConflict,
                        SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::DimensionAccess::Overlapping,
                        SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::BitRange::Overlapping,
                        *symbolTableReference);

                if (equalityResult.equality != SignalAccessUtils::SignalAccessEquivalenceResult::NotEqual) {
                    return decision->operationNodeId;
                }
            }
        }
    }
    return std::nullopt;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::isOperationNodeSourceOfConflict(std::size_t operationNodeId) const {
    return operationNodeCausingConflictAndBacktrack.has_value() && *operationNodeCausingConflictAndBacktrack == operationNodeId;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::markOperationNodeAsSourceOfConflict(std::size_t operationNodeId) {
    operationNodeCausingConflictAndBacktrack = operationNodeId;
    logMarkingOfOperationNodeAsSourceOfConflict(operationNodeId);
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::markSourceOfConflictReached() {
    operationNodeCausingConflictAndBacktrack.reset();
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::wereAccessedSignalPartsModifiedByActiveAssignment(const syrec::VariableAccess& accessedSignalParts) const {
    return generatedAssignmentsContainer->existsOverlappingAssignmentFor(accessedSignalParts, *symbolTableReference);
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineEarliestDecisionsOverlappingAccessedSignalPartsOmittingAlreadyRecordedOnes(const syrec::VariableAccess& accessedSignalParts) const {
    DecisionReference earliestDecisionOverlappingAccessedSignalParts;
    for (const DecisionReference& decision : pastDecisions) {
        if (decision->choosenOperand == Decision::ChoosenOperand::None || decision->inheritedOperandDataForChoice) {
            continue;
        }

        const auto& referenceOperationNode = expressionTraversalHelper->getOperationNodeById(decision->operationNodeId);
        if (!referenceOperationNode.has_value()) {
            continue;
        }

        const syrec::VariableExpression::ptr selectedOperandData = decision->choosenOperand == Decision::ChoosenOperand::Left
            ? expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->lhsOperand.id).value_or(nullptr)
            : expressionTraversalHelper->getOperandAsVariableExpr(referenceOperationNode->get()->rhsOperand.id).value_or(nullptr);

        if (selectedOperandData) {
            const LearnedConflictsLookupKey key = LearnedConflictsLookupKey(decision->operationNodeId, decision->choosenOperand);
            if (const auto& operandAsSignalAccess = std::dynamic_pointer_cast<syrec::VariableExpression>(selectedOperandData); operandAsSignalAccess && !learnedConflictsLookup->count(key)) {
                const auto& equalityResult = SignalAccessUtils::areSignalAccessesEqual(
                        *operandAsSignalAccess->var, accessedSignalParts,
                        SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::DimensionAccess::Overlapping,
                        SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::BitRange::Overlapping,
                        *symbolTableReference);
                if (!(equalityResult.isResultCertain && equalityResult.equality == SignalAccessUtils::SignalAccessEquivalenceResult::NotEqual)) {
                    if (!earliestDecisionOverlappingAccessedSignalParts || decision.get()->operationNodeId <= earliestDecisionOverlappingAccessedSignalParts->operationNodeId) {
                        earliestDecisionOverlappingAccessedSignalParts = decision;
                    }
                }
            }
        }
    }
    return earliestDecisionOverlappingAccessedSignalParts ? std::make_optional(earliestDecisionOverlappingAccessedSignalParts) : std::nullopt;
}

/*
 * TODO: Review search for earliest operation node involved in conflict (line 712) with test 'simplifyWithOnlyReversibleOpsButNonUniqueSignalAccessWithAssignOperationBeingAdditionWithDegeneratedLhsSubASTOfLhsOfAssignmentExpr'
 *
 * When another choice along the hot path could be possible, why not choose it instead (if no other choice is possible at the original operation node)
 */
void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::handleConflict(std::size_t associatedOperationNodeIdOfAccessedSignalPartsOperand, Decision::ChoosenOperand chosenOperandLeadingToDetectionOfConflict, const syrec::VariableAccess& accessedSignalPartsUsedInCheckForConflict) {
    constexpr std::size_t                  earliestPossibleOperationNodeId               = 0;
    const std::size_t                      idOfEarliestOperationNodeIdInvolvedInConflict = determineOperationNodeIdCausingConflict(accessedSignalPartsUsedInCheckForConflict).value_or(earliestPossibleOperationNodeId);
    const std::optional<DecisionReference> earliestDecisionInvolvedInConflict            = determineEarliestDecisionsOverlappingAccessedSignalPartsOmittingAlreadyRecordedOnes(accessedSignalPartsUsedInCheckForConflict);
    
    if (earliestDecisionInvolvedInConflict.has_value()) {
        rememberConflict(earliestDecisionInvolvedInConflict->get()->operationNodeId, earliestDecisionInvolvedInConflict->get()->choosenOperand);
    }

    logConflict(associatedOperationNodeIdOfAccessedSignalPartsOperand, chosenOperandLeadingToDetectionOfConflict, accessedSignalPartsUsedInCheckForConflict, idOfEarliestOperationNodeIdInvolvedInConflict);

    std::unordered_set<std::size_t> hotPathFromSourceOfConflictToLocationWhereConflictWasDetected                                 = {};
    const std::size_t idOfEarliestSharedParentOperationNodeBetweenSourceOfConflictAndDetectionOfOriginOperationNode = determineEarliestSharedParentOperationNodeIdBetweenCurrentAndConflictOperationNodeId(idOfEarliestOperationNodeIdInvolvedInConflict, associatedOperationNodeIdOfAccessedSignalPartsOperand, &hotPathFromSourceOfConflictToLocationWhereConflictWasDetected);
    markOperationNodeAsSourceOfConflict(idOfEarliestSharedParentOperationNodeBetweenSourceOfConflictAndDetectionOfOriginOperationNode);
    forceReuseOfPreviousDecisionsOnceAtAllDecisionsForChildrenOfNodeButExcludeHotpath(idOfEarliestSharedParentOperationNodeBetweenSourceOfConflictAndDetectionOfOriginOperationNode, &hotPathFromSourceOfConflictToLocationWhereConflictWasDetected);
}

std::size_t noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineEarliestSharedParentOperationNodeIdBetweenCurrentAndConflictOperationNodeId(std::size_t operationNodeIdOfEarliestSourceOfConflict, std::size_t operationNodeIdWhereConflictWasDetected, std::unordered_set<std::size_t>* hotPathContainerFromSourceToSharedOrigin) const {
    /*std::optional<ExpressionTraversalHelper::OperationNodeReference> operationNodeOfInterest;
    if (const std::optional<ExpressionTraversalHelper::OperationNodeReference> dataOfOperationNodeWhereConflictWasDetected = expressionTraversalHelper->getOperationNodeById(operationNodeIdWhereConflictWasDetected); dataOfOperationNodeWhereConflictWasDetected.has_value() && dataOfOperationNodeWhereConflictWasDetected->get()->parentNodeId.has_value()) {
        operationNodeOfInterest = expressionTraversalHelper->getOperationNodeById(*dataOfOperationNodeWhereConflictWasDetected->get()->parentNodeId);
    }*/

    std::optional<ExpressionTraversalHelper::OperationNodeReference> operationNodeOfInterest = expressionTraversalHelper->getOperationNodeById(operationNodeIdOfEarliestSourceOfConflict);

    /*
     * Try to find the first shared operation node by the operation node containing the conflict as well as the operation node for which the conflict was detected. Furthermore, the parent of the found shared parent operation node is returned.
     */
    constexpr std::size_t defaultSearchResultOperationNodeId = 0;
    // If the operation node of interest is already the topmost operation node, we can skip the search for the shared operation node since we already found it.
    while (operationNodeOfInterest.has_value() && operationNodeOfInterest->get()->id) {
        if (hotPathContainerFromSourceToSharedOrigin) {
            hotPathContainerFromSourceToSharedOrigin->emplace(operationNodeOfInterest->get()->id);
        }

        /*
         * We have found the operation node that is the source of the conflict (called original source), but we need to mark its parent node, if such a node exists, as the "source" of the conflict to trigger
         * a reprocessing of the original source. 
         */
        if (operationNodeOfInterest->get()->id < operationNodeIdOfEarliestSourceOfConflict) {
            // TODO: Why should we always return the parent of the found node and not the node instead ?
            return operationNodeOfInterest->get()->id;
            //return operationNodeOfInterest->get()->parentNodeId.value_or(defaultSearchResultOperationNodeId);
        }
        // Since any generated operation node id is >= 1 we can assume that the lookup for an operation node with id 0 does not return any matching result
        operationNodeOfInterest = expressionTraversalHelper->getOperationNodeById(operationNodeOfInterest->get()->parentNodeId.value_or(defaultSearchResultOperationNodeId));
    }
    return defaultSearchResultOperationNodeId;
}

/*
 * TODO: Think this through more thorougly with the help of the test case conflictInOperationNodeWithOneLeafNodeWhereLeafIsRhsOperandNotResolvableByOtherChoiceInLhsOperandThatGeneratedAssignmentCreatesExprInstead
 */
void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::forceReuseOfPreviousDecisionsOnceAtAllDecisionsForChildrenOfNodeButExcludeHotpath(std::size_t parentOperationNodeId, const std::unordered_set<std::size_t>* idOfOperationNodesOnHotPath) const {
    /*
     * We are assuming here that no decision are removed during the processing of the whole assignment statement (only the chosen operand should change). Additionally, we assume that the operation node ids
     * are ordered ascending and thus the a parent operation node should have a smaller id than any of its child nodes. Since child nodes are processed before their parent, the former
     * are also found at smaller indices in the container than their parent nodes. Thus we perform a reverse search to find the parents first.
     */
    const auto& firstPastDecisionToReuse = std::find_if(pastDecisions.crbegin(), pastDecisions.crend(), [&parentOperationNodeId](const DecisionReference& pastDecision) { return pastDecision->operationNodeId > parentOperationNodeId; });
    for (auto pastDecisionToReuseIterator = firstPastDecisionToReuse; pastDecisionToReuseIterator != pastDecisions.crend(); ++pastDecisionToReuseIterator) {
        if (pastDecisionToReuseIterator->get()->shouldChoiceBeRepeated != Decision::ChoiceRepetition::Always) {
            pastDecisionToReuseIterator->get()->shouldChoiceBeRepeated = (!idOfOperationNodesOnHotPath || !idOfOperationNodesOnHotPath->count(pastDecisionToReuseIterator->get()->operationNodeId)) ? Decision::ChoiceRepetition::UntilReset : Decision::ChoiceRepetition::None;    
        }
        
    }
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::shouldBacktrackDueToConflict() const {
    return operationNodeCausingConflictAndBacktrack.has_value();
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::considerExpressionInFutureDecisions(const syrec::Expression::ptr& expr) const {
    if (temporaryExpressionsContainer && expr) {
        temporaryExpressionsContainer->activateExpression(expr);
    }
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::revokeConsiderationOfExpressionForFutureDecisions(const syrec::Expression::ptr& expr) const {
    if (temporaryExpressionsContainer && expr) {
        temporaryExpressionsContainer->deactivateExpression(expr);   
    }
}

std::vector<syrec::VariableAccess::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::defineNotUsableReplacementCandidatesFromAssignmentForGenerator(const syrec::AssignStatement& assignment) const {
    if (substitutionGenerator) {
        std::vector<syrec::VariableAccess::ptr> notUsableReplacementCandidatesForSubstitutionGenerator = determineSignalPartsNotUsableAsPotentialReplacementCandidates(*assignment.rhs, *symbolTableReference);
        notUsableReplacementCandidatesForSubstitutionGenerator.emplace_back(assignment.lhs);
        substitutionGenerator->updateRestrictions(notUsableReplacementCandidatesForSubstitutionGenerator, ExpressionSubstitutionGenerator::RestrictionLifetime::Temporary, ExpressionSubstitutionGenerator::RestrictionUpdate::Activation);
        return notUsableReplacementCandidatesForSubstitutionGenerator;
    }
    return {};
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::clearNotUsableReplacementCandidatesFromAssignmentForGenerator(const std::vector<syrec::VariableAccess::ptr>& replacementCandidateRestrictionsStemmingFromAssignment) const {
    if (substitutionGenerator) {
        substitutionGenerator->updateRestrictions(replacementCandidateRestrictionsStemmingFromAssignment, ExpressionSubstitutionGenerator::RestrictionLifetime::Temporary, ExpressionSubstitutionGenerator::Deactivation);
    }
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::isChoiceOfSignalAccessBlockedByAnyActiveExpression(const syrec::VariableAccess& chosenOperand) const {
    return temporaryExpressionsContainer && temporaryExpressionsContainer->existsAnyExpressionDefiningOverlappingSignalAccess(chosenOperand).value_or(true);
}

std::optional<syrec::VariableAccess::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::createReplacementForChosenOperand(const DecisionReference& decisionToReplace, const SignalValueLookupCallback& callbackForValueLookupOfExistingSymbolTableSignals) const {
    if (!determinedBitWidthOfAssignmentToSimplify.has_value() || !substitutionGenerator || !decisionToReplace || decisionToReplace->choosenOperand == Decision::ChoosenOperand::None) {
        return std::nullopt;
    }

    const std::optional<ExpressionTraversalHelper::OperationNodeReference> referencedOperationNode = expressionTraversalHelper->getOperationNodeById(decisionToReplace->operationNodeId);
    if (!referencedOperationNode.has_value() || !referencedOperationNode->get()->hasAnyLeafOperandNodes()) {
        return std::nullopt;
    }

    const std::optional<ExpressionSubstitutionGenerator::ReplacementResult> generatedReplacement = substitutionGenerator->generateReplacementFor(*determinedBitWidthOfAssignmentToSimplify, callbackForValueLookupOfExistingSymbolTableSignals);
    if (!generatedReplacement.has_value()) {
        return std::nullopt;
    }

    /*
     * Since a newly generated replacement signal will always have the initial value of 0 (assuming our replacement is generated as a local signal) thus the XOR assignment operation is sufficient to create the required substitution for the operand of the operation node.
     */
    const std::optional<unsigned int>           mappedToAssignmentOperation            = syrec_operation::tryMapAssignmentOperationEnumToFlag(syrec_operation::operation::XorAssign);
    const std::size_t                           idOfToBeReplacedOperandInOperationNode = decisionToReplace->choosenOperand == Decision::ChoosenOperand::Left ? referencedOperationNode->get()->lhsOperand.id : referencedOperationNode->get()->rhsOperand.id;
    const std::optional<syrec::Expression::ptr> generatedSubstitutionAssignmentRhsExpr = expressionTraversalHelper->getOperandAsVariableExpr(idOfToBeReplacedOperandInOperationNode);
    if (!mappedToAssignmentOperation.has_value() || !generatedSubstitutionAssignmentRhsExpr.has_value()) {
        return std::nullopt;
    }
    
    const syrec::VariableExpression::ptr generatedContainerForReplacementExpr = mappedToAssignmentOperation.has_value() ? std::make_shared<syrec::VariableExpression>(generatedReplacement->foundReplacement) : nullptr;
    const syrec::AssignStatement::ptr    generatedSubstitutionAssignment      = generatedContainerForReplacementExpr ? std::make_shared<syrec::AssignStatement>(generatedReplacement->foundReplacement, *mappedToAssignmentOperation, *generatedSubstitutionAssignmentRhsExpr) : nullptr;
    if (!generatedSubstitutionAssignment || !expressionTraversalHelper->updateOperandData(referencedOperationNode->get()->id, decisionToReplace->choosenOperand == Decision::ChoosenOperand::Left, generatedContainerForReplacementExpr)) {
        return std::nullopt;
    }
    if (generatedAssignmentsContainer->storeInitializationForReplacementOfLeafNode(generatedSubstitutionAssignment, generatedReplacement->requiredResetOfReplacement)) {
        return generatedReplacement->foundReplacement;
    }
    return std::nullopt;
}

std::optional<std::pair<std::size_t, std::shared_ptr<syrec::AssignStatement>>> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::getAndActivateReplacementForOperationNode(std::size_t referencedOperationNodeId, syrec_operation::operation definedOperationInOperationNode, const OperationNodeSimplificationResult& lhsOperandDataChoicesAfterSimplification, const OperationNodeSimplificationResult& rhsOperandDataChoicesAfterSimplification, bool* wasExistingReplacementForOperationNodeEntryUpdated, const SignalValueLookupCallback& callbackForValueLookupOfExistingSymbolTableSignals) {
    if (!determinedBitWidthOfAssignmentToSimplify.has_value() || !substitutionGenerator || !expressionTraversalHelper->getOperationNodeById(referencedOperationNodeId).has_value()) {
        return std::nullopt;
    }
    if (wholeExpressionOfOperationNodeReplacementLookup.count(referencedOperationNodeId)) {
        /*
         * If the operands of the already existing assignment did not change, simply reuse said assignment again. Otherwise, update the operands. The operation of the rhs expression of the assignments should not change thus the type of the expression should also not change.
         */
        const std::shared_ptr<syrec::AssignStatement> existingReplacementForOperationNode = std::dynamic_pointer_cast<syrec::AssignStatement>(wholeExpressionOfOperationNodeReplacementLookup.at(referencedOperationNodeId));
        if (!existingReplacementForOperationNode) {
            wholeExpressionOfOperationNodeReplacementLookup.erase(referencedOperationNodeId);
            return std::nullopt;
        }

        std::optional<bool> didOperandsOfExistingAssignmentChange;
        if (const std::shared_ptr<syrec::BinaryExpression> existingAssignmentRhsExprAsBinaryExpr = std::dynamic_pointer_cast<syrec::BinaryExpression>(existingReplacementForOperationNode->rhs); existingAssignmentRhsExprAsBinaryExpr) {
            didOperandsOfExistingAssignmentChange = tryUpdateOperandsOfExistingReplacementForWholeBinaryExpressionIfChangedAndReturnWhetherUpdateTookPlace(*existingAssignmentRhsExprAsBinaryExpr, lhsOperandDataChoicesAfterSimplification, rhsOperandDataChoicesAfterSimplification);
        } else if (const std::shared_ptr<syrec::ShiftExpression> existingAssignmentRhsExprAsShiftExpr =  std::dynamic_pointer_cast<syrec::ShiftExpression>(existingReplacementForOperationNode->rhs); existingAssignmentRhsExprAsShiftExpr) {
            didOperandsOfExistingAssignmentChange = tryUpdateOperandsOfExistingReplacementForWholeShiftExpressionIfChangedAndReturnWhetherUpdateTookPlace(*existingAssignmentRhsExprAsShiftExpr, lhsOperandDataChoicesAfterSimplification, rhsOperandDataChoicesAfterSimplification);
        }

        if (!didOperandsOfExistingAssignmentChange.has_value()) {
            wholeExpressionOfOperationNodeReplacementLookup.erase(referencedOperationNodeId);
            return std::nullopt;
        }

        if (wasExistingReplacementForOperationNodeEntryUpdated) {
            *wasExistingReplacementForOperationNodeEntryUpdated = *didOperandsOfExistingAssignmentChange;
        }

        const std::vector<std::size_t>& lhsOperandDataDependencies = lhsOperandDataChoicesAfterSimplification.getDataDependenciesAsIdsOfDependentAssignments();
        const std::vector<std::size_t>& rhsOperandDataDependencies = rhsOperandDataChoicesAfterSimplification.getDataDependenciesAsIdsOfDependentAssignments();
        TemporaryAssignmentsContainer::OrderedAssignmentIdContainer fusedDataDependencies;
        fusedDataDependencies.insert(lhsOperandDataDependencies.cbegin(), lhsOperandDataDependencies.cend());
        fusedDataDependencies.insert(rhsOperandDataDependencies.cbegin(), rhsOperandDataDependencies.cend());

        if (const std::optional<std::size_t>& idOfGeneratedAssignment = generatedAssignmentsContainer->storeActiveAssignment(existingReplacementForOperationNode, std::nullopt, fusedDataDependencies, referencedOperationNodeId, std::nullopt); idOfGeneratedAssignment.has_value()) {
            return std::make_pair(*idOfGeneratedAssignment, existingReplacementForOperationNode);    
        }
        return std::nullopt;
    }

    const std::optional<syrec::Expression::ptr> fusedExpressionFromOperands = tryCreateExpressionFromOperationNodeOperandSimplifications(lhsOperandDataChoicesAfterSimplification, definedOperationInOperationNode, rhsOperandDataChoicesAfterSimplification);
    if (!fusedExpressionFromOperands.has_value()) {
        return std::nullopt;
    }

    const std::optional<unsigned int>                                       mappedToFlagForAssignmentEnumValue = syrec_operation::tryMapAssignmentOperationEnumToFlag(syrec_operation::operation::XorAssign);
    const std::optional<ExpressionSubstitutionGenerator::ReplacementResult> generatedReplacement               = mappedToFlagForAssignmentEnumValue.has_value() ? substitutionGenerator->generateReplacementFor(*determinedBitWidthOfAssignmentToSimplify, callbackForValueLookupOfExistingSymbolTableSignals) : std::nullopt;
    if (!generatedReplacement.has_value()) {
        return std::nullopt;
    }

    if (const std::shared_ptr<syrec::AssignStatement> assignmentFusingReplacementAndExpression = std::make_shared<syrec::AssignStatement>(generatedReplacement->foundReplacement, *mappedToFlagForAssignmentEnumValue, *fusedExpressionFromOperands); assignmentFusingReplacementAndExpression) {
        wholeExpressionOfOperationNodeReplacementLookup.insert(std::make_pair(referencedOperationNodeId, assignmentFusingReplacementAndExpression));
        /*
         * Since the operands of the generated assignment, fusing the generated replacement with the expression defining the substitution, rhs expression could potentially change, we need to store said assignment as an active assignment.
         * The optional reset of the replacement can be executed prior to any active assignment and will be stored accordingly in the generated assignment container.
         */
        const std::vector<std::size_t>&                             lhsOperandDataDependencies = lhsOperandDataChoicesAfterSimplification.getDataDependenciesAsIdsOfDependentAssignments();
        const std::vector<std::size_t>&                             rhsOperandDataDependencies = rhsOperandDataChoicesAfterSimplification.getDataDependenciesAsIdsOfDependentAssignments();
        TemporaryAssignmentsContainer::OrderedAssignmentIdContainer fusedDataDependencies;
        fusedDataDependencies.insert(lhsOperandDataDependencies.cbegin(), lhsOperandDataDependencies.cend());
        fusedDataDependencies.insert(rhsOperandDataDependencies.cbegin(), rhsOperandDataDependencies.cend());

        if (const std::optional<std::size_t>& idOfGeneratedAssignment = generatedAssignmentsContainer->storeReplacementAsActiveAssignment(referencedOperationNodeId, assignmentFusingReplacementAndExpression, fusedDataDependencies, generatedReplacement->requiredResetOfReplacement); idOfGeneratedAssignment.has_value()) {
            return std::make_pair(*idOfGeneratedAssignment, assignmentFusingReplacementAndExpression);    
        }
    }
    return std::nullopt;
}

std::optional<bool> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryUpdateOperandsOfExistingReplacementForWholeBinaryExpressionIfChangedAndReturnWhetherUpdateTookPlace(syrec::BinaryExpression& replacementRhsAsBinaryExpr, const OperationNodeSimplificationResult& potentiallyNewLhsOperandOfBinaryExpr, const OperationNodeSimplificationResult& potentiallyNewRhsOperandOfBinaryExpr) {
    bool didAnyOperandChange = false;
    if (!doesOperandSimplificationResultMatchExpression(potentiallyNewLhsOperandOfBinaryExpr, replacementRhsAsBinaryExpr.lhs)) {
        if (const std::optional<syrec::Expression::ptr> newLhsOperandOfBinaryExpr = tryCreateExpressionFromOperationNodeOperandSimplification(potentiallyNewLhsOperandOfBinaryExpr); newLhsOperandOfBinaryExpr.has_value()) {
            replacementRhsAsBinaryExpr.lhs = *newLhsOperandOfBinaryExpr;
            didAnyOperandChange            = true;
        }
        else {
            return std::nullopt;
        }
    }
    if (!doesOperandSimplificationResultMatchExpression(potentiallyNewRhsOperandOfBinaryExpr, replacementRhsAsBinaryExpr.rhs)) {
        if (const std::optional<syrec::Expression::ptr> newRhsOperandOfBinaryExpr = tryCreateExpressionFromOperationNodeOperandSimplification(potentiallyNewRhsOperandOfBinaryExpr); newRhsOperandOfBinaryExpr.has_value()) {
            replacementRhsAsBinaryExpr.rhs = *newRhsOperandOfBinaryExpr;
            didAnyOperandChange            = true;
        } else {
            return std::nullopt;
        }
    }
    return didAnyOperandChange;
}

std::optional<bool> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryUpdateOperandsOfExistingReplacementForWholeShiftExpressionIfChangedAndReturnWhetherUpdateTookPlace(syrec::ShiftExpression& replacementRhsAsShiftExpr, const OperationNodeSimplificationResult& potentiallyNewLhsOperandOfShiftExpr, const OperationNodeSimplificationResult& potentiallyNewRhsOperandOfShiftExpr) {
    bool didAnyOperandChange = false;
    if (!doesOperandSimplificationResultMatchExpression(potentiallyNewLhsOperandOfShiftExpr, replacementRhsAsShiftExpr.lhs)) {
        if (const std::optional<syrec::Expression::ptr> newLhsOperandOfBinaryExpr = tryCreateExpressionFromOperationNodeOperandSimplification(potentiallyNewLhsOperandOfShiftExpr); newLhsOperandOfBinaryExpr.has_value()) {
            replacementRhsAsShiftExpr.lhs = *newLhsOperandOfBinaryExpr;
            didAnyOperandChange           = true;
        } else {
            return std::nullopt;
        }
    }
    if (!doesOperandSimplificationResultMatchNumber(potentiallyNewRhsOperandOfShiftExpr, replacementRhsAsShiftExpr.rhs)) {
        if (const std::optional<syrec::Number::ptr> newRhsOperandOfBinaryExpr = tryCreateNumberFromOperationNodeOperandSimplification(potentiallyNewRhsOperandOfShiftExpr); newRhsOperandOfBinaryExpr.has_value()) {
            replacementRhsAsShiftExpr.rhs = *newRhsOperandOfBinaryExpr;
            didAnyOperandChange           = true;
        } else {
            return std::nullopt;
        }
    }
    return didAnyOperandChange;
}

// TODO: can probably be removed
bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::couldAnotherChoiceBeMadeAtPreviousDecision(const std::optional<std::size_t>& pastDecisionForOperationNodeWithIdToExclude) const {
    if (pastDecisions.empty()) {
        return false;
    }

    std::size_t lastDecisionOffset = 0;
    if (pastDecisionForOperationNodeWithIdToExclude.has_value() && *pastDecisionForOperationNodeWithIdToExclude == std::prev(pastDecisions.cend())->get()->operationNodeId) {
        ++lastDecisionOffset;
    }

    if (lastDecisionOffset >= pastDecisions.size()) {
        return false;
    }

    return std::any_of(
        std::next(pastDecisions.crbegin(), lastDecisionOffset + 1),
        pastDecisions.crend(),
        [&](const DecisionReference& pastDecision) {
                if (const auto& matchingAssignmentOperationForOperation = syrec_operation::getMatchingAssignmentOperationForOperation(*expressionTraversalHelper->getOperationOfOperationNode(pastDecision->operationNodeId)); matchingAssignmentOperationForOperation.has_value()) {
                    return pastDecision->choosenOperand == Decision::ChoosenOperand::Left && syrec_operation::isCommutative(*expressionTraversalHelper->getOperationOfOperationNode(pastDecision->operationNodeId));
                }
                return false;
            });
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::removeDecisionFor(std::size_t operationNodeId) {
    const auto& matchingDecisionForOperationNode = std::find_if(
        pastDecisions.cbegin(),
        pastDecisions.cend(),
        [&operationNodeId](const DecisionReference& decisionReference) {
            return decisionReference->operationNodeId == operationNodeId;
        });

    if (matchingDecisionForOperationNode != pastDecisions.cend()) {
        pastDecisions.erase(matchingDecisionForOperationNode);
    }
}

inline std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryGetLastDecision() const {
    if (pastDecisions.empty()) {
        return std::nullopt;
    }
    return *pastDecisions.begin();
}

inline std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryGetSecondToLastDecision() const {
    if (pastDecisions.size() < 2) {
        return std::nullopt;
    }
    return *std::next(pastDecisions.begin());
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::resetInternals() {
    pastDecisions.clear();
    generatedAssignmentsContainer->resetInternals();
    temporaryExpressionsContainer->resetInternals();
    expressionTraversalHelper->resetInternals();
    if (substitutionGenerator) {
        substitutionGenerator->resetInternals(false);
    }
    determinedBitWidthOfAssignmentToSimplify.reset();
    wholeExpressionOfOperationNodeReplacementLookup.clear();
    enabledValueLookup();
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::defineSymbolTable(const parser::SymbolTable::ptr& activeSymbolTableScope) {
    symbolTableReference = activeSymbolTableScope;
    temporaryExpressionsContainer->defineSymbolTable(symbolTableReference);
    if (substitutionGenerator) {
        substitutionGenerator->defineSymbolTable(symbolTableReference);
    }
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::reloadGenerateableReplacementSignalName() {
    if (substitutionGenerator) {
        substitutionGenerator->loadLastNewlyGeneratedReplacementSignalInformation();
    }
}

std::unique_ptr<syrec::AssignStatement> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::transformAssignmentPriorToSimplification(const syrec::AssignStatement& assignmentToSimplify, bool applyHeuristicsForSubassignmentGeneration) const {
    if (std::unique_ptr<syrec::AssignStatement> owningCopyOfAssignmentStmt = copyUtils::createDeepCopyOfAssignmentStmt(assignmentToSimplify); owningCopyOfAssignmentStmt) {
        // TODO: Only for testing
        return owningCopyOfAssignmentStmt;

        tryConvertNumericToBinaryExpr(owningCopyOfAssignmentStmt->rhs);
        if (!doesExpressionDefineNestedSplitableExpr(*owningCopyOfAssignmentStmt->rhs)) {
            return nullptr;
        }

        /*
         * Try to convert an assignment of the form a -= (<lhsExpr> - <rhsExpr>) to a += (<rhsExpr> - <lhsExpr>) if the <lhsExpr> is a nested expression, to enable the optimization of converting an assignment of the form:
         * a += ... to a ^= 0 if the symbol table entry for the assigned to signal has the value 0
         */
        if (const auto& assignmentRhsExprAsBinaryExpr = std::dynamic_pointer_cast<syrec::BinaryExpression>(owningCopyOfAssignmentStmt->rhs); assignmentRhsExprAsBinaryExpr) {
            const std::optional<syrec_operation::operation> mappedToAssignmentOperationEnumFromFlag = syrec_operation::tryMapAssignmentOperationFlagToEnum(owningCopyOfAssignmentStmt->op);
            const std::optional<syrec_operation::operation> mappedToBinaryOperationEnumFromFlag     = syrec_operation::tryMapBinaryOperationFlagToEnum(assignmentRhsExprAsBinaryExpr->op);
            if (mappedToAssignmentOperationEnumFromFlag.has_value() && *mappedToAssignmentOperationEnumFromFlag == syrec_operation::operation::MinusAssign
                && mappedToBinaryOperationEnumFromFlag.has_value() && *mappedToBinaryOperationEnumFromFlag == syrec_operation::operation::Subtraction) {
                owningCopyOfAssignmentStmt->op                   = *syrec_operation::tryMapAssignmentOperationEnumToFlag(syrec_operation::operation::AddAssign);
                const syrec::Expression::ptr copyOfBinaryExprLhs = assignmentRhsExprAsBinaryExpr->lhs;
                assignmentRhsExprAsBinaryExpr->lhs               = assignmentRhsExprAsBinaryExpr->rhs;
                assignmentRhsExprAsBinaryExpr->rhs               = copyOfBinaryExprLhs;   
            }
        }
        transformExpressionPriorToSimplification(*owningCopyOfAssignmentStmt->rhs, applyHeuristicsForSubassignmentGeneration);
        return owningCopyOfAssignmentStmt;
    }
    return nullptr;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::transformExpressionPriorToSimplification(syrec::Expression& expr, bool applyHeuristicsForSubassignmentGeneration) const {
    if (auto* exprAsBinaryExpr = dynamic_cast<syrec::BinaryExpression*>(&expr); exprAsBinaryExpr) {
        tryConvertNumericToBinaryExpr(exprAsBinaryExpr->lhs);
        tryConvertNumericToBinaryExpr(exprAsBinaryExpr->rhs);
        transformExpressionPriorToSimplification(*exprAsBinaryExpr->lhs, applyHeuristicsForSubassignmentGeneration);

        const bool doesLhsOperandDefineNestedEpxr = doesExpressionDefineNestedSplitableExpr(*exprAsBinaryExpr->lhs);
        const std::optional<syrec_operation::operation> mappedToOperationOfParentExpr  = syrec_operation::tryMapBinaryOperationFlagToEnum(exprAsBinaryExpr->op);

        /*
         * Try to transform a binary expression of the form (<number> op <signalAccess>) to (<signalAccess> op <number>) if the defined operation is commutative, has a matching assignment operation and the defined signal access accesses a modifiable signal.
         */
        if (applyHeuristicsForSubassignmentGeneration && mappedToOperationOfParentExpr.has_value() && syrec_operation::isCommutative(*mappedToOperationOfParentExpr) && syrec_operation::getMatchingAssignmentOperationForOperation(*mappedToOperationOfParentExpr).has_value()
            && (doesExpressionDefineNumber(*exprAsBinaryExpr->lhs) || doesLhsOperandDefineNestedEpxr) && doesExprDefineSignalAccess(*exprAsBinaryExpr->rhs)) {
            const auto& rhsOperandAsSignalAccess = std::dynamic_pointer_cast<const syrec::VariableExpression>(exprAsBinaryExpr->rhs);
            if (rhsOperandAsSignalAccess && isAccessedSignalAssignable(rhsOperandAsSignalAccess->var->var->name)) {
                exprAsBinaryExpr->lhs.swap(exprAsBinaryExpr->rhs);
            }
        }

        if (const std::shared_ptr<syrec::BinaryExpression> rhsExprAsBinaryExpr = std::dynamic_pointer_cast<syrec::BinaryExpression>(exprAsBinaryExpr->rhs); rhsExprAsBinaryExpr) {
            const std::optional<syrec_operation::operation> mappedToOperationOfRhsExpr    = syrec_operation::tryMapBinaryOperationFlagToEnum(rhsExprAsBinaryExpr->op);

            /*
             * Try to transform an expression of the form (a - (b - c)) to (a + (c - b)) only if b is not a signal access. The latter condition is heuristic as the transformation could prevent the creation of an assignment
             * of the form b -= c.
             */
            if (applyHeuristicsForSubassignmentGeneration && mappedToOperationOfParentExpr.has_value() && mappedToOperationOfRhsExpr.has_value() && *mappedToOperationOfRhsExpr == syrec_operation::operation::Subtraction) {
                if (*mappedToOperationOfParentExpr == syrec_operation::operation::Subtraction) {
                /*
                 * TODO: Could a similar transformation take place during the processing of the operation nodes (i.e. when the constellation or something similar (<sigAcc_1> - (<subExpr_1> - <sigAcc_2>)) is encountered?
                 * Try to convert an expression of the form (<subExpr_1> - (<subExpr_2> - <subExpr_3>)) to (<subExpr_1> + (<subExpr_3> - <subExpr_2)).
                 * We do not apply this transformation if <subExpr_2> defines a signal access while <subExpr_3> defines a nested expressions as this could prevent the generation of the assignment <subExpr_2> -= <subExpr_3>.
                 * NOTE: We try to not prevent any future assignments by this transformation, but could implicitly block some by our transformation due to a conflict later during preprocessing.
                 */
                    if (!doesExprDefineSignalAccess(*rhsExprAsBinaryExpr->lhs) || doesExprDefineSignalAccess(*rhsExprAsBinaryExpr->rhs)) {
                        exprAsBinaryExpr->op                    = *syrec_operation::tryMapBinaryOperationEnumToFlag(syrec_operation::operation::Addition);
                        const auto backupOfNestedExprLhsOperand = rhsExprAsBinaryExpr->lhs;
                        rhsExprAsBinaryExpr->lhs                = rhsExprAsBinaryExpr->rhs;
                        rhsExprAsBinaryExpr->rhs                = backupOfNestedExprLhsOperand;
                    }
                /*
                 * TODO: Add tests for this behaviour and could this transformation also be done during the processing of the operation nodes itself ?
                 * Try to convert an expression of the form (<subExpr_1> + (<subExpr_with_op_without_assignmentCounterPart> - <assignableSignalAccess>) to (<subExpr_1> - (<assignableSignalAccess> - <subExpr_with_op_without_assignmentCounterPart>)
                 * where the subexpression that defines an operation without assignment counterpart can also be either a number of a readonly signal access.
                 *
                 * Apply the same transformation if the rhs operand defines an expression with an operation that has an assignment counterpart.
                 * E.g.: (<subExpr_1> + (<notSplitableExprNumberOrReadonlySignalAccess> - <splitableExpr>)) to (<subExpr_1> - (<splitableExpr> - <notSplitableExprNumberOfReadonlySignalAccess>))
                 */
                } else if (*mappedToOperationOfParentExpr == syrec_operation::operation::Addition) {
                    const auto& rhsOperandAsSignalAccess = std::dynamic_pointer_cast<const syrec::VariableExpression>(rhsExprAsBinaryExpr->rhs);
                    const auto& lhsOperandAsSignalAccess                   = std::dynamic_pointer_cast<const syrec::VariableExpression>(rhsExprAsBinaryExpr->lhs);
                    const bool  doesLhsOperandDefineAssignableSignalAccess = lhsOperandAsSignalAccess && isAccessedSignalAssignable(lhsOperandAsSignalAccess->var->var->name);

                    if ((!doesExpressionDefineNestedSplitableExpr(*rhsExprAsBinaryExpr->lhs) && rhsOperandAsSignalAccess && isAccessedSignalAssignable(rhsOperandAsSignalAccess->var->var->name)) 
                        || (!doesLhsOperandDefineAssignableSignalAccess && doesExpressionDefineNestedSplitableExpr(*rhsExprAsBinaryExpr->lhs))) {
                        if (!doesLhsOperandDefineAssignableSignalAccess) {
                            rhsExprAsBinaryExpr->lhs.swap(rhsExprAsBinaryExpr->rhs);
                            exprAsBinaryExpr->op = *syrec_operation::tryMapBinaryOperationEnumToFlag(syrec_operation::operation::Subtraction);
                        }
                    }
                }
            }  
        }
        transformExpressionPriorToSimplification(*exprAsBinaryExpr->rhs, applyHeuristicsForSubassignmentGeneration);
    } else if (auto* exprAsShiftExpr = dynamic_cast<syrec::ShiftExpression*>(&expr); exprAsShiftExpr) {
        tryConvertNumericToBinaryExpr(exprAsShiftExpr->lhs);
        transformExpressionPriorToSimplification(*exprAsShiftExpr->lhs, applyHeuristicsForSubassignmentGeneration);
        // TODO: Simplification of number
    }
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::rememberConflict(std::size_t operationNodeId, Decision::ChoosenOperand chosenOperandAtOperationNode) const {
    const LearnedConflictsLookupKey lookupKey = LearnedConflictsLookupKey(operationNodeId, chosenOperandAtOperationNode);
    learnedConflictsLookup->emplace(lookupKey);
    logLearnedConflict(operationNodeId, chosenOperandAtOperationNode);
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::didPreviousDecisionMatchingChoiceCauseConflict(const LearnedConflictsLookupKey& lookupKeyRepresentingSearchedForPreviousDecision) const {
    return learnedConflictsLookup->count(lookupKeyRepresentingSearchedForPreviousDecision);
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::disableValueLookup() {
    disabledValueLookupToggle = true;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::enabledValueLookup() {
    disabledValueLookupToggle = false;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::backtrack(std::size_t operationNodeIdAtOriginOfBacktrack, bool onlyUpToOperationNode) const {
    if (onlyUpToOperationNode) {
        expressionTraversalHelper->backtrackToNode(operationNodeIdAtOriginOfBacktrack);
    }
    else {
        expressionTraversalHelper->backtrackOnePastNode(operationNodeIdAtOriginOfBacktrack);
    }
    const std::optional<ExpressionTraversalHelper::OperationNodeReference> peekedNextOperationNodeAfterFinishOfBacktrack = expressionTraversalHelper->peekNextOperationNode();
    const std::size_t                                                      peekedNextOperationNodeToBeProcessedAfterBacktracking = peekedNextOperationNodeAfterFinishOfBacktrack.has_value() ? peekedNextOperationNodeAfterFinishOfBacktrack.value()->id : 0;
    logBacktrackingResult(operationNodeIdAtOriginOfBacktrack, peekedNextOperationNodeToBeProcessedAfterBacktracking);
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::recordDecision(const DecisionReference& decision) {
    /*const auto& insertPosition = std::find_if(pastDecisions.cbegin(), pastDecisions.cend(), [&decision](const DecisionReference& pastDecision) { return pastDecision->operationNodeId < decision->operationNodeId; });
    if (insertPosition != pastDecisions.cend()) {
        pastDecisions.insert(insertPosition, decision);
    }
    else {
        pastDecisions.emplace(decision);
    }*/
    pastDecisions.emplace(decision);
}

noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OperationNodeProcessingResult noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::processNextOperationNode(const SignalValueLookupCallback& signalValueLookupCallback) {
    std::optional<ExpressionTraversalHelper::OperationNodeReference>   dataOfOperationNode;
    std::optional<OperationNodeSimplificationResult::OwningReference> simplificationResultOfOperationNode;

    bool continueProcessing = true;
    while (continueProcessing) {
        dataOfOperationNode = expressionTraversalHelper->getNextOperationNode();
        if (!dataOfOperationNode.has_value()) {
            return OperationNodeProcessingResult::fromUnknownResult();
        }

        const std::size_t idOfOperationNodeToBeProcessed = dataOfOperationNode->get()->id;
        simplificationResultOfOperationNode              = handleOperationNode(*dataOfOperationNode, signalValueLookupCallback);
        if (shouldBacktrackDueToConflict()) {
            const bool isThisOperationNodeSourceOfConflict = isOperationNodeSourceOfConflict(idOfOperationNodeToBeProcessed);
            if (isThisOperationNodeSourceOfConflict) {
                markSourceOfConflictReached();
            }
            backtrack(idOfOperationNodeToBeProcessed, false);
            if (!isThisOperationNodeSourceOfConflict) {
                return OperationNodeProcessingResult::fromConflictInOtherNode();
            }
        } else {
            continueProcessing = false;
        }
    }

    if (!simplificationResultOfOperationNode.has_value() || !simplificationResultOfOperationNode->get()->hasKnownValue()) {
        return OperationNodeProcessingResult::fromUnknownResult();
    }

    if (!simplificationResultOfOperationNode.has_value()) {
        const std::size_t idOfOperationNodeToBeProcessed = dataOfOperationNode->get()->id;
        if (couldAnotherChoiceBeMadeAtPreviousDecision(idOfOperationNodeToBeProcessed)) {
            generatedAssignmentsContainer->rollbackAssignmentsMadeSinceLastCutoffAndOptionallyPopCutoff(true);
            backtrack(idOfOperationNodeToBeProcessed, false);
            return OperationNodeProcessingResult::fromUnknownResult();
        }
        const std::size_t            operationNodeIdOfFirstOperand = *expressionTraversalHelper->getOperandNodeIdOfNestedOperation(*dataOfOperationNode->get()->parentNodeId, dataOfOperationNode->get()->id);
        const syrec::Expression::ptr operandAsExpr                 = *expressionTraversalHelper->getOperandAsExpr(operationNodeIdOfFirstOperand);
        simplificationResultOfOperationNode                        = OperationNodeSimplificationResult::createAndOwnNewInstance(OperationNodeSimplificationResult::createFromNonLeafNode(idOfOperationNodeToBeProcessed, operandAsExpr, {}));
    }
    return OperationNodeProcessingResult::fromResult(std::move(simplificationResultOfOperationNode));
}


bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::canAlternativeByChosenInOperationNode(std::size_t operationNodeId, Decision::ChoosenOperand toBeChosenAlternative, const syrec::VariableAccess& signalAccess, const syrec::VariableAccess& alternativeToCheckAsSignalAccess, const parser::SymbolTable& symbolTable) const {
    return expressionTraversalHelper->canSignalBeUsedOnAssignmentLhs(signalAccess.var->name)
        && !didPreviousDecisionMatchingChoiceCauseConflict(LearnedConflictsLookupKey(operationNodeId, toBeChosenAlternative))
        && !doSignalAccessesOverlap(alternativeToCheckAsSignalAccess, signalAccess, symbolTable)
        && !isChoiceOfSignalAccessBlockedByAnyActiveExpression(signalAccess);
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::canAlternativeByChosenInOperationNode(std::size_t operationNodeId, Decision::ChoosenOperand toBeChosenAlternative, const syrec::VariableAccess& signalAccess, const syrec::Expression& alternativeToCheckAsExpr, const parser::SymbolTable& symbolTable) const {
    return expressionTraversalHelper->canSignalBeUsedOnAssignmentLhs(signalAccess.var->name)
        && !didPreviousDecisionMatchingChoiceCauseConflict(LearnedConflictsLookupKey(operationNodeId, toBeChosenAlternative))
        && !doesExprContainOverlappingAccessOnGivenSignalAccess(alternativeToCheckAsExpr, signalAccess, symbolTable)
        && !isChoiceOfSignalAccessBlockedByAnyActiveExpression(signalAccess);
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::isAccessedSignalAssignable(const std::string_view& accessedSignalIdent) const {
    return symbolTableReference && symbolTableReference->canSignalBeAssignedTo(accessedSignalIdent).value_or(false);
}


std::optional<double> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineCostOfExpr(const syrec::Expression& expr, std::size_t currentNestingLevel) const {
    if (const auto& exprAsBinaryExpr = dynamic_cast<const syrec::BinaryExpression*>(&expr); exprAsBinaryExpr) {
        ++currentNestingLevel;
        const std::optional<double> costOfLhsExpr = determineCostOfExpr(*exprAsBinaryExpr->lhs, currentNestingLevel);
        const std::optional<double> costOfRhsExpr = costOfLhsExpr.has_value() ? determineCostOfExpr(*exprAsBinaryExpr->rhs, currentNestingLevel) : std::nullopt;

        if (costOfRhsExpr.has_value()) {
            return (internalConfig.expressionNestingPenaltyScalingPerNestingLevel * currentNestingLevel * internalConfig.expressionNestingPenalty) + *costOfLhsExpr + *costOfRhsExpr;
        }
        return std::nullopt;
    }
    if (const auto& exprAsShiftExpr = dynamic_cast<const syrec::ShiftExpression*>(&expr); exprAsShiftExpr) {
        ++currentNestingLevel;
        const std::optional<double> costOfToBeShiftedExpr = determineCostOfExpr(*exprAsShiftExpr->lhs, currentNestingLevel);
        const std::optional<double> costOfShiftAmount     = costOfToBeShiftedExpr.has_value() ? determineCostOfNumber(*exprAsShiftExpr->rhs, currentNestingLevel) : std::nullopt;

        if (costOfShiftAmount.has_value()) {
            return (internalConfig.expressionNestingPenaltyScalingPerNestingLevel * currentNestingLevel * internalConfig.expressionNestingPenalty) + *costOfToBeShiftedExpr + *costOfShiftAmount;
        }
        return std::nullopt;
    }
    if (const auto& exprAsNumericExpr = dynamic_cast<const syrec::NumericExpression*>(&expr); exprAsNumericExpr) {
        return determineCostOfNumber(*exprAsNumericExpr->value, currentNestingLevel + 1);
    }
    if (const auto& exprAsVariableExpr = dynamic_cast<const syrec::VariableExpression*>(&expr); exprAsVariableExpr) {
        return 1;
    }
    return std::nullopt;
}

std::optional<double> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineCostOfAssignment(const syrec::AssignStatement& assignment) const {
    return determineCostOfExpr(*assignment.rhs, 0);
}

std::optional<double> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineCostOfNumber(const syrec::Number& number, std::size_t currentNestingLevel) const {
    if (number.isCompileTimeConstantExpression()) {
        const std::optional<syrec::BinaryExpression::ptr> numericExprAsBinaryExpr = convertCompileTimeConstantExprToBinaryExpr(number.getExpression(), 0);
        return numericExprAsBinaryExpr.has_value() ? determineCostOfExpr(**numericExprAsBinaryExpr, currentNestingLevel + 1) : std::nullopt;
    }
    return 1;
}

std::optional<double> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineCostOfAssignments(const std::vector<AssignmentTransformer::SharedAssignmentReference>& assignmentsToCheck) const {
    std::optional<double> sumOfCosts = 0;
    for (auto&& assignment: assignmentsToCheck) {
        if (!sumOfCosts.has_value()) {
            break;
        }

        if (std::holds_alternative<std::shared_ptr<syrec::AssignStatement>>(assignment)) {
            const std::shared_ptr<syrec::AssignStatement> assignmentCastedAsBinaryOne = std::get<std::shared_ptr<syrec::AssignStatement>>(assignment);
            tryAddCosts(sumOfCosts, determineCostOfAssignment(*assignmentCastedAsBinaryOne));
        } else if (std::holds_alternative<std::shared_ptr<syrec::UnaryStatement>>(assignment)) {
            tryAddCosts(sumOfCosts, 1);
        } else {
            sumOfCosts.reset();
        }
    }
    return sumOfCosts;
}

std::optional<double> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineCostOfAssignments(SimplificationResult::OwningCopiesOfAssignment& assignments) const {
    std::optional<double> sumOfCosts = 0;
    for (auto&& assignment : assignments){
        if (!sumOfCosts.has_value()) {
            break;
        }

        if (std::holds_alternative<std::unique_ptr<syrec::AssignStatement>>(assignment)) {
            std::unique_ptr<syrec::AssignStatement> temporarilyOwningBinaryAssignment = std::move(std::get<std::unique_ptr<syrec::AssignStatement>>(assignment));
            tryAddCosts(sumOfCosts, determineCostOfAssignment(*temporarilyOwningBinaryAssignment));
            assignment = std::move(temporarilyOwningBinaryAssignment);
        }
        else if (std::holds_alternative<std::unique_ptr<syrec::UnaryStatement>>(assignment)) {
            tryAddCosts(sumOfCosts, 1);
        }
        else {
            sumOfCosts.reset();
        }
    }
    return sumOfCosts;
}

noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::SimplificationResult::OwningReference noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineMostViableAlternativeBasedOnCost(SimplificationResult::OwningReference& generatedSimplifiedAssignments, const std::shared_ptr<syrec::AssignStatement>& originalAssignmentUnoptimized, const SignalValueLookupCallback& signalValueCallback) const {
    SimplificationResult::OwningReference endResult = SimplificationResult::createOwningReferenceOf(SimplificationResult::asEmptyResult());
    if (!endResult || internalConfig.preferAssignmentsGeneratedByChoiceRegardlessOfCost) {
        return std::move(generatedSimplifiedAssignments);
    }
    
    /*if (!generatedSimplifiedAssignments.empty() && (!doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(*originalAssignmentUnoptimized->rhs) || internalConfig.preferAssignmentsGeneratedByChoiceRegardlessOfCost)) {
        return generatedSimplifiedAssignments;
    }*/

    auto containerForUnoptimizedOriginalAssignment = std::vector<AssignmentTransformer::SharedAssignmentReference>(1, originalAssignmentUnoptimized);
    containerForUnoptimizedOriginalAssignment      = assignmentTransformer->simplify(containerForUnoptimizedOriginalAssignment, signalValueCallback);

    const std::optional<std::size_t> costOfUnoptimizedAssignment                                 = determineCostOfAssignments(containerForUnoptimizedOriginalAssignment);
    const std::optional<std::size_t> costOfRequiredValueResetsOfOptimizedAssignments             = costOfUnoptimizedAssignment.has_value() ? determineCostOfAssignments(generatedSimplifiedAssignments->requiredValueResetsForReplacementsTargetingExistingSignals) : std::nullopt;
    const std::optional<std::size_t> costOfOptimizedAssignments                                  = costOfRequiredValueResetsOfOptimizedAssignments.has_value() ? determineCostOfAssignments(generatedSimplifiedAssignments->generatedAssignments) : std::nullopt;
    const std::optional<std::size_t> costOfRequiredInversionsOfValueResetsOfOptimizedAssignments = costOfOptimizedAssignments.has_value() ? determineCostOfAssignments(generatedSimplifiedAssignments->requiredInversionsOfValuesResetsForReplacementsTargetingExistingSignals) : std::nullopt;

    std::optional<double> sumOfCostsOfOptimizedAssignments = 0;
    tryAddCosts(sumOfCostsOfOptimizedAssignments, costOfRequiredValueResetsOfOptimizedAssignments);
    tryAddCosts(sumOfCostsOfOptimizedAssignments, costOfOptimizedAssignments);
    tryAddCosts(sumOfCostsOfOptimizedAssignments, costOfRequiredInversionsOfValueResetsOfOptimizedAssignments);

    if (sumOfCostsOfOptimizedAssignments.has_value() && costOfOptimizedAssignments.has_value() && *sumOfCostsOfOptimizedAssignments < *costOfUnoptimizedAssignment) {
        return std::move(generatedSimplifiedAssignments);
    }

    if (std::optional<SimplificationResult::OwningCopiesOfAssignment> owningCopiesOfAssignmentsOfTransformedOriginalAssignment = createOwningCopiesOfAssignments(containerForUnoptimizedOriginalAssignment); owningCopiesOfAssignmentsOfTransformedOriginalAssignment.has_value()) {
        endResult->generatedAssignments = std::move(*owningCopiesOfAssignmentsOfTransformedOriginalAssignment);
    }
    return endResult;
}

std::optional<syrec::Expression::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::fuseExpressions(const syrec::Expression::ptr& lhsOperand, syrec_operation::operation op, const syrec::Expression::ptr& rhsOperand) {
    if (syrec_operation::isOperationShiftOperation(op)) {
        if (const auto& rhsOperandAsNumericExpr = std::dynamic_pointer_cast<syrec::NumericExpression>(rhsOperand); rhsOperandAsNumericExpr) {
            const auto generatedShiftExpr = std::make_shared<syrec::ShiftExpression>(
                    lhsOperand,
                    *syrec_operation::tryMapShiftOperationEnumToFlag(op),
                    rhsOperandAsNumericExpr->value);
            return generatedShiftExpr;    
        }
        return std::nullopt;
    }
    const auto generatedBinaryExpr = std::make_shared<syrec::BinaryExpression>(lhsOperand, *syrec_operation::tryMapBinaryOperationEnumToFlag(op), rhsOperand);
    return generatedBinaryExpr;
}

std::optional<syrec::AssignStatement::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryCreateAssignmentForOperationNode(const syrec::VariableAccess::ptr& assignmentLhs, syrec_operation::operation op, const syrec::Expression::ptr& assignmentRhs) {
    if (const auto matchingAssignmentOperationForOperation = syrec_operation::getMatchingAssignmentOperationForOperation(op); matchingAssignmentOperationForOperation.has_value()) {
        const auto& mappedToAssignmentOperationFlag = syrec_operation::tryMapAssignmentOperationEnumToFlag(*matchingAssignmentOperationForOperation);
        const auto& generatedAssignment = std::make_shared<syrec::AssignStatement>(assignmentLhs, *mappedToAssignmentOperationFlag, assignmentRhs);
        return generatedAssignment;
    }
    return std::nullopt;
}

//inline syrec::Expression::ptr noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::createExpressionFromOperandSimplificationResult(const OperationOperandSimplificationResult& operandSimplificationResult) {
//    if (const auto& lastAssignedToSignalInOperandSimplificationResult = operandSimplificationResult.getAssignedToSignalOfAssignment(); lastAssignedToSignalInOperandSimplificationResult.has_value()) {
//        return std::make_shared<syrec::VariableExpression>(*lastAssignedToSignalInOperandSimplificationResult);
//    }
//    return *operandSimplificationResult.getGeneratedExpr();
//}

inline bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesExpressionDefineNestedSplitableExpr(const syrec::Expression& expr) {
    // We are assuming here that compile time constant expressions were already converted to binary expressions
    return dynamic_cast<const syrec::BinaryExpression*>(&expr) || dynamic_cast<const syrec::ShiftExpression*>(&expr);
}

inline bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesExpressionDefineNumber(const syrec::Expression& expr) {
    return dynamic_cast<const syrec::NumericExpression*>(&expr);
}

inline bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesExprDefineSignalAccess(const syrec::Expression& expr) {
    return dynamic_cast<const syrec::VariableExpression*>(&expr);
}

std::optional<syrec::Expression::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryCreateExpressionFromOperationNodeOperandSimplifications(const OperationNodeSimplificationResult& simplificationResultOfFirstOperand, syrec_operation::operation operationNodeOperation, const OperationNodeSimplificationResult& simplificationResultOfSecondOperand) {
    const std::optional<syrec::Expression::ptr> generatedLhsOperandExpr = tryCreateExpressionFromOperationNodeOperandSimplification(simplificationResultOfFirstOperand);
    if (const std::optional<syrec::Expression::ptr> generatedRhsOperandExpr = generatedLhsOperandExpr.has_value() ? tryCreateExpressionFromOperationNodeOperandSimplification(simplificationResultOfSecondOperand) : std::nullopt; generatedRhsOperandExpr.has_value()) {
        return fuseExpressions(*generatedLhsOperandExpr, operationNodeOperation, *generatedRhsOperandExpr);
    }
    return std::nullopt;
}

std::optional<syrec::Expression::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryCreateExpressionFromOperationNodeOperandSimplification(const OperationNodeSimplificationResult& simplificationResultOfOperand) {
    if (const std::optional<syrec::VariableAccess::ptr> lastAssignedToSignalOfFirstOperand = simplificationResultOfOperand.getResultAsSignalAccess(); lastAssignedToSignalOfFirstOperand.has_value()) {
        if (const syrec::Expression::ptr generatedVariableExpr = std::make_shared<syrec::VariableExpression>(*lastAssignedToSignalOfFirstOperand); generatedVariableExpr) {
            return generatedVariableExpr;
        }
    } else {
        if (std::optional<syrec::Expression::ptr> preexistingExpr = simplificationResultOfOperand.getResultAsExpr(); preexistingExpr.has_value()) {
            return preexistingExpr;
        }
    }
    return std::nullopt;
}

std::optional<syrec::Number::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryCreateNumberFromOperationNodeOperandSimplification(const OperationNodeSimplificationResult& simplificationResultOfOperand) {
    if (std::optional<syrec::Expression::ptr> preexistingExpr = simplificationResultOfOperand.getResultAsExpr(); preexistingExpr.has_value()) {
        if (const std::shared_ptr<syrec::NumericExpression>& exprAsNumericExpr = std::dynamic_pointer_cast<syrec::NumericExpression>(*preexistingExpr); exprAsNumericExpr) {
            return exprAsNumericExpr->value;
        }
    }
    return std::nullopt;
}


bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::areAssignedToSignalPartsZero(const syrec::VariableAccess& accessedSignalParts, const SignalValueLookupCallback& signalValueLookupCallback) {
    const std::optional<unsigned int> fetchedValueOfAccessedSignalParts = signalValueLookupCallback(accessedSignalParts);
    return fetchedValueOfAccessedSignalParts.has_value() && !*fetchedValueOfAccessedSignalParts;
}

// TODO: One could extend this condition to also include that non-reversible operations are only defined at operations nodes with only leaf nodes
bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(const syrec::Expression& expr) {
    if (const auto& exprAsNumericExpr = dynamic_cast<const syrec::NumericExpression*>(&expr); exprAsNumericExpr) {
        return !exprAsNumericExpr->value->isCompileTimeConstantExpression();
    }
    if (const auto& exprAsVariableExpr = dynamic_cast<const syrec::VariableExpression*>(&expr); exprAsVariableExpr) {
        return true;
    }
    if (const auto& exprAsBinaryExpr = dynamic_cast<const syrec::BinaryExpression*>(&expr); exprAsBinaryExpr) {
        const std::optional<syrec_operation::operation> mappedToBinaryOperationEnumValue = syrec_operation::tryMapBinaryOperationFlagToEnum(exprAsBinaryExpr->op);
        if (mappedToBinaryOperationEnumValue.has_value() && syrec_operation::getMatchingAssignmentOperationForOperation(*mappedToBinaryOperationEnumValue).has_value()) {
            if (*mappedToBinaryOperationEnumValue == syrec_operation::operation::BitwiseXor) {
                return !(doesExpressionDefineNestedSplitableExpr(*exprAsBinaryExpr->lhs) && doesExpressionDefineNestedSplitableExpr(*exprAsBinaryExpr->rhs))
                    && doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(*exprAsBinaryExpr->lhs) && doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(*exprAsBinaryExpr->rhs);
            }
            return doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(*exprAsBinaryExpr->lhs) && doesExprOnlyDefineReversibleOperationsAndNoBitwiseXorOperationWithNoLeafNodes(*exprAsBinaryExpr->rhs);
        }
    }
    return false;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryConvertNumericToBinaryExpr(syrec::Expression::ptr& expr) {
    if (const auto& lhsExprAsNumericExpr = std::dynamic_pointer_cast<syrec::NumericExpression>(expr); lhsExprAsNumericExpr) {
        if (const auto& lhsNumericExprAsBinaryExpr = convertNumericExprToBinary(*lhsExprAsNumericExpr); lhsNumericExprAsBinaryExpr.has_value()) {
            expr = *lhsNumericExprAsBinaryExpr;
        }
    }
}


std::optional<syrec::BinaryExpression::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::convertNumericExprToBinary(const syrec::NumericExpression& numericExpr) {
    if (!numericExpr.value->isCompileTimeConstantExpression()) {
        return std::nullopt;
    }
    return convertCompileTimeConstantExprToBinaryExpr(numericExpr.value->getExpression(), numericExpr.bwidth);
}

std::optional<syrec_operation::operation> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryMapCompileTimeConstantExprOperationToBinaryOperation(syrec::Number::CompileTimeConstantExpression::Operation operation) {
    switch (operation) {
        case syrec::Number::CompileTimeConstantExpression::Addition:
            return syrec_operation::operation::Addition;
        case syrec::Number::CompileTimeConstantExpression::Subtraction:
            return syrec_operation::operation::Subtraction;
        case syrec::Number::CompileTimeConstantExpression::Multiplication:
            return syrec_operation::operation::Multiplication;
        case syrec::Number::CompileTimeConstantExpression::Division:
        default:
            return std::nullopt;
    }
}

syrec::Expression::ptr noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::convertNumberToExpr(const syrec::Number::ptr& number, unsigned int expectedBitwidth) {
    if (number->isCompileTimeConstantExpression()) {
        if (const std::optional<syrec::BinaryExpression::ptr> mappedToBinaryExpr = convertCompileTimeConstantExprToBinaryExpr(number->getExpression(), expectedBitwidth); mappedToBinaryExpr.has_value()) {
            return *mappedToBinaryExpr;
        }
        return nullptr;
    }

    const syrec::NumericExpression::ptr generatedExpr = std::make_shared<syrec::NumericExpression>(number, expectedBitwidth);
    return generatedExpr;
}

std::optional<syrec::BinaryExpression::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::convertCompileTimeConstantExprToBinaryExpr(const syrec::Number::CompileTimeConstantExpression& compileTimeConstantExpr, unsigned int expectedBitwidth) {
    const std::optional<syrec_operation::operation> mappedToOperation = tryMapCompileTimeConstantExprOperationToBinaryOperation(compileTimeConstantExpr.operation);
    if (!mappedToOperation.has_value()) {
        return std::nullopt;
    }

    const syrec::Expression::ptr& lhsOperandConverted = convertNumberToExpr(compileTimeConstantExpr.lhsOperand, expectedBitwidth);
    const syrec::Expression::ptr& rhsOperandConverted = convertNumberToExpr(compileTimeConstantExpr.rhsOperand, expectedBitwidth);
    if (!lhsOperandConverted || !rhsOperandConverted) {
        return std::nullopt;
    }

    const syrec::BinaryExpression::ptr generatedExpr = std::make_shared<syrec::BinaryExpression>(lhsOperandConverted, *syrec_operation::tryMapBinaryOperationEnumToFlag(*mappedToOperation), rhsOperandConverted);
    return generatedExpr;
}

syrec::Expression::ptr noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::transformExprBeforeProcessing(const syrec::Expression::ptr& initialExpr) {
    if (const auto& exprAsNumericExpr = std::dynamic_pointer_cast<syrec::NumericExpression>(initialExpr); exprAsNumericExpr) {
        if (const auto& exprConverted = convertNumericExprToBinary(*exprAsNumericExpr); exprConverted.has_value()) {
            return *exprConverted;
        }
    }
    return initialExpr;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesExprContainOverlappingAccessOnGivenSignalAccess(const syrec::Expression& expr, const syrec::VariableAccess& signalAccess, const parser::SymbolTable& symbolTable) {
    if (const auto& exprAsBinaryExpr = dynamic_cast<const syrec::BinaryExpression*>(&expr); exprAsBinaryExpr) {
        return doesExprContainOverlappingAccessOnGivenSignalAccess(*exprAsBinaryExpr->lhs, signalAccess, symbolTable) || doesExprContainOverlappingAccessOnGivenSignalAccess(*exprAsBinaryExpr->rhs, signalAccess, symbolTable);
    }
    if (const auto& exprAsShiftExpr = dynamic_cast<const syrec::ShiftExpression*>(&expr); exprAsShiftExpr) {
        return doesExprContainOverlappingAccessOnGivenSignalAccess(*exprAsShiftExpr->lhs, signalAccess, symbolTable) || doesNumberContainOverlappingAccessOnGivenSignalAccess(*exprAsShiftExpr->rhs, signalAccess, symbolTable);
    }
    if (const auto& exprAsVariableExpr = dynamic_cast<const syrec::VariableExpression*>(&expr); exprAsVariableExpr) {
        return doSignalAccessesOverlap(signalAccess, *exprAsVariableExpr->var, symbolTable);
    }
    if (const auto& exprAsNumericExpr = dynamic_cast<const syrec::NumericExpression*>(&expr); exprAsNumericExpr) {
        return doesNumberContainOverlappingAccessOnGivenSignalAccess(*exprAsNumericExpr->value, signalAccess, symbolTable);
    }
    return false;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesNumberContainOverlappingAccessOnGivenSignalAccess(const syrec::Number& number, const syrec::VariableAccess& signalAccess, const parser::SymbolTable& symbolTable) {
    if (!number.isCompileTimeConstantExpression()) {
        return false;
    }

    const auto& numericExprAsBinaryOne = convertCompileTimeConstantExprToBinaryExpr(number.getExpression(), 0);
    return numericExprAsBinaryOne.has_value() && doesExprContainOverlappingAccessOnGivenSignalAccess(**numericExprAsBinaryOne, signalAccess, symbolTable);
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doSignalAccessesOverlap(const syrec::VariableAccess& firstSignalAccess, const syrec::VariableAccess& otherSignalAccess, const parser::SymbolTable& symbolTable) {
    const SignalAccessUtils::SignalAccessEquivalenceResult equivalenceResult = SignalAccessUtils::areSignalAccessesEqual(
            firstSignalAccess, otherSignalAccess,
            SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::DimensionAccess::Overlapping,
            SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::BitRange::Overlapping,
            symbolTable);
    return !equivalenceResult.isResultCertain || equivalenceResult.equality != SignalAccessUtils::SignalAccessEquivalenceResult::NotEqual;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::areSignalAccessesSyntacticallyEquivalent(const syrec::VariableAccess& firstSignalAccess, const syrec::VariableAccess& otherSignalAccess, const parser::SymbolTable& symbolTable) {
    const SignalAccessUtils::SignalAccessEquivalenceResult equivalenceResult = SignalAccessUtils::areSignalAccessesEqual(
            firstSignalAccess, otherSignalAccess,
            SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::DimensionAccess::Equal,
            SignalAccessUtils::SignalAccessComponentEquivalenceCriteria::BitRange::Equal,
            symbolTable);
    return equivalenceResult.isResultCertain && equivalenceResult.equality == SignalAccessUtils::SignalAccessEquivalenceResult::Equal;
}

std::optional<unsigned> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineBitwidthOfSignalAccess(const syrec::VariableAccess& signalAccess) {
    if (!signalAccess.range.has_value()) {
        return signalAccess.var->bitwidth;
    }

    const std::optional<unsigned int> bitRangeStartEvaluated = evaluateNumber(*signalAccess.range->first);
    const std::optional<unsigned int> bitRangeEndEvaluated   = evaluateNumber(*signalAccess.range->second);
    if (!bitRangeStartEvaluated.has_value() || !bitRangeEndEvaluated.has_value()) {
        return std::nullopt;
    }
    return (*bitRangeEndEvaluated - *bitRangeStartEvaluated) + 1;
}

std::optional<unsigned> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::evaluateNumber(const syrec::Number& numberToEvaluate) {
    return numberToEvaluate.isConstant() ? std::make_optional(numberToEvaluate.evaluate({})) : std::nullopt;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesOperandSimplificationResultMatchExpression(const OperationNodeSimplificationResult& operandSimplificationResult, const syrec::Expression::ptr& exprToCheck) {
    if (const std::optional<syrec::VariableAccess::ptr>& signalAccessDataOfOperand = operandSimplificationResult.getResultAsSignalAccess(); signalAccessDataOfOperand.has_value()) {
        if (const std::shared_ptr<syrec::VariableExpression>& exprAsVariableExpr = std::dynamic_pointer_cast<syrec::VariableExpression>(exprToCheck); exprAsVariableExpr) {
            return *signalAccessDataOfOperand == exprAsVariableExpr->var;
        }
    } else if (const std::optional<syrec::Expression::ptr>& exprDataOfOperand = operandSimplificationResult.getResultAsExpr(); exprDataOfOperand.has_value()) {
        return *exprDataOfOperand == exprToCheck;
    }
    return false;
}

bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::doesOperandSimplificationResultMatchNumber(const OperationNodeSimplificationResult& operandSimplificationResult, const syrec::Number::ptr& numberToCheck) {
    if (const std::optional<syrec::Expression::ptr>& exprDataOfOperand = operandSimplificationResult.getResultAsExpr(); exprDataOfOperand.has_value()) {
        if (const std::shared_ptr<syrec::NumericExpression>& exprAsNumericExpr = std::dynamic_pointer_cast<syrec::NumericExpression>(*exprDataOfOperand); exprAsNumericExpr) {
            return exprAsNumericExpr->value == numberToCheck;
        }
    }
    return false;
}


std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::SimplificationResult::OwningCopyOfAssignment> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::createOwningCopyOfAssignment(const syrec::AssignStatement& assignment) {
    if (auto owningCopyOfAssignment = std::make_unique<syrec::AssignStatement>(assignment); owningCopyOfAssignment) {
        return owningCopyOfAssignment;
    }
    return std::nullopt;
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::SimplificationResult::OwningCopyOfAssignment> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::createOwningCopyOfAssignment(const syrec::UnaryStatement& assignment) {
    if (auto owningCopyOfAssignment = std::make_unique<syrec::UnaryStatement>(assignment); owningCopyOfAssignment) {
        return owningCopyOfAssignment;
    }
    return std::nullopt;
}


std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::SimplificationResult::OwningCopiesOfAssignment> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::createOwningCopiesOfAssignments(const std::vector<TemporaryAssignmentsContainer::AssignmentReferenceVariant>& assignments) {
    SimplificationResult::OwningCopiesOfAssignment containerForCopies;
    containerForCopies.reserve(assignments.size());

    bool copyingSuccessful = true;
    for (std::size_t i = 0; i < assignments.size() && copyingSuccessful; ++i) {
        const TemporaryAssignmentsContainer::AssignmentReferenceVariant& statementToTreatAsAssignment = assignments.at(i);
        if (std::holds_alternative<std::shared_ptr<syrec::AssignStatement>>(statementToTreatAsAssignment)) {
            const std::shared_ptr<syrec::AssignStatement> castedStatementAsBinaryAssignment = std::get<std::shared_ptr<syrec::AssignStatement>>(statementToTreatAsAssignment);
            if (std::optional<SimplificationResult::OwningCopyOfAssignment> copyOfAssignment = createOwningCopyOfAssignment(*castedStatementAsBinaryAssignment); copyOfAssignment.has_value()) {
                containerForCopies.push_back(std::move(*copyOfAssignment));
                continue;
            }    
        }
        else if (std::holds_alternative<std::shared_ptr<syrec::UnaryStatement>>(statementToTreatAsAssignment)) {
            const std::shared_ptr<syrec::UnaryStatement> castedStatementAsUnaryAssignment = std::get<std::shared_ptr<syrec::UnaryStatement>>(statementToTreatAsAssignment);
            if (std::optional<SimplificationResult::OwningCopyOfAssignment> copyOfAssignment = createOwningCopyOfAssignment(*castedStatementAsUnaryAssignment); copyOfAssignment.has_value()) {
                containerForCopies.push_back(std::move(*copyOfAssignment));
                continue;
            }
        }
        copyingSuccessful = false;
    }
    return copyingSuccessful ? std::make_optional(std::move(containerForCopies)) : std::nullopt;
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryAddCosts(std::optional<double>& currentSumOfCosts, const std::optional<double>& costsToAdd) {
    if (!costsToAdd.has_value() || !currentSumOfCosts.has_value()) {
        currentSumOfCosts.reset();
        return;
    }

    if (*costsToAdd < (UINT_MAX - *currentSumOfCosts)) {
        currentSumOfCosts = *currentSumOfCosts + *costsToAdd;
    } else {
        currentSumOfCosts.reset();
    }
}


std::vector<syrec::VariableAccess::ptr> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::determineSignalPartsNotUsableAsPotentialReplacementCandidates(const syrec::Expression& expr, const parser::SymbolTable& symbolTable) {
    if (const auto& exprAsBinaryExpr = dynamic_cast<const syrec::BinaryExpression*>(&expr); exprAsBinaryExpr) {
        std::vector<syrec::VariableAccess::ptr> notUsableCandidatesOfLhs = determineSignalPartsNotUsableAsPotentialReplacementCandidates(*exprAsBinaryExpr->lhs, symbolTable);
        const std::vector<syrec::VariableAccess::ptr> notUsableCandidatesOfRhs = determineSignalPartsNotUsableAsPotentialReplacementCandidates(*exprAsBinaryExpr->rhs, symbolTable);

        for (const syrec::VariableAccess::ptr& notUsableCandidateOfRhs : notUsableCandidatesOfRhs) {
            if (std::all_of(notUsableCandidatesOfLhs.cbegin(), notUsableCandidatesOfLhs.cend(), [&notUsableCandidateOfRhs, &symbolTable](const syrec::VariableAccess::ptr& notUsableCandidateOfLhs) { return !areSignalAccessesSyntacticallyEquivalent(*notUsableCandidateOfLhs, *notUsableCandidateOfRhs, symbolTable); })) {
                notUsableCandidatesOfLhs.emplace_back(notUsableCandidateOfRhs);
            }
        }
        return notUsableCandidatesOfLhs;
    }
    if (const auto& exprAsShiftExpr = dynamic_cast<const syrec::ShiftExpression*>(&expr); exprAsShiftExpr) {
        return determineSignalPartsNotUsableAsPotentialReplacementCandidates(*exprAsShiftExpr->lhs, symbolTable);
    }
    if (const auto& exprAsVariableExpr = dynamic_cast<const syrec::VariableExpression*>(&expr); exprAsVariableExpr) {
        if (symbolTable.canSignalBeAssignedTo(exprAsVariableExpr->var->var->name)) {
            return {exprAsVariableExpr->var};
        }
    }
    return {};
}


constexpr bool noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::shouldLogMessageBePrinted() {
    #ifndef NDEBUG
    return true;
    #else
    return false;
    #endif
}

std::string noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::stringifyChosenOperandForLogMessage(Decision::ChoosenOperand chosenOperand) {
    switch (chosenOperand) {
        case Decision::ChoosenOperand::Left:
            return "LEFT";
        case Decision::ChoosenOperand::Right:
            return "RIGHT";
        case Decision::ChoosenOperand::None:
            return "NONE";
        default:
            return "UNKNOWN";
    }
}

std::string noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::stringifyRepetitionOfChoice(Decision::ChoiceRepetition setRepetitionOfChoice) {
    switch (setRepetitionOfChoice) {
        case Decision::ChoiceRepetition::None:
            return "NONE";
        case Decision::ChoiceRepetition::UntilReset:
            return "UNTIL_RESET";
        case Decision::ChoiceRepetition::Always:
            return "ALWAYS";
        default:
            return "UNKNOWN";
    }
}


void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logDecision(const DecisionReference& madeDecision) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }
#ifndef NDEBUG
    logMessage(fmt::format("Decision @ operation node {:d} choose operand {:s} | Decision repetition flag: {:s} \n", madeDecision->operationNodeId, stringifyChosenOperandForLogMessage(madeDecision->choosenOperand), stringifyRepetitionOfChoice(madeDecision->shouldChoiceBeRepeated)));
#else
    return;
#endif
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logConflict(std::size_t operationNodeId, Decision::ChoosenOperand operandCausingConflict, const syrec::VariableAccess& signalAccessCausingConflict, const std::optional<std::size_t>& idOfEarliestDecisionInvolvedInConflict) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }

#ifndef NDEBUG
    const std::size_t printableIdOfEarliestOperationNodeInvolvedInConflict = idOfEarliestDecisionInvolvedInConflict.value_or(0);
    logMessage(fmt::format("Conflict @ operation node {:d} detected by usage of operand {:s} => signal access {:s} overlaps decision made in operation node {:d}\n", operationNodeId, stringifyChosenOperandForLogMessage(operandCausingConflict), signalAccessCausingConflict.var->name, printableIdOfEarliestOperationNodeInvolvedInConflict));
#else
    return;
#endif
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logStartOfProcessingOfOperationNode(std::size_t operationNodeId) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }

#ifndef NDEBUG
    logMessage(fmt::format("START Processing operation node {:d}\n", operationNodeId));
#else
    return;
#endif
    
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logEndOfProcessingOfOperationNode(std::size_t operationNodeId) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }
#ifndef NDEBUG
    logMessage(fmt::format("END Processing operation node {:d}\n", operationNodeId));
#else
    return;
#endif
    
}


void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logBacktrackingResult(std::size_t operationNodeIdAtStartOfBacktracking, std::size_t nextOperationNodeAfterBacktrackingFinished) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }
#ifndef NDEBUG
    logMessage(fmt::format("Backtracking started @ operation node with id {:d} | finished @ operation node with id {:d} as next to be processed\n", operationNodeIdAtStartOfBacktracking, nextOperationNodeAfterBacktrackingFinished));
#else
    return;
#endif
    
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logMarkingOfOperationNodeAsSourceOfConflict(std::size_t operationNodeId) {
    if constexpr (!shouldLogMessageBePrinted()) {
        return;
    }
#ifndef NDEBUG
    logMessage(fmt::format("Marking operation node {:d} as source of conflict\n", operationNodeId));
#else
    return;
#endif

}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logMessage(const std::string& msg) {
#ifndef NDEBUG
    fmt::print(stdout, msg);
#else
    return;
#endif
    
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logCreationOfSubstitutionOfOperandOfOperationNode(std::size_t operationNodeId, Decision::ChoosenOperand substitutedOperand, const syrec::VariableAccess& generatedSubstitution) {
#ifndef NDEBUG
    logMessage(fmt::format("{:s} operand in operation node {:d} was replaced with {:s}\n", stringifyChosenOperandForLogMessage(substitutedOperand), operationNodeId, generatedSubstitution.var->name));
#else
    return;
#endif
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logLearnedConflict(std::size_t operationNodeId, Decision::ChoosenOperand learnedConflictingChoiceOfOperand) {
#ifndef NDEBUG
    logMessage(fmt::format("Remembering conflict @ operation node {:d} due to choice of operand {:s}\n", operationNodeId, stringifyChosenOperandForLogMessage(learnedConflictingChoiceOfOperand)));
#else
    return;
#endif
}

void noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::logCreationOfSubstitutionOfExprOfOperationNode(std::size_t operationNodeId, const std::string& replacementSignalIdent, bool wasExistingEntryUpdated) {
#ifndef NDEBUG
    if (wasExistingEntryUpdated) {
        logMessage(fmt::format("Updated existing replacement (defined by assignment to replacement signal {:s}) for whole expression of operation node with id {:d}\n", replacementSignalIdent, operationNodeId));
    } else {
        logMessage(fmt::format("Created replacement signal {:s} for whole expression of operation node with id {:d}\n", replacementSignalIdent, operationNodeId));
    }
#else
    return;
#endif
}

noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionResult noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::makeDecisionFor(std::size_t operationNodeId, const OperationNodeSimplificationResult& lhsOperandSimplificationResult, syrec_operation::operation definedOperationOfOperationNode, const OperationNodeSimplificationResult& rhsOperandSimplificationResult, const std::optional<std::size_t>& idOfLastActiveAssignmentPriorToProcessingOfLhsOperand, const std::optional<std::size_t>& idOfLastActiveAssignmentPriorToProcessingOfRhsOperand, const SignalValueLookupCallback& signalValueLookupCallback) {
    const std::optional<syrec::Expression::ptr>&     lhsOperandAsExpr         = lhsOperandSimplificationResult.getResultAsExpr();
    const std::optional<syrec::VariableAccess::ptr>& lhsOperandAsSignalAccess = lhsOperandSimplificationResult.getResultAsSignalAccess();

    const std::optional<syrec::Expression::ptr>&     rhsOperandAsExpr         = rhsOperandSimplificationResult.getResultAsExpr();
    const std::optional<syrec::VariableAccess::ptr>& rhsOperandAsSignalAccess = rhsOperandSimplificationResult.getResultAsSignalAccess();

    const std::optional<syrec_operation::operation> definedOperationAsAssignmentOperation                      = syrec_operation::getMatchingAssignmentOperationForOperation(definedOperationOfOperationNode);
    const std::optional<unsigned int>               mappedToDefinedOperationAsAssignmentOperationFlagValue     = definedOperationAsAssignmentOperation.has_value() ? syrec_operation::tryMapAssignmentOperationEnumToFlag(*definedOperationAsAssignmentOperation) : std::nullopt;
    
    Decision::ChoosenOperand chosenOperand                              = Decision::ChoosenOperand::None;
    Decision::ChoosenOperand preferredOperandDueToInheritance            = Decision::ChoosenOperand::None;
    DecisionReference        previousDecisionForReferencedOperationNode = tryGetDecisionForOperationNode(operationNodeId).value_or(nullptr);
    if (!previousDecisionForReferencedOperationNode) {
        previousDecisionForReferencedOperationNode = constructAndRecordDefaultDecision(operationNodeId);
        if (!previousDecisionForReferencedOperationNode) {
            return DecisionResult::fromUnknownResult(UnknownResultReason::Other);
        }
    }

    const bool canAssignmentBeGeneratedBasedOnOperation = definedOperationAsAssignmentOperation.has_value() && mappedToDefinedOperationAsAssignmentOperationFlagValue.has_value();
    const bool isAssignmentOperationCommutative         = mappedToDefinedOperationAsAssignmentOperationFlagValue.has_value() ? syrec_operation::isCommutative(definedOperationOfOperationNode) : false;

    std::optional<std::size_t> idOfLatestActiveAssignmentOverlappingLhsOperand;
    std::optional<std::size_t> idOfLatestActiveAssignmentOverlappingRhsOperand;
    if (previousDecisionForReferencedOperationNode->shouldChoiceBeRepeated != Decision::ChoiceRepetition::Always) {
        previousDecisionForReferencedOperationNode->shouldChoiceBeRepeated = Decision::ChoiceRepetition::None;
        previousDecisionForReferencedOperationNode->choosenOperand         = Decision::ChoosenOperand::None;

        /*
         * If both operands define signal accesses either due to the operand being a signal access or by being created from an assignment, with the lhs operand being manually created (i.e. the original operand already being a
         * signal access) and the rhs operand being created from an assignment, we prefer to reuse the assigned to signal parts of the latter if a choice between both operands is possible. Otherwise, the preferred operand is the
         * lhs one.
         */
        if (lhsOperandAsSignalAccess.has_value() && lhsOperandSimplificationResult.wasResultManuallyCreated() && rhsOperandAsSignalAccess.has_value() && !rhsOperandSimplificationResult.wasResultManuallyCreated() 
            && isAssignmentOperationCommutative && canAlternativeByChosenInOperationNode(operationNodeId, Decision::ChoosenOperand::Right, **lhsOperandAsSignalAccess, **rhsOperandAsSignalAccess, *symbolTableReference)) {
            preferredOperandDueToInheritance = Decision::ChoosenOperand::Right;
        }
    }

    const std::optional<std::size_t> operationNodeOfRhsOperandOfThisOperationNode = expressionTraversalHelper->getOperationNodeIdOfRightOperand(operationNodeId);
    if (lhsOperandAsSignalAccess.has_value() && previousDecisionForReferencedOperationNode->choosenOperand != Decision::ChoosenOperand::Left) {
        const std::size_t                  searchForActiveAssignmentExclusionRangeForLowerBoundDefinedByAssociatedOperationNodeId = operationNodeId;
        const std::size_t                  searchForActiveAssignmentExclusionRangeForUpperBoundDefinedByAssociatedOperationNodeId = operationNodeOfRhsOperandOfThisOperationNode.value_or(SIZE_MAX) - 1;
        constexpr Decision::ChoosenOperand potentialOperandChoice                                                                 = Decision::ChoosenOperand::Left;
        /*
         * If can find an active assignment that overlaps with the given accessed signal parts of the operand we need to check whether found assignment is a data dependency of another active
         * assignment because then we can safely invert the found assignment without the inversion affecting other currently active ones (Since our check for an overlapping assignment will return the latest [i.e. earliest relative to the last added active assignment] our subsequent check for it being a data dependency will ignore
         * prior active assignments that propagated the assigned to signal parts to the found one). Otherwise, if the assignment was no data dependency of another active assignment, we found a conflict.
         */
        if (idOfLatestActiveAssignmentOverlappingLhsOperand = generatedAssignmentsContainer->getOverlappingActiveAssignmentForSignalAccessWithIdNotInRange(**lhsOperandAsSignalAccess, searchForActiveAssignmentExclusionRangeForLowerBoundDefinedByAssociatedOperationNodeId, searchForActiveAssignmentExclusionRangeForUpperBoundDefinedByAssociatedOperationNodeId, *symbolTableReference); idOfLatestActiveAssignmentOverlappingLhsOperand.has_value()
            && !generatedAssignmentsContainer->existsActiveAssignmentHavingGivenAssignmentAsDataDependency(*idOfLatestActiveAssignmentOverlappingLhsOperand)) {
            if (const std::optional<syrec::VariableAccess::ptr>& generatedSubstitutionForLhsOperand = lhsOperandSimplificationResult.wasResultManuallyCreated() ? createReplacementForChosenOperand(previousDecisionForReferencedOperationNode, signalValueLookupCallback) : std::nullopt; generatedSubstitutionForLhsOperand.has_value()) {
                logCreationOfSubstitutionOfOperandOfOperationNode(operationNodeId, potentialOperandChoice, **generatedSubstitutionForLhsOperand);
                previousDecisionForReferencedOperationNode->shouldChoiceBeRepeated = Decision::ChoiceRepetition::Always;
                previousDecisionForReferencedOperationNode->choosenOperand         = potentialOperandChoice;
            } else {
                handleConflict(operationNodeId, potentialOperandChoice, **lhsOperandAsSignalAccess);
                return DecisionResult::fromUnknownResult(UnknownResultReason::Conflict);
            }
        }
        else if (preferredOperandDueToInheritance == Decision::ChoosenOperand::None && canAssignmentBeGeneratedBasedOnOperation &&
            (((rhsOperandAsSignalAccess.has_value() && canAlternativeByChosenInOperationNode(operationNodeId, potentialOperandChoice, **lhsOperandAsSignalAccess, **rhsOperandAsSignalAccess, *symbolTableReference)) 
                || (rhsOperandAsExpr.has_value() && canAlternativeByChosenInOperationNode(operationNodeId, potentialOperandChoice, **lhsOperandAsSignalAccess, **rhsOperandAsExpr, *symbolTableReference))))) {
            chosenOperand = potentialOperandChoice;
        }
    }

    if (rhsOperandAsSignalAccess.has_value() && previousDecisionForReferencedOperationNode->choosenOperand != Decision::ChoosenOperand::Right) {
        const std::size_t                  searchForActiveAssignmentExclusionRangeForLowerBoundDefinedByAssociatedOperationNodeId = operationNodeOfRhsOperandOfThisOperationNode.value_or(SIZE_MAX);
        constexpr std::size_t              searchForActiveAssignmentExclusionRangeForUpperBoundDefinedByAssociatedOperationNodeId = SIZE_MAX;
        constexpr Decision::ChoosenOperand potentialOperandChoice                                                                 = Decision::ChoosenOperand::Right;

        /*
         * If can find an active assignment that overlaps with the given accessed signal parts of the operand we need to check whether found assignment is a data dependency of another active
         * assignment because then we can safely invert the found assignment without the inversion affecting other currently active ones (Since our check for an overlapping assignment will return the latest [i.e. earliest relative to the last added active assignment] our subsequent check for it being a data dependency will ignore
         * prior active assignments that propagated the assigned to signal parts to the found one). Otherwise, if the assignment was no data dependency of another active assignment, we found a conflict.
         */
        if (idOfLatestActiveAssignmentOverlappingRhsOperand = generatedAssignmentsContainer->getOverlappingActiveAssignmentForSignalAccessWithIdNotInRange(**rhsOperandAsSignalAccess, searchForActiveAssignmentExclusionRangeForLowerBoundDefinedByAssociatedOperationNodeId, searchForActiveAssignmentExclusionRangeForUpperBoundDefinedByAssociatedOperationNodeId, *symbolTableReference); idOfLatestActiveAssignmentOverlappingRhsOperand.has_value() && !generatedAssignmentsContainer->existsActiveAssignmentHavingGivenAssignmentAsDataDependency(*idOfLatestActiveAssignmentOverlappingRhsOperand)) {
            if (const std::optional<syrec::VariableAccess::ptr>& generatedSubstitutionForRhsOperand = rhsOperandSimplificationResult.wasResultManuallyCreated() ? createReplacementForChosenOperand(previousDecisionForReferencedOperationNode, signalValueLookupCallback) : std::nullopt; generatedSubstitutionForRhsOperand.has_value()) {
                logCreationOfSubstitutionOfOperandOfOperationNode(operationNodeId, potentialOperandChoice, **generatedSubstitutionForRhsOperand);
                if (chosenOperand == Decision::ChoosenOperand::None) {
                    previousDecisionForReferencedOperationNode->shouldChoiceBeRepeated = Decision::ChoiceRepetition::Always;
                    previousDecisionForReferencedOperationNode->choosenOperand         = potentialOperandChoice;   
                }
            }
            else {
                handleConflict(operationNodeId, potentialOperandChoice, **rhsOperandAsSignalAccess);
                return DecisionResult::fromUnknownResult(UnknownResultReason::Conflict);   
            }
        }
        else if (chosenOperand == Decision::ChoosenOperand::None && isAssignmentOperationCommutative && ((lhsOperandAsSignalAccess.has_value() && canAlternativeByChosenInOperationNode(operationNodeId, potentialOperandChoice, **rhsOperandAsSignalAccess, **lhsOperandAsSignalAccess, *symbolTableReference)) || (lhsOperandAsExpr.has_value() && canAlternativeByChosenInOperationNode(operationNodeId, potentialOperandChoice, **rhsOperandAsSignalAccess, **lhsOperandAsExpr, *symbolTableReference)))) {
            chosenOperand = potentialOperandChoice;
        }
    }

    const std::vector<std::size_t> dataDependenciesAsIdsOfDependentAssignmentsOfLhsOperand = (lhsOperandAsSignalAccess.has_value() && !lhsOperandSimplificationResult.wasResultManuallyCreated()) ? std::vector(1, lhsOperandSimplificationResult.getIdOfGeneratedAssignment().value()) : lhsOperandSimplificationResult.getDataDependenciesAsIdsOfDependentAssignments();
    const std::vector<std::size_t> dataDependenciesAsIdsOfDependentAssignmentsOfRhsOperand = (rhsOperandAsSignalAccess.has_value() && !rhsOperandSimplificationResult.wasResultManuallyCreated()) ? std::vector(1, rhsOperandSimplificationResult.getIdOfGeneratedAssignment().value()) : rhsOperandSimplificationResult.getDataDependenciesAsIdsOfDependentAssignments();
    if (chosenOperand != Decision::ChoosenOperand::None && mappedToDefinedOperationAsAssignmentOperationFlagValue.has_value()) {
        // GENERATE ASSIGNMENT
        // INVERSIONS OF DATA DEPENDENCIES, ETC.
        syrec::VariableAccess::ptr                                  generatedAssignmentLhs;
        syrec::Expression::ptr                                      generatedAssignmentRhs;
        TemporaryAssignmentsContainer::OrderedAssignmentIdContainer dataDependenciesOfGeneratedAssignmentRhs;

        if (chosenOperand == Decision::ChoosenOperand::Left) {
            generatedAssignmentLhs                   = *lhsOperandAsSignalAccess;
            if (rhsOperandAsExpr.has_value()) {
                generatedAssignmentRhs = *rhsOperandAsExpr;
                dataDependenciesOfGeneratedAssignmentRhs.insert(dataDependenciesAsIdsOfDependentAssignmentsOfRhsOperand.cbegin(), dataDependenciesAsIdsOfDependentAssignmentsOfRhsOperand.cend());
            }
            else {
                generatedAssignmentRhs = std::make_shared<syrec::VariableExpression>(*rhsOperandAsSignalAccess);
                if (const std::optional<std::size_t> idOfAssociatedAssignmentForRhsOperand = rhsOperandSimplificationResult.getIdOfGeneratedAssignment(); idOfAssociatedAssignmentForRhsOperand.has_value()) {
                    dataDependenciesOfGeneratedAssignmentRhs.emplace(*idOfAssociatedAssignmentForRhsOperand);
                }
            }
        } else {
            generatedAssignmentLhs                   = *rhsOperandAsSignalAccess;
            if (lhsOperandAsExpr.has_value()) {
                generatedAssignmentRhs = *lhsOperandAsExpr;
                dataDependenciesOfGeneratedAssignmentRhs.insert(dataDependenciesAsIdsOfDependentAssignmentsOfLhsOperand.cbegin(), dataDependenciesAsIdsOfDependentAssignmentsOfLhsOperand.cend());
            } else {
                generatedAssignmentRhs = std::make_shared<syrec::VariableExpression>(*lhsOperandAsSignalAccess);
                if (const std::optional<std::size_t> idOfAssociatedAssignmentForLhsOperand = lhsOperandSimplificationResult.getIdOfGeneratedAssignment(); idOfAssociatedAssignmentForLhsOperand.has_value()) {
                    dataDependenciesOfGeneratedAssignmentRhs.emplace(*idOfAssociatedAssignmentForLhsOperand);
                }
            }
        }

        const std::shared_ptr<syrec::AssignStatement> generatedAssignment = generatedAssignmentRhs ? std::make_shared<syrec::AssignStatement>(generatedAssignmentLhs, *mappedToDefinedOperationAsAssignmentOperationFlagValue, generatedAssignmentRhs) : nullptr;
        if (!generatedAssignment) {
            return DecisionResult::fromUnknownResult(UnknownResultReason::Other);
        }
        logDecision(previousDecisionForReferencedOperationNode);

        std::size_t                idOfFirstAssignmentToInvert;
        std::optional<std::size_t> idOfLastAssignmentToInvert;
        if (chosenOperand == Decision::ChoosenOperand::Left) {
            if (!idOfLastActiveAssignmentPriorToProcessingOfRhsOperand.has_value() || !*idOfLastActiveAssignmentPriorToProcessingOfRhsOperand) {
                idOfFirstAssignmentToInvert = SIZE_MAX;
            }
            else {
                idOfFirstAssignmentToInvert = *idOfLastActiveAssignmentPriorToProcessingOfRhsOperand;    
            }
            idOfLastAssignmentToInvert  = std::nullopt;
        }
        else {
            if (!idOfLastActiveAssignmentPriorToProcessingOfLhsOperand.has_value() || !*idOfLastActiveAssignmentPriorToProcessingOfLhsOperand) {
                idOfFirstAssignmentToInvert = idOfLastActiveAssignmentPriorToProcessingOfRhsOperand.value_or(SIZE_MAX);
                idOfLastAssignmentToInvert  = idOfFirstAssignmentToInvert;
            }
            else {
                idOfFirstAssignmentToInvert = *idOfLastActiveAssignmentPriorToProcessingOfLhsOperand;
                idOfLastAssignmentToInvert  = idOfLastActiveAssignmentPriorToProcessingOfRhsOperand.has_value() ? idOfLastActiveAssignmentPriorToProcessingOfRhsOperand.value() : 0;   
            }
        }
        
        const TemporaryAssignmentsContainer::OrderedAssignmentIdContainer containerForDataDependenciesOfGeneratedAssignmentRhs(dataDependenciesOfGeneratedAssignmentRhs.begin(), dataDependenciesOfGeneratedAssignmentRhs.end());
        const std::optional<std::size_t>                                  idOfAssignmentFromWhichAssignedToPartsWereInherited = chosenOperand == Decision::ChoosenOperand::Left ? lhsOperandSimplificationResult.getIdOfGeneratedAssignment() : rhsOperandSimplificationResult.getIdOfGeneratedAssignment();
        if (const std::optional<std::size_t>& idOfGeneratedAssignment = generatedAssignmentsContainer->storeActiveAssignment(generatedAssignment, idOfAssignmentFromWhichAssignedToPartsWereInherited, containerForDataDependenciesOfGeneratedAssignmentRhs, operationNodeId, std::nullopt); idOfGeneratedAssignment.has_value()) {
            // Since we are adding the generated assignment prior to the inversion of its data dependencies, we also need to update our upper bound of our open interval when the lhs operand was chosen as assigned to signal of the assignment
            if (chosenOperand == Decision::ChoosenOperand::Left) {
                idOfLastAssignmentToInvert = *idOfGeneratedAssignment;
            }
            if (!generatedAssignmentsContainer->invertAssignmentsWithIdInRange(idOfFirstAssignmentToInvert, idOfLastAssignmentToInvert)) {
                return DecisionResult::fromUnknownResult(UnknownResultReason::Other);
            }
            previousDecisionForReferencedOperationNode->choosenOperand = chosenOperand;   

            /*
             * Since we try to learn conflicts at operation nodes where either or both operands are leaf nodes (learning a conflict at an operation node with no leaf nodes could prevent the usage of a
             * now valid operand propagated from node N1 matching a previous conflict found in N2 using the same operand), decisions where an operand was inherited (i.e. the original operand was an expression
             * was now transformed to an assignment), will not be considered as a source of a conflict to allow traversal to the child node causing the initial choice that will be propagated to said decision.
             */
            if (chosenOperand == Decision::ChoosenOperand::Left && lhsOperandAsExpr.has_value()) {
                previousDecisionForReferencedOperationNode->inheritedOperandDataForChoice = *lhsOperandAsSignalAccess;
            } else if (chosenOperand == Decision::ChoosenOperand::Right && rhsOperandAsExpr.has_value()) {
                previousDecisionForReferencedOperationNode->inheritedOperandDataForChoice = *rhsOperandAsSignalAccess;
            }
            return DecisionResult::fromGeneratedAssignment(generatedAssignment, *idOfGeneratedAssignment);
        }
        return DecisionResult::fromUnknownResult(UnknownResultReason::Other);
    }

    // FUSE EXPRESSIONS
    const syrec::Expression::ptr generatedExprLhsExpr = lhsOperandAsExpr.has_value() ? *lhsOperandAsExpr : std::make_shared<syrec::VariableExpression>(*lhsOperandAsSignalAccess);
    const syrec::Expression::ptr generatedExprRhsExpr = rhsOperandAsExpr.has_value() ? *rhsOperandAsExpr : std::make_shared<syrec::VariableExpression>(*rhsOperandAsSignalAccess);
    if (generatedExprLhsExpr && generatedExprRhsExpr) {
        std::vector<std::size_t> fusedDataDependencies;
        fusedDataDependencies.reserve(dataDependenciesAsIdsOfDependentAssignmentsOfLhsOperand.size() + dataDependenciesAsIdsOfDependentAssignmentsOfRhsOperand.size());
        // TODO: What if this allocation fails?
        fusedDataDependencies.insert(fusedDataDependencies.end(), dataDependenciesAsIdsOfDependentAssignmentsOfLhsOperand.cbegin(), dataDependenciesAsIdsOfDependentAssignmentsOfLhsOperand.cend());
        fusedDataDependencies.insert(fusedDataDependencies.end(), dataDependenciesAsIdsOfDependentAssignmentsOfRhsOperand.cbegin(), dataDependenciesAsIdsOfDependentAssignmentsOfRhsOperand.cend());

        /*
         * Replacing the topmost expression via a replacement does not lead to any improvement and would only introduce unnecessary additional signals.
         * Furthermore, we assume that the topmost operation node has an id with value 0.
         */
        if (operationNodeId) {
            bool wasExistingReplacementUpdated = false;
            if (const std::optional<std::pair<std::size_t, std::shared_ptr<syrec::AssignStatement>>>& idAndDataOfGeneratedReplacementForWholeExpr = getAndActivateReplacementForOperationNode(operationNodeId, definedOperationOfOperationNode, lhsOperandSimplificationResult, rhsOperandSimplificationResult, &wasExistingReplacementUpdated, signalValueLookupCallback); idAndDataOfGeneratedReplacementForWholeExpr.has_value()) {
                const std::optional<std::size_t> lowerBoundOfClosedIntervalOfAssignmentIdsToInvert = generatedAssignmentsContainer->findDataDependencyOfCurrentAndChildAssignmentsFittingCriteria(fusedDataDependencies, TemporaryAssignmentsContainer::DataDependencySortCriteria::Smallest);
                std::optional<std::size_t> upperBoundOfClosedIntervalOfAssignmentIdsToInvert = generatedAssignmentsContainer->findDataDependencyOfCurrentAndChildAssignmentsFittingCriteria(fusedDataDependencies, TemporaryAssignmentsContainer::DataDependencySortCriteria::Largest);

                if (lowerBoundOfClosedIntervalOfAssignmentIdsToInvert.has_value() && upperBoundOfClosedIntervalOfAssignmentIdsToInvert.has_value()) {
                    if (*upperBoundOfClosedIntervalOfAssignmentIdsToInvert == SIZE_MAX) {
                        upperBoundOfClosedIntervalOfAssignmentIdsToInvert = std::nullopt;
                    }
                    else {
                        upperBoundOfClosedIntervalOfAssignmentIdsToInvert = *upperBoundOfClosedIntervalOfAssignmentIdsToInvert + 1;
                    }

                    if (!generatedAssignmentsContainer->invertAssignmentsWithIdInRange(*lowerBoundOfClosedIntervalOfAssignmentIdsToInvert - 1, upperBoundOfClosedIntervalOfAssignmentIdsToInvert)) {
                        return DecisionResult::fromUnknownResult(UnknownResultReason::Other);
                    }
                }

                const std::shared_ptr<syrec::VariableAccess>& assignedToSignalParts = idAndDataOfGeneratedReplacementForWholeExpr.value().second->lhs;
                /*
                * Since we use the expression traversal helper to determine whether a signal ident refers to an assignable signal in our implementation of a decision, and due to the fact that said
                * lookup is initially built during the generation of the traversal data from the initial assignment right-hand side expression, we need to manually add the generated replacement signal
                * as an assignable signal.
                */
                expressionTraversalHelper->markSignalAsAssignable(assignedToSignalParts->var->name);
                logCreationOfSubstitutionOfExprOfOperationNode(operationNodeId, assignedToSignalParts->var->name, wasExistingReplacementUpdated);
                return DecisionResult::fromGeneratedAssignment(idAndDataOfGeneratedReplacementForWholeExpr.value().second, idAndDataOfGeneratedReplacementForWholeExpr.value().first);
            }    
        }

        if (const std::optional<syrec::Expression::ptr> fusedExpression = fuseExpressions(generatedExprLhsExpr, definedOperationOfOperationNode, generatedExprRhsExpr); fusedExpression) {
            logDecision(previousDecisionForReferencedOperationNode);
            return DecisionResult::fromGeneratedExpression(*fusedExpression, fusedDataDependencies);
        }
    }
    return DecisionResult::fromUnknownResult(UnknownResultReason::Other);
}

noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::constructAndRecordDefaultDecision(std::size_t operationNodeId) {
    if (DecisionReference generatedDefaultDecision = constructDefaultDecision(operationNodeId); generatedDefaultDecision) {
        pastDecisions.emplace(generatedDefaultDecision);
        return generatedDefaultDecision;
    }
    return nullptr;
}

noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::DecisionReference noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::constructDefaultDecision(std::size_t operationNodeId) {
    return std::make_shared<Decision>(Decision({operationNodeId, 0, Decision::ChoosenOperand::None, Decision::ChoiceRepetition::UntilReset, nullptr}));
}

std::optional<noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::OperationNodeSimplificationResult::OwningReference> noAdditionalLineSynthesis::AssignmentWithoutAdditionalLineSimplifier::tryPerformTransformationOfDecisionResultToOperationNodeSimplificationResultWhenNoConflictWasDetected(std::size_t operationNodeId, const DecisionResult& decisionResult) {
    if (decisionResult.data.has_value()) {
        if (const std::optional<syrec::Expression::ptr>& generatedExpressionByDecision = decisionResult.getGeneratedExpression(); generatedExpressionByDecision.has_value()) {
            return OperationNodeSimplificationResult::createAndOwnNewInstance(OperationNodeSimplificationResult::createFromNonLeafNode(operationNodeId, *generatedExpressionByDecision, decisionResult.dataDependenciesOfGeneratedResult));
        }
        const OperationNodeSimplificationResult::IdAndAssignmentTuple generatedAssignmentData = std::make_pair(*decisionResult.idOfGeneratedAssignment, *decisionResult.getAssignedToSignalParts());
        return OperationNodeSimplificationResult::createAndOwnNewInstance(OperationNodeSimplificationResult::createFromNonLeafNode(operationNodeId, generatedAssignmentData, decisionResult.dataDependenciesOfGeneratedResult));
    }
    if (decisionResult.reasonForUnknownResult.value_or(UnknownResultReason::Other) == UnknownResultReason::Conflict) {
        return std::nullopt;
    }
    return OperationNodeSimplificationResult::createAndOwnNewInstance(OperationNodeSimplificationResult::createAsUnknownResult(UnknownResultReason::Other));
}