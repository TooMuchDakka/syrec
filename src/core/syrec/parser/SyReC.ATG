/*-------------------------------------------------------------------------
ATG for SyReC: A Programming Language for Synthesis of Reversible Circuits
(specification available @ http://www.revlib.org/doc/docu/revlib_2_0_1.pdf)

User manual for Coco/R is available @
https://ssw.jku.at/Research/Projects/Coco/Doc/UserManual.pdf
-------------------------------------------------------------------------*/
$namespace=syrec
/*-- $checkEOF=false --*/

// Place includes here
#include <cwchar>
#include <optional>
#include <set>
#include <string>
#include <variant>
#include <vector>

#include "core/syrec/module.hpp"
#include "core/syrec/parser/parser_error_message_generator.hpp"
#include "core/syrec/parser/symbol_table.hpp"
#include "core/syrec/parser/text_utils.hpp"

COMPILER SyReC
	
	typedef std::optional<std::variant<variable_access::ptr, number::ptr>> signal_evaluation_result;
	typedef std::optional<std::variant<binary_expression, numeric_expression, shift_expression, variable_expression>> expression_evaluation_result;

	// Place declarations of objects referenced in this ATG
	module::vec modules;
	parser_error_message_generator error_message_generator;
	symbol_table::ptr current_symbol_table_scope;

	// This method will be called by the contructor if it exits.
	// This support is specific to the C++ version of Coco/R.
	void Init() {
		// nothing to do
		symbol_table::open_scope(current_symbol_table_scope);
	}

	// Uncomment this method if cleanup is necessary,
	// this method will be called by the destructor if it exists.
	// This support is specific to the C++ version of Coco/R.
	// void Destroy() {
		// nothing to do
	// }

	[[nodiscard]] bool are_token_values_equal(const wchar_t *my_token_value, const wchar_t *other_token_value) const {
		if (my_token_value == nullptr || other_token_value == nullptr) {
			// TODO: Could also throw exception
			return false;
		}
		return !wcscmp(my_token_value, other_token_value);
	}

	[[nodiscard]] bool token_matches_one_of(const Token *tokenToCheck, std::vector<std::wstring> one_of_many_token_values) const {
        const std::set<std::wstring> set_of_matching_token_values{std::begin(one_of_many_token_values), std::end(one_of_many_token_values)};
        return set_of_matching_token_values.count(tokenToCheck->val);
	}

	[[nodiscard]] bool find_matching_token(std::vector<std::wstring> matching_token_values, std::vector<std::wstring> token_values_allowing_stop_of_search) const {
		const std::set<std::wstring> set_of_matching_token_values { std::begin(matching_token_values), std::end(matching_token_values) };
		const std::set<std::wstring> set_of_token_values_allowing_stop_of_search { std::begin(token_values_allowing_stop_of_search), std::end(token_values_allowing_stop_of_search) };
		bool found_matching_operator = false;
		bool can_cancel_search = false;

		while (!can_cancel_search) {
			const Token *peeked_token = scanner->Peek();
			found_matching_operator = set_of_matching_token_values.count(peeked_token->val);
			can_cancel_search = found_matching_operator || peeked_token->kind == _EOF || set_of_token_values_allowing_stop_of_search.count(peeked_token->val);
		}
		return found_matching_operator;
	}

	[[nodiscard]] bool check_if_is_assign_statement() const {
		const std::vector<std::wstring> matching_tokens = {L"^", L"+", L"-"};
		const std::vector<std::wstring> tokens_resulting_in_check_being_false = {L";", L"<=>"};

		return find_matching_token(matching_tokens, tokens_resulting_in_check_being_false);
	}

	[[nodiscard]] bool check_if_expression_is_binary_expression() const {
		// Since first LL(1) conflict resolver already started peeking and failed to resolve the conflict, we need to reset the peek position to original one
		scanner->ResetPeek();

		const std::set<std::wstring> tokens_resulting_in_check_being_false {L"+", L"-", L"^", L"*", L"/", L"%", L"*>", L"&&", L"||", L"&", L"|", L"<", L">", L"=", L"!=", L"<=", L">="};
		const std::set<std::wstring> set_of_operator_token_values_of_alternative {L"<<", L">>"};

		bool found_matching_operator = false;
		bool can_cancel_search = false;
		int expression_nesting_level = 0;

		while (!can_cancel_search) {
			const Token *peeked_token = scanner->Peek();

			if (are_token_values_equal(peeked_token->val, L"(")) {
				expression_nesting_level++;
			} 
			else if (are_token_values_equal(peeked_token->val, L")")) {
				expression_nesting_level--;
			}
			else {
				found_matching_operator = expression_nesting_level == 0 && tokens_resulting_in_check_being_false.count(peeked_token->val);
				can_cancel_search = found_matching_operator || set_of_operator_token_values_of_alternative.count(peeked_token->val) || peeked_token->kind == _EOF;			
			}

		}
		return found_matching_operator;
	}

	[[nodiscard]] bool is_token_not_nested_number(const Token *token) const {
		if (token == nullptr) {
			return false;
		}
		return token->kind == _int || are_token_values_equal(token->val, L"#") || are_token_values_equal(token->val, L"$");
	}

	[[nodiscard]] bool check_if_expression_is_number(const Token *first_token_of_expression) const {
        bool found_matching_operator;
        const std::vector<std::wstring> matching_tokens = {L"^", L"+", L"-", L"*"};

        if (are_token_values_equal(first_token_of_expression->val, L"(")) {
            found_matching_operator = check_if_expression_is_number(scanner->Peek())
                && token_matches_one_of(scanner->Peek(), matching_tokens)
                && check_if_expression_is_number(scanner->Peek())
                && are_token_values_equal(scanner->Peek()->val, L")");
        } else {
            found_matching_operator = is_token_not_nested_number(first_token_of_expression);
        }
        return found_matching_operator;
	}

	[[nodiscard]] bool check_if_expression_is_number() const {
        return la != nullptr && check_if_expression_is_number(la);
	}

	[[nodiscard]] bool check_if_loop_variable_is_defined() const {
		// Since first LL(1) conflict resolver already started peeking and failed to resolve the conflict, we need to reset the peek position to original one
		scanner->ResetPeek();
		const std::vector<std::wstring> matching_tokens = {L"="};
		const std::vector<std::wstring> tokens_resulting_in_check_being_false = {L"rof"};

		return find_matching_token(matching_tokens, tokens_resulting_in_check_being_false);
	}

	[[nodiscard]] bool check_if_loop_iteration_range_start_is_defined() const {
		const std::vector<std::wstring> matching_tokens = {L"to"};
		const std::vector<std::wstring> tokens_resulting_in_check_being_false = {L"rof"};

		return find_matching_token(matching_tokens, tokens_resulting_in_check_being_false);
	}

/*-------------------------------------------------------------------------*/

CHARACTERS
	letter		= 'A' .. 'Z' + 'a' .. 'z'.
	digit		= '0' .. '9'.

	cr        = '\r'.
	lf        = '\n'.
	tab       = '\t'.

TOKENS
	ident		= ('_' | letter) {('_' | letter | digit)}.
	int			= digit {digit}.
	
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/
PRODUCTIONS

/*-------------------------------------------------------------------------
Since Coco/R does not accept recursive token definitions, 
we redefine the token 'number as a non-terminal symbol
-------------------------------------------------------------------------*/
Number<. std::optional<number::ptr> &number .>									
=
int 
| '#' ident 
| '$' ident 
| (																			(.	std::optional<number::ptr> lhs_operand, rhs_operand;	.)
	'(' 
		Number<lhs_operand>
		('+'
		|'-'
		|'*'
		|'/'
		) 
		Number<rhs_operand>
	')'
)
.

/*-------------------------------------------------------------------------
Program and Modules
-------------------------------------------------------------------------*/

SyReC								(.	std::optional<module::ptr> module;	.)
=
Module<module>						(.	if (module.has_value()) {
											current_symbol_table_scope->add_entry(module.value());
										}
									.)
{									(.	module.reset();	.)
	Module<module>					(.	if (module.has_value()) {
											const module::ptr well_formed_module = module.value();
											if (current_symbol_table_scope->contains(well_formed_module)) {
												// TODO: GEN_ERROR 
												// TODO: Do not cancel parsing	
											}
											else {
												current_symbol_table_scope->add_entry(well_formed_module);
											}
										}
									.)
}
.

Module <. std::optional<module::ptr> &parsed_module	.>			(.	symbol_table::open_scope(current_symbol_table_scope);
																	std::optional<std::vector<variable::ptr>> locals;	
																	bool valid_module_definition = false;
																.)	
=
"module" ident													(.	const std::string module_name = convert_to_uniform_text_format(t->val);	
																	module::ptr user_defined_module = std::make_shared<module>(module(module_name));
																.)	
"(" [ParameterList<valid_module_definition, user_defined_module>] ")" 
{
	SignalList<locals>											(.	valid_module_definition &= locals.has_value();	.)
}														
StatementList													(.	symbol_table::close_scope(current_symbol_table_scope);
																	if (valid_module_definition) {
															
																		user_defined_module->variables = locals.value_or(std::vector<variable::ptr>{});
																		parsed_module.emplace(user_defined_module);
																	}
																.)
.

ParameterList<bool &is_valid_module_definition, const module::ptr &module>			(.	std::optional<variable::ptr> parameter;	.)
=
Parameter<parameter>																(.	is_valid_module_definition = parameter.has_value();
																						if (is_valid_module_definition) {
																							module->add_parameter(parameter.value());
																							current_symbol_table_scope->add_entry(parameter.value());
																						}
																					.)
{																					(.	parameter.reset();	.)
	"," Parameter<parameter>														(.	is_valid_module_definition = parameter.has_value();
																						const variable::ptr well_formed_parameter = parameter.value();
																						if (is_valid_module_definition && !current_symbol_table_scope->contains(well_formed_parameter->name)) {
																							module->add_parameter(well_formed_parameter);
																							current_symbol_table_scope->add_entry(well_formed_parameter);
																						}
																						else {
																							// TODO: GEN_ERROR 
																						}
																					.)
}															
.

Parameter<. std::optional<variable::ptr> &parameter .>								(.	variable::types parameter_type = variable::wire;
																						bool valid_variable_type = true;
																					.)	
= 
(
	"in"																			(.	parameter_type = variable::in;	.)
	| "out"																			(.	parameter_type = variable::out;	.)
	| "inout"																		(.	parameter_type = variable::inout;	.)	
)																					(.	if (variable::wire == parameter_type) {
																							// TODO: GEN_ERROR 
																							// TODO: Do not cancel parsing
																							valid_variable_type = false;
																						}
																					.)
SignalDeclaration<parameter_type, parameter>										(.	if (!valid_variable_type) {
																							parameter.reset();
																						}
																					.)
.

SignalList <. std::optional<std::vector<variable::ptr>> &signals .>	(.	variable::types signal_type = variable::in;
																		std::optional<variable::ptr> declared_signal;
																		bool valid_signal_type = true;
																		std::vector<variable::ptr> valid_signal_declarations;
																	.)
=
(
	"wire"															(.	signal_type = variable::wire;		.)
	| "signal"														(.	signal_type = variable::state;		.)
)																	(.	if (variable::wire != signal_type && variable::state != signal_type) {
																			// TODO: GEN_ERROR ?
																			// TODO: Do not cancel parsing
																			valid_signal_type = false;
																		}
																	.)
SignalDeclaration<signal_type, declared_signal>						(.	if (valid_signal_type && declared_signal.has_value()) {
																			const variable::ptr &valid_signal_declaration = declared_signal.value();
																			if (current_symbol_table_scope->contains(valid_signal_declaration->name)) {
																				// TODO: GEN_ERROR 
																				// TODO: Do not cancel parsing
																			}
																			else {
																				valid_signal_declarations.emplace_back(valid_signal_declaration);
																				current_symbol_table_scope->add_entry(valid_signal_declaration);
																			}
																		}
																	.)
{																	(.	declared_signal.reset();			.)	
	"," SignalDeclaration<signal_type, declared_signal>				(.	if (valid_signal_type && declared_signal.has_value()) {
																			const variable::ptr &valid_signal_declaration = declared_signal.value();
																			if (current_symbol_table_scope->contains(valid_signal_declaration->name)) {
																				// TODO: GEN_ERROR 
																				// TODO: Do not cancel parsing
																			}
																			else {
																				valid_signal_declarations.emplace_back(valid_signal_declaration);
																				current_symbol_table_scope->add_entry(valid_signal_declaration);
																			}
																		}
																	.)
}																	(.	if (valid_signal_declarations.size()){
																			signals.emplace(valid_signal_declarations);
																		}
																	.)
.

SignalDeclaration<. variable::types variable_type, std::optional<variable::ptr> &declared_signal .>			(.	std::vector<unsigned int> dimensions{};
																												// TODO: Use default bit width
																												unsigned int signal_width = 0;	
																												bool valid_declaration = true;
																											.)
=
ident																										(.	const std::string signal_ident = convert_to_uniform_text_format(t->val);	.)
{"[" 
	int																										(.	const unsigned int dimension = std::stoul(convert_to_uniform_text_format(t->val));
																												if (!dimension) {
																													valid_declaration = false;
																													// TODO: GEN_ERROR
																												}
																												else {
																													dimensions.emplace_back(dimension);	
																												}
																											.)
"]"} 
["(" 
	int																									(.	signal_width = std::stoul(convert_to_uniform_text_format(t->val));
																											if (!signal_width) {
																												// TODO: GEN_ERROR
																												valid_declaration = false;
																											}
																										.)
")"]																									(.	// TODO: What if no dimensions is specified, add default dimension entry ?
																											if (valid_declaration) {
																												declared_signal.emplace(std::make_shared<variable>(variable(variable_type, signal_ident, dimensions, signal_width)));
																											}
																										.)	
.

/*-------------------------------------------------------------------------
Statements
-------------------------------------------------------------------------*/

StatementList 
=
Statement {";" Statement}
.

Statement
=
CallStatement
| ForStatement
| IfStatement
| UnaryStatement
| SkipStatement
| IF (check_if_is_assign_statement()) AssignStatement
| SwapStatement
.

CallStatement
=
("call" | "uncall") ident "(" ident {"," ident} ")"
.

ForStatement													(.	std::optional<number::ptr> number;	.)
=
"for" 
[IF (check_if_loop_iteration_range_start_is_defined()) (
	[
		IF (check_if_loop_variable_is_defined()) (
			"$" ident 
			"="
		)
	] 
	Number<number>
	"to"
)] 
Number<number>
["step" 
	[	"-"
	] 
Number<number>
] 
"do" 
StatementList 
"rof"
.

IfStatement															(.	expression_evaluation_result condition;
																		expression_evaluation_result closing_condition;
																	.)	
=
"if" Expression<condition> "then" StatementList "else" StatementList "fi" Expression<closing_condition>
.

UnaryStatement														(.	signal_evaluation_result unary_stmt_operand;	.)
=
("~" | "++" | "--") "=" Signal<unary_stmt_operand>
.

AssignStatement														(.	signal_evaluation_result assign_stmt_lhs;
																		expression_evaluation_result assign_stmt_rhs;
																	.)
=
Signal<assign_stmt_lhs> 
("^" | "+" | "-") 
"=" Expression<assign_stmt_rhs>
.

SwapStatement														(.	signal_evaluation_result swap_me, swap_there;	.)
=
Signal<swap_me> "<=>" Signal<swap_there>
.

SkipStatement
=
"skip"
.

Signal<signal_evaluation_result &signal_access>					(.	variable_access::ptr signal;	.)				
=
ident															(.	const std::string signal_ident = convert_to_uniform_text_format(t->val);
																	if (!current_symbol_table_scope->contains(signal_ident)) {
																		// TODO: GEN_ERROR
																	}
																	else {
																		signal.reset(new variable_access());
																		// TODO: Set with variable from symbol table
																		signal->set_var({});
																	}
																.)
{"["															(.	expression_evaluation_result index_expression;	.)
	Expression<index_expression>								
"]"
} 
[																(.	std::optional<number::ptr> range_start, range_end;
																	bool defined_range = false;
																.)
	"." Number<range_start>									
	[
		":" Number<range_end>									(.	defined_range = true;	.)
	]															(.	if (!range_start.has_value() || (defined_range && !range_end.has_value())) {
																		return;
																	}

																	bool isBitIndex = nullptr != range_end;
																	if (isBitIndex) {
																		// TODO:
																	}
																	else {
																		// TODO:
																	}
																.)
]
.

/*-------------------------------------------------------------------------
Expressions
-------------------------------------------------------------------------*/

Expression<expression_evaluation_result &expression>									(.	signal_evaluation_result signal;
																							std::optional<number::ptr> number;
																						.)
=
(
	IF (check_if_expression_is_number()) Number<number>									
	| IF (check_if_expression_is_binary_expression()) BinaryExpression<expression>
	| ShiftExpression<expression>
)
	| Signal<signal>					
	| UnaryExpression<expression>
.

BinaryExpression<expression_evaluation_result &binary_expression>						(.	expression_evaluation_result binary_expr_lhs;
																							expression_evaluation_result binary_expr_rhs;
																						.)
=
"(" Expression<binary_expr_lhs> 
	("+" | "-" | "^" | "*" | "/" | "%" | "*>" | "&&" | "||" | "&" | "|" | "<" | ">" | "=" | "!=" | "<=" | ">=") 
	Expression<binary_expr_rhs>
")"
.

UnaryExpression<expression_evaluation_result &unary_expression>							(.	expression_evaluation_result unary_expression_operand;	.)
=
("!" | "~") Expression<unary_expression_operand>
.

ShiftExpression<expression_evaluation_result &shift_expression>							(.	expression_evaluation_result shift_expression_lhs;
																							std::optional<number::ptr> shift_amount;
																						.)
=
"(" Expression<shift_expression_lhs> ("<<" | ">>") Number<shift_amount> ")"
.

END SyReC.