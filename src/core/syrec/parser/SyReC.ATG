/*-------------------------------------------------------------------------
ATG for SyReC: A Programming Language for Synthesis of Reversible Circuits
(specification available @ http://www.revlib.org/doc/docu/revlib_2_0_1.pdf)

User manual for Coco/R is available @
https://ssw.jku.at/Research/Projects/Coco/Doc/UserManual.pdf
-------------------------------------------------------------------------*/
$namespace=syrec
$checkEOF=false

// Place includes here
#include <set>
#include <string>
#include <vector>

#include "core/syrec/module.hpp"
#include "core/syrec/program.hpp"

COMPILER SyReC
	// Place declarations of objects referenced in this ATG
	module::vec modules;

	// This method will be called by the contructor if it exits.
	// This support is specific to the C++ version of Coco/R.
	void Init() {
		// nothing to do for now
	}

	// Uncomment this method if cleanup is necessary,
	// this method will be called by the destructor if it exists.
	// This support is specific to the C++ version of Coco/R.
	// void Destroy() {
		// nothing to do
	// }

	[[nodiscard]] bool find_matching_token(std::vector<std::wstring> matching_token_values, std::vector<std::wstring> token_values_allowing_stop_of_search) const {
		const std::set<std::wstring> set_of_matching_token_values { std::begin(matching_token_values), std::end(matching_token_values) };
		const std::set<std::wstring> set_of_token_values_allowing_stop_of_search { std::begin(token_values_allowing_stop_of_search), std::end(token_values_allowing_stop_of_search) };
		bool found_matching_operator = false;
		bool can_cancel_search = false;

		while (!can_cancel_search) {
			const Token *peeked_token = scanner->Peek();
			found_matching_operator = set_of_matching_token_values.count(peeked_token->val);
			can_cancel_search = found_matching_operator || peeked_token->kind == _EOF || set_of_token_values_allowing_stop_of_search.count(peeked_token->val);
		}
		return found_matching_operator;
	}

	[[nodiscard]] bool check_if_is_assign_statement() const {
		const std::vector<std::wstring> matching_tokens = {L"^", L"+", L"-"};
		const std::vector<std::wstring> tokens_resulting_in_check_being_false = {L";", L"<=>"};

		return find_matching_token(matching_tokens, tokens_resulting_in_check_being_false);
	}

	[[nodiscard]] bool check_if_expression_is_binary_expression() const {
		// Since first LL(1) conflict resolver already started peeking and failed to resolve the conflict, we need to reset the peek position to original one
		scanner->ResetPeek();

		const std::set<std::wstring> tokens_resulting_in_check_being_false {L"+", L"-", L"^", L"*", L"/", L"%", L"*>", L"&&", L"||", L"&", L"|", L"<", L">", L"=", L"!=", L"<=", L">="};
		const std::set<std::wstring> set_of_operator_token_values_of_alternative {L"<<", L">>"};

		bool found_matching_operator = false;
		bool can_cancel_search = false;
		int expression_nesting_level = 0;

		while (!can_cancel_search) {
			const Token *peeked_token = scanner->Peek();

			if (peeked_token->val == L"("){
				expression_nesting_level++;
			} 
			else if (peeked_token->val == L")") {
				expression_nesting_level--;
			}
			else {
				found_matching_operator = expression_nesting_level == 0 && tokens_resulting_in_check_being_false.count(peeked_token->val);
				can_cancel_search = found_matching_operator || set_of_operator_token_values_of_alternative.count(peeked_token->val) || peeked_token->kind == _EOF;			
			}

		}
		return found_matching_operator;
	}

	[[nodiscard]] bool is_token_not_nested_number(const Token *token) const {
		if (token == NULL) {
			return false;
		}
		return token->kind == _int || token->val == L"#" || token->val == L"$";
	}

	[[nodiscard]] bool check_if_expression_is_number() const {
		const Token *peeked_token = scanner->Peek();
		bool found_matching_operator = peeked_token->kind == _int || peeked_token->val == L"#" || peeked_token->val == L"$";
		bool can_cancel_search = !found_matching_operator;

		int nesting_level = 0;
		while (!can_cancel_search) {
			peeked_token = scanner->Peek();
			if (peeked_token->val == L"(") {
				nesting_level++;
			} 
			else if (peeked_token->val == L")") {
				nesting_level--;
			}
			else {
				const std::vector<std::wstring> matching_tokens = {L"^", L"+", L"-", L"*"};
				found_matching_operator = !is_token_not_nested_number(peeked_token) && find_matching_token(matching_tokens, {}) && check_if_expression_is_number();
				can_cancel_search = found_matching_operator;
			}
		}
		return found_matching_operator;
	}

	[[nodiscard]] bool check_if_loop_variable_is_defined() const {
		// Since first LL(1) conflict resolver already started peeking and failed to resolve the conflict, we need to reset the peek position to original one
		scanner->ResetPeek();
		const std::vector<std::wstring> matching_tokens = {L"="};
		const std::vector<std::wstring> tokens_resulting_in_check_being_false = {L"rof"};

		return find_matching_token(matching_tokens, tokens_resulting_in_check_being_false);
	}

	[[nodiscard]] bool check_if_loop_iteration_range_start_is_defined() const {
		const std::vector<std::wstring> matching_tokens = {L"to"};
		const std::vector<std::wstring> tokens_resulting_in_check_being_false = {L"rof"};

		return find_matching_token(matching_tokens, tokens_resulting_in_check_being_false);
	}

/*-------------------------------------------------------------------------*/

CHARACTERS
	letter		= 'A' .. 'Z' + 'a' .. 'z'.
	digit		= '0' .. '9'.

	cr        = '\r'.
	lf        = '\n'.
	tab       = '\t'.

TOKENS
	ident		= ('_' | letter) {('_' | letter | digit)}.
	int			= digit {digit}.
	
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/
PRODUCTIONS

/*-------------------------------------------------------------------------
Since Coco/R does not accept recursive token definitions, 
we redefine the token 'number as a non-terminal symbol
-------------------------------------------------------------------------*/
Number
=
int | '#' ident | '$' ident | ('(' Number ('+'|'-'|'*'|'/') Number ')')
.

/*-------------------------------------------------------------------------
Program and Modules
-------------------------------------------------------------------------*/

SyReC
=
Module {Module}
.

Module
=
"module" ident "(" [ParameterList] ")" {SignalList} StatementList
.

ParameterList 
=
Parameter {"," Parameter}
.

Parameter 
= 
("in" | "out" | "inout") SignalDeclaration
.

SignalList 
=
("wire" | "signal") SignalDeclaration {"," SignalDeclaration}
.

SignalDeclaration 
=
ident {"[" int "]"} ["(" int ")"]
.

/*-------------------------------------------------------------------------
Statements
-------------------------------------------------------------------------*/

StatementList 
=
Statement {";" Statement}
.

Statement
=
CallStatement
| ForStatement
| IfStatement
| UnaryStatement
| SkipStatement
| IF (check_if_is_assign_statement()) AssignStatement
| SwapStatement
.

CallStatement
=
("call" | "uncall") ident "(" ident {"," ident} ")"
.

ForStatement
=
"for" [IF (check_if_loop_iteration_range_start_is_defined()) ([IF (check_if_loop_variable_is_defined()) ("$" ident "=")] Number "to")] Number ["step" ["-"] Number] StatementList "rof"
.

IfStatement
=
"if" Expression "then" StatementList "else" StatementList "fi"
.

UnaryStatement
=
("~" | "++" | "--") "=" Signal
.

AssignStatement
=
Signal ("^" | "+" | "-") "=" Expression
.

SwapStatement
=
Signal "<=>" Signal
.

SkipStatement
=
"skip"
.

Signal
=
ident {"[" Expression "]"} ["." Number [":" Number]]
.

/*-------------------------------------------------------------------------
Expressions
-------------------------------------------------------------------------*/

Expression
=
(
	IF (check_if_expression_is_number()) Number
	| IF (check_if_expression_is_binary_expression()) BinaryExpression
	| ShiftExpression
)
	| Signal | UnaryExpression
.

BinaryExpression
=
"(" Expression ("+" | "-" | "^" | "*" | "/" | "%" | "*>" | "&&" | "||" "&" | "|" "<" | ">" "=" | "!=" | "<=" | ">=") Expression ")"
.

UnaryExpression
=
("!" | "~") Expression
.

ShiftExpression
=
"(" Expression ("<<" | ">>") Number ")"
.

END SyReC.