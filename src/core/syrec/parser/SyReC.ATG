/*-------------------------------------------------------------------------
ATG for SyReC: A Programming Language for Synthesis of Reversible Circuits
(specification available @ http://www.revlib.org/doc/docu/revlib_2_0_1.pdf)

User manual for Coco/R is available @
https://ssw.jku.at/Research/Projects/Coco/Doc/UserManual.pdf
-------------------------------------------------------------------------*/
$namespace=syrec
/*-- $checkEOF=false --*/

// Place includes here
#include <cwchar>
#include <set>
#include <string>
#include <vector>

#include "core/syrec/module.hpp"
#include "core/syrec/parser/parser_error_message_generator.hpp"
#include "core/syrec/parser/symbol_table.hpp"
#include "core/syrec/parser/text_utils.hpp"

COMPILER SyReC
	// Place declarations of objects referenced in this ATG
	module::vec modules;
	parser_error_message_generator error_message_generator;
	symbol_table::ptr current_symbol_table_scope;

	// This method will be called by the contructor if it exits.
	// This support is specific to the C++ version of Coco/R.
	void Init() {
		// nothing to do
		current_symbol_table_scope = nullptr;
	}

	// Uncomment this method if cleanup is necessary,
	// this method will be called by the destructor if it exists.
	// This support is specific to the C++ version of Coco/R.
	// void Destroy() {
		// nothing to do
	// }

	[[nodiscard]] bool are_token_values_equal(const wchar_t *my_token_value, const wchar_t *other_token_value) const {
		if (my_token_value == nullptr || other_token_value == nullptr) {
			// TODO: Could also throw exception
			return false;
		}
		return !wcscmp(my_token_value, other_token_value);
	}

	[[nodiscard]] bool token_matches_one_of(const Token *tokenToCheck, std::vector<std::wstring> one_of_many_token_values) const {
        const std::set<std::wstring> set_of_matching_token_values{std::begin(one_of_many_token_values), std::end(one_of_many_token_values)};
        return set_of_matching_token_values.count(tokenToCheck->val);
	}

	[[nodiscard]] bool find_matching_token(std::vector<std::wstring> matching_token_values, std::vector<std::wstring> token_values_allowing_stop_of_search) const {
		const std::set<std::wstring> set_of_matching_token_values { std::begin(matching_token_values), std::end(matching_token_values) };
		const std::set<std::wstring> set_of_token_values_allowing_stop_of_search { std::begin(token_values_allowing_stop_of_search), std::end(token_values_allowing_stop_of_search) };
		bool found_matching_operator = false;
		bool can_cancel_search = false;

		while (!can_cancel_search) {
			const Token *peeked_token = scanner->Peek();
			found_matching_operator = set_of_matching_token_values.count(peeked_token->val);
			can_cancel_search = found_matching_operator || peeked_token->kind == _EOF || set_of_token_values_allowing_stop_of_search.count(peeked_token->val);
		}
		return found_matching_operator;
	}

	[[nodiscard]] bool check_if_is_assign_statement() const {
		const std::vector<std::wstring> matching_tokens = {L"^", L"+", L"-"};
		const std::vector<std::wstring> tokens_resulting_in_check_being_false = {L";", L"<=>"};

		return find_matching_token(matching_tokens, tokens_resulting_in_check_being_false);
	}

	[[nodiscard]] bool check_if_expression_is_binary_expression() const {
		// Since first LL(1) conflict resolver already started peeking and failed to resolve the conflict, we need to reset the peek position to original one
		scanner->ResetPeek();

		const std::set<std::wstring> tokens_resulting_in_check_being_false {L"+", L"-", L"^", L"*", L"/", L"%", L"*>", L"&&", L"||", L"&", L"|", L"<", L">", L"=", L"!=", L"<=", L">="};
		const std::set<std::wstring> set_of_operator_token_values_of_alternative {L"<<", L">>"};

		bool found_matching_operator = false;
		bool can_cancel_search = false;
		int expression_nesting_level = 0;

		while (!can_cancel_search) {
			const Token *peeked_token = scanner->Peek();

			if (are_token_values_equal(peeked_token->val, L"(")) {
				expression_nesting_level++;
			} 
			else if (are_token_values_equal(peeked_token->val, L")")) {
				expression_nesting_level--;
			}
			else {
				found_matching_operator = expression_nesting_level == 0 && tokens_resulting_in_check_being_false.count(peeked_token->val);
				can_cancel_search = found_matching_operator || set_of_operator_token_values_of_alternative.count(peeked_token->val) || peeked_token->kind == _EOF;			
			}

		}
		return found_matching_operator;
	}

	[[nodiscard]] bool is_token_not_nested_number(const Token *token) const {
		if (token == nullptr) {
			return false;
		}
		return token->kind == _int || are_token_values_equal(token->val, L"#") || are_token_values_equal(token->val, L"$");
	}

	[[nodiscard]] bool check_if_expression_is_number(const Token *first_token_of_expression) const {
        bool found_matching_operator;
        const std::vector<std::wstring> matching_tokens = {L"^", L"+", L"-", L"*"};

        if (are_token_values_equal(first_token_of_expression->val, L"(")) {
            found_matching_operator = check_if_expression_is_number(scanner->Peek())
                && token_matches_one_of(scanner->Peek(), matching_tokens)
                && check_if_expression_is_number(scanner->Peek())
                && are_token_values_equal(scanner->Peek()->val, L")");
        } else {
            found_matching_operator = is_token_not_nested_number(first_token_of_expression);
        }
        return found_matching_operator;
	}

	[[nodiscard]] bool check_if_expression_is_number() const {
        return la != nullptr && check_if_expression_is_number(la);
	}

	[[nodiscard]] bool check_if_loop_variable_is_defined() const {
		// Since first LL(1) conflict resolver already started peeking and failed to resolve the conflict, we need to reset the peek position to original one
		scanner->ResetPeek();
		const std::vector<std::wstring> matching_tokens = {L"="};
		const std::vector<std::wstring> tokens_resulting_in_check_being_false = {L"rof"};

		return find_matching_token(matching_tokens, tokens_resulting_in_check_being_false);
	}

	[[nodiscard]] bool check_if_loop_iteration_range_start_is_defined() const {
		const std::vector<std::wstring> matching_tokens = {L"to"};
		const std::vector<std::wstring> tokens_resulting_in_check_being_false = {L"rof"};

		return find_matching_token(matching_tokens, tokens_resulting_in_check_being_false);
	}

/*-------------------------------------------------------------------------*/

CHARACTERS
	letter		= 'A' .. 'Z' + 'a' .. 'z'.
	digit		= '0' .. '9'.

	cr        = '\r'.
	lf        = '\n'.
	tab       = '\t'.

TOKENS
	ident		= ('_' | letter) {('_' | letter | digit)}.
	int			= digit {digit}.
	
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/
PRODUCTIONS

/*-------------------------------------------------------------------------
Since Coco/R does not accept recursive token definitions, 
we redefine the token 'number as a non-terminal symbol
-------------------------------------------------------------------------*/
Number
=
int | '#' ident | '$' ident | ('(' Number ('+'|'-'|'*'|'/') Number ')')
.

/*-------------------------------------------------------------------------
Program and Modules
-------------------------------------------------------------------------*/

SyReC								(.	module::ptr module = nullptr; 
										symbol_table::open_scope(current_symbol_table_scope);
									.)
=
Module<module>						(.	symbol_table::close_scope(current_symbol_table_scope);
										if (nullptr != module) {
											current_symbol_table_scope->add_entry(module);
										}
									.)
{									(.	symbol_table::open_scope(current_symbol_table_scope);
										module = nullptr;
									.)
	Module<module>					(.	symbol_table::close_scope(current_symbol_table_scope);
										if (nullptr != module) {
											if (current_symbol_table_scope->contains(module)) {
												// TODO: GEN_ERROR 
												// TODO: Do not cancel parsing	
											}
											else {
												current_symbol_table_scope->add_entry(module);
											}
										}
									.)
}
.

Module <module::ptr &parsed_module>						(.	std::vector<variable::ptr> locals {};	.)	
=
"module" ident											(.	const std::string module_name = convert_to_uniform_text_format(t->val);
															parsed_module = std::make_shared<module>(module(module_name));	
														.)	
"(" [ParameterList<parsed_module>] ")" 
{
	SignalList<locals>									(.	parsed_module->variables = locals;	.)
}														
StatementList
.

ParameterList<const module::ptr &module>					(.	variable::ptr parameter = nullptr;	.)
=
Parameter<parameter>										(.	if (nullptr != parameter) {
																	module->add_parameter(parameter);
																}
															.)
{															(.	parameter = nullptr;	.)
	"," Parameter<parameter>								(.	if (nullptr != parameter) {
																	// TODO: Check for duplicates
																	if (current_symbol_table_scope->contains(parameter->name)) {
																		// TODO: GEN_ERROR 
																		// TODO: Do not cancel parsing
																	}
																	else {
																		module->add_parameter(parameter);
																		current_symbol_table_scope->add_entry(parameter);
																	}
																}
															.)
}
.

Parameter<variable::ptr &parameter>						(.	variable::types parameter_type = variable::wire;
															bool valid_variable_type = true;
														.)	
= 
(
	"in"												(.	parameter_type = variable::in;	.)
	| "out"												(.	parameter_type = variable::out;	.)
	| "inout"											(.	parameter_type = variable::inout;	.)	
)														(.	if (variable::wire == parameter_type) {
																// TODO: GEN_ERROR 
																// TODO: Do not cancel parsing
																valid_variable_type = false;
															}
														.)
SignalDeclaration<parameter_type, parameter>			(.	if (!valid_variable_type) {
																parameter = nullptr;
															}
														.)
.

SignalList <. std::vector<variable::ptr> &signals .>				(.	variable::types signal_type = variable::in;
																		variable::ptr variable = nullptr;
																		bool valid_signal_type = true;
																	.)
=
(
	"wire"															(.	signal_type = variable::wire;		.)
	| "signal"														(.	signal_type = variable::state;		.)
)																	(.	if (variable::wire != signal_type && variable::state != signal_type) {
																			// TODO: GEN_ERROR ?
																			// TODO: Do not cancel parsing
																			valid_signal_type = false;
																		}
																	.)
SignalDeclaration<signal_type, variable>							(.	if (nullptr != variable && valid_signal_type){
																			if (current_symbol_table_scope->contains(variable->name)) {
																				// TODO: GEN_ERROR 
																				// TODO: Do not cancel parsing
																			}
																			else {
																				signals.emplace_back(variable);
																				current_symbol_table_scope->add_entry(variable);
																			}
																		}
																	.)
{																	(.	variable = nullptr;					.)	
	"," SignalDeclaration<signal_type, variable>					(.	if (nullptr != variable && valid_signal_type){
																			if (current_symbol_table_scope->contains(variable->name)) {
																				// TODO: GEN_ERROR 
																				// TODO: Do not cancel parsing
																			}
																			else {
																				signals.emplace_back(variable);
																				current_symbol_table_scope->add_entry(variable);
																			}
																		}
																	.)
}
.

SignalDeclaration<variable::types variable_type, variable::ptr &declared_signal>		(.	std::vector<unsigned int> dimensions{};
																							// TODO: Use default bit width
																							unsigned int signal_width = 0;	
																							bool valid_declaration = true;
																						.)
=
ident																					(.	const std::string signal_ident = convert_to_uniform_text_format(t->val);	.)
{"[" 
	int																					(.	const unsigned int dimension = std::stoul(convert_to_uniform_text_format(t->val));
																							if (!dimension) {
																								valid_declaration = false;
																								// TODO: GEN_ERROR
																							}
																							else {
																								dimensions.emplace_back(dimension);	
																							}
																						.)
"]"} 
["(" 
	int																					(.	signal_width = std::stoul(convert_to_uniform_text_format(t->val));
																							if (!signal_width) {
																								// TODO: GEN_ERROR
																								valid_declaration = false;
																							}
																						.)
")"]																					(.	// TODO: What if no dimensions is specified, add default dimension entry ?
																							if (valid_declaration) {
																								declared_signal = std::make_shared<variable>(variable(variable_type, signal_ident, dimensions, signal_width));	
																							}
																							else {
																								declared_signal = nullptr;
																							}
																						.)	
.

/*-------------------------------------------------------------------------
Statements
-------------------------------------------------------------------------*/

StatementList 
=
Statement {";" Statement}
.

Statement
=
CallStatement
| ForStatement
| IfStatement
| UnaryStatement
| SkipStatement
| IF (check_if_is_assign_statement()) AssignStatement
| SwapStatement
.

CallStatement
=
("call" | "uncall") ident "(" ident {"," ident} ")"
.

ForStatement
=
"for" [IF (check_if_loop_iteration_range_start_is_defined()) ([IF (check_if_loop_variable_is_defined()) ("$" ident "=")] Number "to")] Number ["step" ["-"] Number] "do" StatementList "rof"
.

IfStatement
=
"if" Expression "then" StatementList "else" StatementList "fi" Expression
.

UnaryStatement
=
("~" | "++" | "--") "=" Signal
.

AssignStatement
=
Signal ("^" | "+" | "-") "=" Expression
.

SwapStatement
=
Signal "<=>" Signal
.

SkipStatement
=
"skip"
.

Signal
=
ident {"[" Expression "]"} ["." Number [":" Number]]
.

/*-------------------------------------------------------------------------
Expressions
-------------------------------------------------------------------------*/

Expression
=
(
	IF (check_if_expression_is_number()) Number
	| IF (check_if_expression_is_binary_expression()) BinaryExpression
	| ShiftExpression
)
	| Signal | UnaryExpression
.

BinaryExpression
=
"(" Expression ("+" | "-" | "^" | "*" | "/" | "%" | "*>" | "&&" | "||" | "&" | "|" | "<" | ">" | "=" | "!=" | "<=" | ">=") Expression ")"
.

UnaryExpression
=
("!" | "~") Expression
.

ShiftExpression
=
"(" Expression ("<<" | ">>") Number ")"
.

END SyReC.