/*-------------------------------------------------------------------------
ATG for SyReC: A Programming Language for Synthesis of Reversible Circuits
(specification available @ http://www.revlib.org/doc/docu/revlib_2_0_1.pdf)

User manual for Coco/R is available @
https://ssw.jku.at/Research/Projects/Coco/Doc/UserManual.pdf
-------------------------------------------------------------------------*/
$namespace=syrec
/*-- $checkEOF=false --*/

// Place includes here
#include <algorithm>
#include <cwchar>
#include <optional>
#include <set>
#include <stdexcept>
#include <string>
#include <variant>
#include <vector>

#include "core/syrec/module.hpp"
#include "core/syrec/parser/expression_evaluation_result.hpp"
#include "core/syrec/parser/method_call_guess.hpp"
#include "core/syrec/parser/operation.hpp"
#include "core/syrec/parser/parser_error_message_generator.hpp"
#include "core/syrec/parser/range_check.hpp"
#include "core/syrec/parser/signal_evaluation_result.hpp"
#include "core/syrec/parser/symbol_table.hpp"
#include "core/syrec/parser/text_utils.hpp"

COMPILER SyReC
	// Place declarations of objects referenced in this ATG
	Module::vec modules;
	parser_error_message_generator error_message_generator;
	SymbolTable::ptr currSymTabScope;

	Number::loop_variable_mapping loop_variable_mapping_lookup;

	// This method will be called by the contructor if it exits.
	// This support is specific to the C++ version of Coco/R.
	void Init() {
		// nothing to do
		SymbolTable::openScope(currSymTabScope);
	}

	// Uncomment this method if cleanup is necessary,
	// this method will be called by the destructor if it exists.
	// This support is specific to the C++ version of Coco/R.
	// void Destroy() {
		// nothing to do
	// }

	[[nodiscard]] bool are_token_values_equal(const wchar_t *my_token_value, const wchar_t *other_token_value) const {
		if (my_token_value == nullptr || other_token_value == nullptr) {
			// TODO: Could also throw exception
			return false;
		}
		return !wcscmp(my_token_value, other_token_value);
	}

	[[nodiscard]] bool token_matches_one_of(const Token *tokenToCheck, std::vector<std::wstring> one_of_many_token_values) const {
        const std::set<std::wstring> set_of_matching_token_values{std::begin(one_of_many_token_values), std::end(one_of_many_token_values)};
        return set_of_matching_token_values.count(tokenToCheck->val);
	}

	[[nodiscard]] bool find_matching_token(std::vector<std::wstring> matching_token_values, std::vector<std::wstring> token_values_allowing_stop_of_search) const {
		const std::set<std::wstring> set_of_matching_token_values { std::begin(matching_token_values), std::end(matching_token_values) };
		const std::set<std::wstring> set_of_token_values_allowing_stop_of_search { std::begin(token_values_allowing_stop_of_search), std::end(token_values_allowing_stop_of_search) };
		bool found_matching_operator = false;
		bool can_cancel_search = false;

		while (!can_cancel_search) {
			const Token *peeked_token = scanner->Peek();
			found_matching_operator = set_of_matching_token_values.count(peeked_token->val);
			can_cancel_search = found_matching_operator || peeked_token->kind == _EOF || set_of_token_values_allowing_stop_of_search.count(peeked_token->val);
		}
		return found_matching_operator;
	}

	[[nodiscard]] bool check_if_is_assign_statement() const {
		const std::vector<std::wstring> matching_tokens = {L"^", L"+", L"-"};
		const std::vector<std::wstring> tokens_resulting_in_check_being_false = {L";", L"<=>"};

		return find_matching_token(matching_tokens, tokens_resulting_in_check_being_false);
	}

	[[nodiscard]] bool check_if_expression_is_binary_expression() const {
		// Since first LL(1) conflict resolver already started peeking and failed to resolve the conflict, we need to reset the peek position to original one
		scanner->ResetPeek();

		const std::set<std::wstring> tokens_resulting_in_check_being_false {L"+", L"-", L"^", L"*", L"/", L"%", L"*>", L"&&", L"||", L"&", L"|", L"<", L">", L"=", L"!=", L"<=", L">="};
		const std::set<std::wstring> set_of_operator_token_values_of_alternative {L"<<", L">>"};

		bool found_matching_operator = false;
		bool can_cancel_search = false;
		int expression_nesting_level = 0;

		while (!can_cancel_search) {
			const Token *peeked_token = scanner->Peek();

			if (are_token_values_equal(peeked_token->val, L"(")) {
				expression_nesting_level++;
			} 
			else if (are_token_values_equal(peeked_token->val, L")")) {
				expression_nesting_level--;
			}
			else {
				found_matching_operator = expression_nesting_level == 0 && tokens_resulting_in_check_being_false.count(peeked_token->val);
				can_cancel_search = found_matching_operator || set_of_operator_token_values_of_alternative.count(peeked_token->val) || peeked_token->kind == _EOF;			
			}

		}
		return found_matching_operator;
	}

	[[nodiscard]] bool is_token_not_nested_number(const Token *token) const {
		if (token == nullptr) {
			return false;
		}
		return token->kind == _int || are_token_values_equal(token->val, L"#") || are_token_values_equal(token->val, L"$");
	}
		
	[[nodiscard]] bool check_if_expression_is_number(const Token *first_token_of_expression) const {
        bool found_matching_operator;
        const std::vector<std::wstring> matching_tokens = {L"^", L"+", L"-", L"*"};

        if (are_token_values_equal(first_token_of_expression->val, L"(")) {
            found_matching_operator = check_if_expression_is_number(scanner->Peek())
                && token_matches_one_of(scanner->Peek(), matching_tokens)
                && check_if_expression_is_number(scanner->Peek())
                && are_token_values_equal(scanner->Peek()->val, L")");
        } else {
            found_matching_operator = is_token_not_nested_number(first_token_of_expression);
        }
        return found_matching_operator;
	}

	[[nodiscard]] bool check_if_expression_is_number() const {
        return la != nullptr && check_if_expression_is_number(la);
	}

	[[nodiscard]] bool check_if_loop_variable_is_defined() const {
		// Since first LL(1) conflict resolver already started peeking and failed to resolve the conflict, we need to reset the peek position to original one
		scanner->ResetPeek();
		const std::vector<std::wstring> matching_tokens = {L"="};
		const std::vector<std::wstring> tokens_resulting_in_check_being_false = {L"rof"};

		return find_matching_token(matching_tokens, tokens_resulting_in_check_being_false);
	}

	[[nodiscard]] bool check_if_loop_iteration_range_start_is_defined() const {
		const std::vector<std::wstring> matching_tokens = {L"to"};
		const std::vector<std::wstring> tokens_resulting_in_check_being_false = {L"rof"};

		return find_matching_token(matching_tokens, tokens_resulting_in_check_being_false);
	}

	[[nodiscard]] std::optional<unsigned int> convert_token_value_to_number(const Token &token) {
		std::optional<unsigned int> token_as_number;
		try {
			token_as_number.emplace(std::stoul(convert_to_uniform_text_format(token.val)));
		} 
		catch (std::invalid_argument const &ex) {
			// TODO: GEN_ERROR
		}
		catch (std::out_of_range const &ex) {
			// TODO: GEN_ERROR
		}
		return token_as_number;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_assign_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::add_assign:
				mapping_result.emplace(AssignStatement::Add);
				break;
			case syrec_operation::operation::minus_assign:
				mapping_result.emplace(AssignStatement::Subtract);
				break;
			case syrec_operation::operation::xor_assign:
				mapping_result.emplace(AssignStatement::Exor);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_unary_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::increment_assign:
				mapping_result.emplace(UnaryStatement::Increment);
				break;
			case syrec_operation::operation::decrement_assign:
				mapping_result.emplace(UnaryStatement::Decrement);
				break;
			case syrec_operation::operation::negate_assign:
				mapping_result.emplace(UnaryStatement::Invert);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_shift_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::shift_left:
				mapping_result.emplace(ShiftExpression::Left);
				break;
			case syrec_operation::operation::shift_right:
				mapping_result.emplace(ShiftExpression::Right);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_binary_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::addition:
				mapping_result.emplace(BinaryExpression::Add);
				break;
			case syrec_operation::operation::subtraction:
				mapping_result.emplace(BinaryExpression::Subtract);
				break;
				case syrec_operation::operation::multiplication:
				mapping_result.emplace(BinaryExpression::Multiply);
				break;		
			case syrec_operation::operation::division:
				mapping_result.emplace(BinaryExpression::Divide);
				break;			
			case syrec_operation::operation::modulo:
				mapping_result.emplace(BinaryExpression::Modulo);
				break;		
			case syrec_operation::operation::upper_bits_multiplication:
				mapping_result.emplace(BinaryExpression::FracDivide);
				break;		
			case syrec_operation::operation::bitwise_xor:
				mapping_result.emplace(BinaryExpression::Exor);
				break;		
			case syrec_operation::operation::logical_and:
				mapping_result.emplace(BinaryExpression::LogicalAnd);
				break;		
			case syrec_operation::operation::logical_or:
				mapping_result.emplace(BinaryExpression::LogicalOr);
				break;		
			case syrec_operation::operation::bitwise_and:
				mapping_result.emplace(BinaryExpression::BitwiseAnd);
				break;	
			case syrec_operation::operation::bitwise_or:
				mapping_result.emplace(BinaryExpression::BitwiseOr);
				break;	
			case syrec_operation::operation::less_than:
				mapping_result.emplace(BinaryExpression::LessThan);
				break;	
			case syrec_operation::operation::greater_than:
				mapping_result.emplace(BinaryExpression::GreaterThan);
				break;	
			case syrec_operation::operation::equals:
				mapping_result.emplace(BinaryExpression::Equals);
				break;		
			case syrec_operation::operation::not_equals:
				mapping_result.emplace(BinaryExpression::NotEquals);
				break;		
			case syrec_operation::operation::less_equals:
				mapping_result.emplace(BinaryExpression::LessEquals);
				break;		
			case syrec_operation::operation::greater_equals:
				mapping_result.emplace(BinaryExpression::GreaterEquals);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	bool check_ident_was_declared(const std::string_view& ident) const {
		if (!currSymTabScope->contains(ident)) {
			// TOOD: GEN_ERROR
			return false;
		}
		return true;
	}

	// TODO: Generate error/s in case of exceptions
	[[nodiscard]] std::optional<unsigned int> apply_unary_operation(const syrec_operation::operation operation, const Number::ptr &left_operand) const {
		std::optional<unsigned int> operation_result;
		try {
			operation_result.emplace(syrec_operation::apply(operation, left_operand->evaluate(loop_variable_mapping_lookup)));
		}
		catch (std::overflow_error &err) {
		
		}
		catch(std::invalid_argument &err) {
		
		}
        return operation_result;
	}

	// TODO: Generate error/s in case of exceptions
	[[nodiscard]] static std::optional<unsigned int> apply_binary_operation(const syrec_operation::operation operation, const unsigned int &left_operand, const unsigned int &right_operand) {
		std::optional<unsigned int> operation_result;
		try {
			operation_result.emplace(syrec_operation::apply(operation, left_operand, right_operand));
		}
		catch (std::overflow_error &err) {
		
		}
		catch(std::invalid_argument &err) {
		
		}
        return operation_result;
	}

	[[nodiscard]] std::optional<unsigned int> evaluate_number_container_to_constant(const Number::ptr &number_container) const {
		std::optional<unsigned int> value_of_number_container;
		if (number_container->isLoopVariable()) {
			const std::string &loop_variable_name = number_container->variableName();
			if (loop_variable_mapping_lookup.find(loop_variable_name) == loop_variable_mapping_lookup.end()) {
				// TODO: GEN_ERROR
			}
			else {
				value_of_number_container.emplace(number_container->evaluate(loop_variable_mapping_lookup));
			}
		}
		else {
			value_of_number_container.emplace(number_container->evaluate(loop_variable_mapping_lookup));
		}
		return value_of_number_container;
	}

	[[nodiscard]] ExpressionEvaluationResult::ptr createExpressionEvalutionResultContainer() const {
		return std::make_shared<ExpressionEvaluationResult>(ExpressionEvaluationResult());
	}

/*-------------------------------------------------------------------------*/

CHARACTERS
	letter		= 'A' .. 'Z' + 'a' .. 'z'.
	digit		= '0' .. '9'.

	cr        = '\r'.
	lf        = '\n'.
	tab       = '\t'.

TOKENS
	ident		= ('_' | letter) {('_' | letter | digit)}.
	int			= digit {digit}.
	
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/
PRODUCTIONS


/*-------------------------------------------------------------------------
Number production

Since Coco/R does not accept recursive token definitions, 
we redefine the token 'Number as a non-terminal symbol
-------------------------------------------------------------------------*/
// TODO: Current data structure does not handle negative numbers well, one migitation could be to use the two-complement representation (which would require to update the calculation for many operations (i.e. division, etc.))
// TODO: Currently synthesis uses ident without '$' prefix for its loop mappings
// TODO: For now no loop variable mappings will get added to the lookup (since currently no support for iterating a list of statements is supported)

// TODO: Expression productions still require checks that the bitwidth of the internal expressions (i.e. the left and right expression in a binary expression) are not larger than the input one

Number<. std::optional<Number::ptr> &parsed_number, bool simplify_if_possible .>									
=
int																			(.	const std::optional<unsigned int> conversion_result = convert_token_value_to_number(*t);
																				if (conversion_result.has_value()) {
																					const Number::ptr result = std::make_shared<syrec::Number>(syrec::Number(conversion_result.value())); 
																					parsed_number.emplace(result);
																				}
																			.)
| '#' ident																	(.	const std::string signal_ident = convert_to_uniform_text_format(t->val);
																				if (check_ident_was_declared(signal_ident)) {
																					const auto &symbol_table_entry = currSymTabScope->getVariable(signal_ident);
																					if (symbol_table_entry.has_value() && std::holds_alternative<Variable::ptr>(symbol_table_entry.value())) {
																						parsed_number.emplace(std::make_shared<syrec::Number>(syrec::Number(std::get<Variable::ptr>(symbol_table_entry.value())->bitwidth)));
																					}
																					else {
																						// TODO: GEN_ERROR, this should not happen but check anyways
																					}
																				}
																			.)
| '$' ident																	(.	const std::string signal_ident = convert_to_uniform_text_format(t->val);
																				if (check_ident_was_declared(signal_ident)) {
																					const auto &symbol_table_entry = currSymTabScope->getVariable(signal_ident);
																					if (symbol_table_entry.has_value() && std::holds_alternative<Number::ptr>(symbol_table_entry.value())) {
																						// TODO: An optimization that can be done here would be the replacement of the loop variable with its current value from the mapping
																						parsed_number.emplace(std::get<Number::ptr>(symbol_table_entry.value()));
																					}
																					else {
																						// TODO: GEN_ERROR, this should not happen but check anyways
																					}
																				}
																			.)
| (																			(.	std::optional<Number::ptr> lhs_operand, rhs_operand;  
																				std::optional<syrec_operation::operation> op;
																			.)
	'(' 
		Number<lhs_operand, simplify_if_possible>
		('+'																(.	op.emplace(syrec_operation::operation::addition);		.)
		|'-'																(.	op.emplace(syrec_operation::operation::subtraction);	.)
		|'*'																(.	op.emplace(syrec_operation::operation::multiplication);	.)
		|'/'																(.	op.emplace(syrec_operation::operation::division);		.)
		) 
		Number<rhs_operand, simplify_if_possible>							(.	if (op.has_value() && lhs_operand.has_value() && rhs_operand.has_value()){
																					const std::optional<unsigned int> lhs_value = evaluate_number_container_to_constant(lhs_operand.value());
																					const std::optional<unsigned int> rhs_value = evaluate_number_container_to_constant(rhs_operand.value());

																					if (lhs_value.has_value() && rhs_value.has_value()) {
																						const std::optional<unsigned int> op_result = apply_binary_operation(op.value(),
																																							lhs_operand.value()->evaluate(loop_variable_mapping_lookup),
																																							rhs_operand.value()->evaluate(loop_variable_mapping_lookup));
																						if (op_result.has_value()) {
																							const Number::ptr result = std::make_shared<syrec::Number>(syrec::Number(op_result.value())); 
																							parsed_number.emplace(result);
																						}
																					}
																				}
																			.)
	')'																	
)
.

/*-------------------------------------------------------------------------
Program and Modules
-------------------------------------------------------------------------*/

SyReC										(.	std::optional<Module::ptr> module;	.)
=
Module<module>								(.	if (module.has_value()) {
													currSymTabScope->addEntry(module.value());
													this->modules.emplace_back(module.value());
												}
											.)
{											(.	module.reset();	.)
	Module<module>							(.	if (module.has_value()) {
													const Module::ptr well_formed_module = module.value();
													if (currSymTabScope->contains(well_formed_module)) {
														// TODO: GEN_ERROR 
														// TODO: Do not cancel parsing	
													}
													else {
														currSymTabScope->addEntry(well_formed_module);
														this->modules.emplace_back(module.value());
													}
												}
											.)
}
.

/*-------------------------------------------------------------------------
Module production
-------------------------------------------------------------------------*/

Module <. std::optional<Module::ptr> &parsed_module	.>			(.	SymbolTable::openScope(currSymTabScope);
																	std::optional<std::vector<Variable::ptr>> locals;	
																	bool valid_module_definition = false;
																	Statement::vec module_body {};
																.)	
=
"module" ident													(.	const std::string module_name = convert_to_uniform_text_format(t->val);	
																	Module::ptr user_defined_module = std::make_shared<syrec::Module>(syrec::Module(module_name));
																.)	
"(" [ParameterList<valid_module_definition, user_defined_module>] ")" 
{
	SignalList<locals>											(.	valid_module_definition &= locals.has_value();	.)
}														
StatementList<module_body>										(.	SymbolTable::closeScope(currSymTabScope);
																	if (module_body.empty()) {
																		valid_module_definition = false;
																		// TODO: GEN_ERROR
																	}

																	if (valid_module_definition) {
																		user_defined_module->variables = locals.value_or(std::vector<Variable::ptr>{});
																		for (const auto &statement : module_body) {
																			user_defined_module->addStatement(statement);
																		}
																		parsed_module.emplace(user_defined_module);
																	}
																.)
.


/*-------------------------------------------------------------------------
ParameterList production
-------------------------------------------------------------------------*/

ParameterList<bool &is_valid_module_definition, const Module::ptr &module>			(.	std::optional<Variable::ptr> parameter;	.)
=
Parameter<parameter>																(.	is_valid_module_definition = parameter.has_value();
																						if (is_valid_module_definition) {
																							module->addParameter(parameter.value());
																							currSymTabScope->addEntry(parameter.value());
																						}
																					.)
{																					(.	parameter.reset();	.)
	"," Parameter<parameter>														(.	is_valid_module_definition = parameter.has_value();
																						if (is_valid_module_definition) {	
																							const Variable::ptr &well_formed_parameter = parameter.value();
																							if (!currSymTabScope->contains(well_formed_parameter->name)) {
																								module->addParameter(well_formed_parameter);
																								currSymTabScope->addEntry(well_formed_parameter);
																							}
																							else {
																								is_valid_module_definition = false;
																								// TODO: GEN_ERROR 
																							}
																						}
																					.)
}															
.


/*-------------------------------------------------------------------------
Parameter production
-------------------------------------------------------------------------*/

Parameter<. std::optional<Variable::ptr> &parameter .>								(.	Variable::Types parameter_type = Variable::Wire;
																						bool valid_variable_type = true;
																					.)	
= 
(
	"in"																			(.	parameter_type = Variable::In;	.)
	| "out"																			(.	parameter_type = Variable::Out;	.)
	| "inout"																		(.	parameter_type = Variable::Inout;	.)	
)																					(.	if (Variable::Wire == parameter_type) {
																							// TODO: GEN_ERROR 
																							// TODO: Do not cancel parsing
																							valid_variable_type = false;
																						}
																					.)
SignalDeclaration<parameter_type, parameter>										(.	if (!valid_variable_type) {
																							parameter.reset();
																						}
																					.)
.

/*-------------------------------------------------------------------------
SignalList production
-------------------------------------------------------------------------*/

SignalList <. std::optional<std::vector<Variable::ptr>> &signals .>	(.	Variable::Types signal_type = Variable::In;
																		std::optional<Variable::ptr> declared_signal;
																		bool valid_signal_type = true;
																		std::vector<Variable::ptr> valid_signal_declarations;
																	.)
=
(
	"wire"															(.	signal_type = Variable::Wire;		.)
	| "signal"														(.	signal_type = Variable::State;		.)
)																	(.	if (Variable::Wire != signal_type && Variable::State != signal_type) {
																			// TODO: GEN_ERROR ?
																			// TODO: Do not cancel parsing
																			valid_signal_type = false;
																		}
																	.)
SignalDeclaration<signal_type, declared_signal>						(.	if (valid_signal_type && declared_signal.has_value()) {
																			const Variable::ptr &valid_signal_declaration = declared_signal.value();
																			if (currSymTabScope->contains(valid_signal_declaration->name)) {
																				// TODO: GEN_ERROR 
																				// TODO: Do not cancel parsing
																			}
																			else {
																				valid_signal_declarations.emplace_back(valid_signal_declaration);
																				currSymTabScope->addEntry(valid_signal_declaration);
																			}
																		}
																	.)
{																	(.	declared_signal.reset();			.)	
	"," SignalDeclaration<signal_type, declared_signal>				(.	if (valid_signal_type && declared_signal.has_value()) {
																			const Variable::ptr &valid_signal_declaration = declared_signal.value();
																			if (currSymTabScope->contains(valid_signal_declaration->name)) {
																				// TODO: GEN_ERROR 
																				// TODO: Do not cancel parsing
																			}
																			else {
																				valid_signal_declarations.emplace_back(valid_signal_declaration);
																				currSymTabScope->addEntry(valid_signal_declaration);
																			}
																		}
																	.)
}																	(.	if (valid_signal_declarations.size()){
																			signals.emplace(valid_signal_declarations);
																		}
																	.)
.


/*-------------------------------------------------------------------------
SignalDeclaration production
-------------------------------------------------------------------------*/

SignalDeclaration<. const Variable::Types variable_type, std::optional<Variable::ptr> &declared_signal .>	(.	std::vector<unsigned int> dimensions{};
																												// TODO: Use default bit width
																												unsigned int signal_width = 0;	
																												bool valid_declaration = true;
																											.)
=
ident																										(.	const std::string signal_ident = convert_to_uniform_text_format(t->val);	.)
{"[" 
	int																										(.	const std::optional<unsigned int> dimension = convert_token_value_to_number(*t);
																												if (!dimension.has_value()) {
																													valid_declaration = false;
																													// TODO: GEN_ERROR
																												}
																												else {
																													dimensions.emplace_back(dimension.value());	
																												}
																											.)
"]"}																									
["(" 
	int																									(.	const std::optional<unsigned int> user_defined_signal_width = convert_token_value_to_number(*t);
																											if (!user_defined_signal_width.has_value()) {
																												// TODO: GEN_ERROR
																												valid_declaration = false;
																											}
																											else {
																												signal_width = user_defined_signal_width.value();
																											}
																										.)
")"]																									(.	// TODO: What if no dimensions is specified, add default dimension entry ?
																											if (valid_declaration) {
																												declared_signal.emplace(std::make_shared<Variable>(Variable(variable_type, signal_ident, dimensions, signal_width)));
																											}
																										.)	
.

/*-------------------------------------------------------------------------
Statement variants
-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
StatementList
-------------------------------------------------------------------------*/

// TODO: Add check that every call statement has its matching counterpart, no uncall can be made before its corresponding call was called
StatementList<. Statement::vec &statements .>								(.	std::optional<Statement::ptr> user_defined_statement;	.)
=
Statement<user_defined_statement>											(.	if (user_defined_statement.has_value()) {
																					statements.emplace_back(user_defined_statement.value());
																				}
																			.)
{																			(.	user_defined_statement.reset();	.)	
	";" Statement<user_defined_statement>									(.	if (user_defined_statement.has_value()) {
																					statements.emplace_back(user_defined_statement.value());
																				}
																			.)
}
.


/*-------------------------------------------------------------------------
Statement production
-------------------------------------------------------------------------*/

Statement<. std::optional<Statement::ptr> &user_defined_statement .>
=
CallStatement<user_defined_statement>
| ForStatement<user_defined_statement>
| IfStatement<user_defined_statement>
| UnaryStatement<user_defined_statement>
| SkipStatement<user_defined_statement>
| IF (check_if_is_assign_statement()) AssignStatement<user_defined_statement>
| SwapStatement<user_defined_statement>
.


/*-------------------------------------------------------------------------
CallStatement production
-------------------------------------------------------------------------*/

// TODO: Are aliases between the formal and actual parameters necessary (i.e. in a call statement should the parameter be replaced with the actual value)
CallStatement<. std::optional<Statement::ptr> &statement .>							(.	std::optional<bool> isCallStatement;
																						std::vector<std::string> calleeArguments {};
																						std::size_t numActualParameters = 0;
																						bool isValidCallOperation = true;
																					.)
=
(
	"call"																			(.	isCallStatement.emplace(true);	.)
	| "uncall"																		(.	isCallStatement.emplace(false);	.)
)																					(.	isValidCallOperation = isCallStatement.has_value();	.)
ident																				(.	std::string methodIdent = convert_to_uniform_text_format(t->val);
																						const MethodCallGuess::ptr guessesForPossibleCall = std::make_shared<MethodCallGuess>(MethodCallGuess(currSymTabScope, methodIdent));
																						if (!guessesForPossibleCall->hasSomeMatches()) {
																							// TODO: GEN_ERROR no method for ident declared
																							isValidCallOperation = false;
																						}
																					.)
"(" 
	ident																			(.	std::string parameterIdent = convert_to_uniform_text_format(t->val);
																						isValidCallOperation &= check_ident_was_declared(parameterIdent);

																						if (isValidCallOperation) {
																							const std::optional<std::variant<Variable::ptr, Number::ptr>> paramSymTabEntry = currSymTabScope->getVariable(parameterIdent);
																							isValidCallOperation = paramSymTabEntry.has_value() && std::holds_alternative<Variable::ptr>(paramSymTabEntry.value());

																							if (isValidCallOperation) {
																								guessesForPossibleCall->refineWithNextParameter(std::get<Variable::ptr>(paramSymTabEntry.value()));
																								calleeArguments.emplace_back(parameterIdent);
																							}
																							else {
																								// TODO: GEN_ERROR Declared identifier was not a variable (but a loop variable)
																							}
																						}
																						else {
																							// TODO: GEN_ERROR Use of undeclared identifier
																						}
																						numActualParameters++;
																					.)
	{
		"," ident																	(.	std::string parameterIdent = convert_to_uniform_text_format(t->val);
																						isValidCallOperation &= check_ident_was_declared(parameterIdent);

																						if (isValidCallOperation) {
																							const std::optional<std::variant<Variable::ptr, Number::ptr>> paramSymTabEntry = currSymTabScope->getVariable(parameterIdent);
																							isValidCallOperation = paramSymTabEntry.has_value() && std::holds_alternative<Variable::ptr>(paramSymTabEntry.value());

																							if (isValidCallOperation) {
																								guessesForPossibleCall->refineWithNextParameter(std::get<Variable::ptr>(paramSymTabEntry.value()));
																								calleeArguments.emplace_back(parameterIdent);
																							}
																							else {
																								// TODO: GEN_ERROR Declared identifier was not a variable (but a loop variable)
																							}
																						}
																						else {
																							// TODO: GEN_ERROR Use of undeclared identifier
																						}
																						numActualParameters++;
																					.)
	}																
")"																					(.	if (!isValidCallOperation){
																							return;
																						}

																						if (!guessesForPossibleCall->hasSomeMatches()) {
																							return;		
																						}
																						
																						guessesForPossibleCall->discardGuessesWithMoreThanNParameters(numActualParameters);
																						if (!guessesForPossibleCall->hasSomeMatches()) {
																							// TODO: GEN_ERROR All of the declared methods that matched had more than n parameters
																							return;
																						}

																						Module::vec possibleCalls = guessesForPossibleCall->getMatchesForGuess().value();
																						if (possibleCalls.size() > 1) {
																							// TODO: GEN_ERROR Ambiguous call, more than one match for current setups
																							return;
																						}
																						const Module::ptr matchingModuleForCall = possibleCalls.at(0);
																						if (isCallStatement.value()) {
																							statement.emplace(std::make_shared<syrec::CallStatement>(syrec::CallStatement(matchingModuleForCall, calleeArguments)));
																						}
																						else {
																							statement.emplace(std::make_shared<syrec::UncallStatement>(syrec::UncallStatement(matchingModuleForCall, calleeArguments)));
																						}
																					.)
.


/*-------------------------------------------------------------------------
ForStatement production
-------------------------------------------------------------------------*/

// TODO: Currently no negative numbers are supported
ForStatement<. std::optional<Statement::ptr> &statement .>								(.	std::optional<std::string> loopVariableIdent;
																							std::optional<Number::ptr> iterationRangeStart;
																							std::optional<Number::ptr> iterationRangeEnd;
																							std::optional<Number::ptr> customStepSize;
																							bool negativeStepSize = false;
																							Statement::vec loopBody{};
																							bool explicitRangeStartDefined = false;
																							bool explicitStepSizeDefined = false;
																						.)
=
"for" 
[IF (check_if_loop_iteration_range_start_is_defined()) (
	[
		IF (check_if_loop_variable_is_defined()) (
			"$" ident																	(.	const std::string &loopVarIdent = convert_to_uniform_text_format(t->val);
																							if (!check_ident_was_declared(loopVarIdent)) {
																								loopVariableIdent.emplace(convert_to_uniform_text_format(t->val));
																								SymbolTable::openScope(currSymTabScope);
																								const Number::ptr loopVariableEntry = std::make_shared<syrec::Number>(syrec::Number(loopVarIdent));
																								currSymTabScope->addEntry(loopVariableEntry);
																							}
																						.)
			"="
		)
	] 
	Number<iterationRangeStart, true>													(.	explicitRangeStartDefined = true;	.)
	"to"
)] 
Number<iterationRangeEnd, true>															(.	if (!explicitRangeStartDefined){
																								iterationRangeStart = iterationRangeEnd;
																							}
																						.)
["step"																					(.	explicitStepSizeDefined = true;	.)
	[	"-"																				(.	negativeStepSize = true;	.)
	] 
Number<customStepSize, true>															(.	if (customStepSize.has_value() && !customStepSize.value()->evaluate({})) {
																								// TODO: GEN_ERROR step size cannot be zero ?
																							}
																						.)		
]																						(.	if (!explicitStepSizeDefined) {
																								customStepSize.emplace(std::make_shared<syrec::Number>(syrec::Number(1)));
																							}

																							bool validLoopHeader = loopVariableIdent.has_value() 
																															&& (explicitRangeStartDefined ? iterationRangeStart.has_value() : true)
																															&& iterationRangeEnd.has_value()
																															&& (explicitStepSizeDefined ? customStepSize.has_value() : true);
																							if (validLoopHeader) {
																								const unsigned int iterationRangeStartValue = iterationRangeStart.value()->evaluate({});
																								const unsigned int iterationRangeEndValue = iterationRangeEnd.value()->evaluate({});
																								const unsigned int stepSize = customStepSize.value()->evaluate({});

																								unsigned int numIterations;
																								if ((negativeStepSize && iterationRangeEndValue > iterationRangeStartValue)
																									|| (!negativeStepSize && iterationRangeStartValue > iterationRangeEndValue)
																									|| !stepSize) {
																									// TODO: Either generate error or warning
																									numIterations = 0;	
																									validLoopHeader = false;
																								}
																								else {
																									numIterations = negativeStepSize 
																										? (iterationRangeStartValue - iterationRangeEndValue)
																										: (iterationRangeEndValue - iterationRangeStartValue);
																									numIterations = (numIterations + 1) / stepSize;
																								}
																							}
																						.)
"do" 
StatementList<loopBody>																	(.	if (loopBody.empty()) {
																								// TODO: GEN_ERROR
																							}
																						.)
"rof"																					(.	if (loopVariableIdent.has_value()) {
																								SymbolTable::closeScope(currSymTabScope);
																							}

																							// TODO: If a statement must be generated, one could create a skip statement instead of simply returning 
																							if (!validLoopHeader || loopBody.empty()) {
																								return;
																							}

																							const std::shared_ptr<syrec::ForStatement> loopStatement = std::make_shared<syrec::ForStatement>();
																							loopStatement->loopVariable = loopVariableIdent.value();
																							loopStatement->range = std::pair(iterationRangeStart.value(), iterationRangeEnd.value());
																							loopStatement->step = customStepSize.value();
																							loopStatement->statements = loopBody;
																							statement.emplace(loopStatement);
																						.)
.

/*-------------------------------------------------------------------------
IfStatement production
-------------------------------------------------------------------------*/

IfStatement<. std::optional<Statement::ptr> &statement .>		(.	const ExpressionEvaluationResult::ptr condition = createExpressionEvalutionResultContainer();
																	const ExpressionEvaluationResult::ptr closingCondition = createExpressionEvalutionResultContainer();
																	Statement::vec trueBranch{};
																	Statement::vec falseBranch{};
																.)	
=
"if" Expression<condition, 1u, false> 
"then" 
StatementList<trueBranch> 
"else" StatementList<falseBranch>
"fi" Expression<closingCondition, 1u, false>					(.	// TODO: Add check that condition and closing_condition match, closingCondition should use same bitwidth as condition
																	const bool conditionalWellFormed = condition->hasValue() 
																		&& closingCondition->hasValue()
																		&& !trueBranch.empty()
																		&& !falseBranch.empty();
																	if (!conditionalWellFormed) {
																		return;
																	}
															
																	const std::shared_ptr<syrec::IfStatement> &conditional = std::make_shared<syrec::IfStatement>();
																	conditional->condition = condition->getOrConvertToExpression(1u).value();
																	conditional->fiCondition = closingCondition->getOrConvertToExpression(1u).value();
																	conditional->thenStatements                    = trueBranch;
																	conditional->elseStatements                    = falseBranch;
																	statement.emplace(conditional);
																.)
.

/*-------------------------------------------------------------------------
UnaryStatement production
-------------------------------------------------------------------------*/

UnaryStatement<. std::optional<Statement::ptr> &statement .>			(.	SignalEvaluationResult unaryStmtOperand;
																			std::optional<syrec_operation::operation> unaryOperation;	
																		.)
=
(
	"~"																	(.	unaryOperation.emplace(syrec_operation::operation::negate_assign);	.)
	| "++"																(.	unaryOperation.emplace(syrec_operation::operation::increment_assign);	.)
	| "--"																(.	unaryOperation.emplace(syrec_operation::operation::decrement_assign);	.)
) 
"=" Signal<unaryStmtOperand, false>										(.	bool allSemanticChecksOk = true;
																			if (!unaryOperation.has_value()){
																				allSemanticChecksOk = false;
																				// TODO: GEN_ERROR Expected a valid unary operand
																			}
																			if (unaryStmtOperand.isValid() && !unaryStmtOperand.isVariableAccess()) {
																				allSemanticChecksOk = false;
																				// TODO: GEN_ERROR Operand can only be variable access
																			}

																			const std::optional<unsigned int> mappedOperation = map_operation_to_unary_operation(unaryOperation.value());
																			allSemanticChecksOk &= mappedOperation.has_value();
																			if (!allSemanticChecksOk) {
																				return;
																			}

																			const VariableAccess::ptr unaryOperandAsVarAccess = unaryStmtOperand.getAsVariableAccess().value();
																			statement.emplace(std::make_shared<syrec::UnaryStatement>(syrec::UnaryStatement(mappedOperation.value(), unaryOperandAsVarAccess)));
																		.)
.


/*-------------------------------------------------------------------------
AssignStatement production
-------------------------------------------------------------------------*/

AssignStatement<. std::optional<Statement::ptr> &statement .>	(.		SignalEvaluationResult assignStmtLhs;
																		const ExpressionEvaluationResult::ptr assignStmtRhs = createExpressionEvalutionResultContainer();
																		std::optional<syrec_operation::operation> assignOperation;
																		unsigned int expressionBitwidth = 1u;

																		std::optional<VariableAccess::ptr> assigned_to_obj;
																		bool allSemanticChecksOk = true;
																.)
=
Signal<assignStmtLhs, false>									(.		allSemanticChecksOk = assignStmtLhs.isValid();
																		if (allSemanticChecksOk){
																			if (!assignStmtLhs.isVariableAccess()) {
																				allSemanticChecksOk = false;
																				// TODO: GEN_ERROR: Lhs operand must be variable access
																			}
																			else {
																				expressionBitwidth = assignStmtLhs.getAsVariableAccess().value()->bitwidth();
																			}
																		}
																.)
(
	"^"															(.		assignOperation.emplace(syrec_operation::operation::xor_assign);	.)
	| "+"														(.		assignOperation.emplace(syrec_operation::operation::add_assign);	.)
	| "-"														(.		assignOperation.emplace(syrec_operation::operation::minus_assign);	.)
)					
"=" Expression<assignStmtRhs, expressionBitwidth, false>		(.		if (!allSemanticChecksOk || !assignOperation.has_value() || !assignStmtRhs->hasValue()) {
																			return;
																		}

																		// TODO: To not break reversability of operation, check that expression does not contain the assigned to signal 
																		const std::optional<unsigned int> mappedOperation = map_operation_to_assign_operation(assignOperation.value());
																		if (mappedOperation.has_value()) {
																			statement.emplace(std::make_shared<syrec::AssignStatement>(syrec::AssignStatement(assignStmtLhs.getAsVariableAccess().value(),
																																				mappedOperation.value(),
																																				assignStmtRhs->getOrConvertToExpression(expressionBitwidth).value())));
																		}
																.)		
.

/*-------------------------------------------------------------------------
SwapStatement production
-------------------------------------------------------------------------*/

SwapStatement<. std::optional<Statement::ptr> &statement .>			(.	SignalEvaluationResult swapMe, swapOther;
																		bool isSwapOperatorDefined = false;
																	.)
=
Signal<swapMe, false> 
"<=>"																(.	isSwapOperatorDefined = true;	.)
Signal<swapOther, false>											(.	bool allSemanticChecksOk = true;
																		if (swapMe.isValid() && !swapMe.isVariableAccess()) {
																			allSemanticChecksOk = false;
																			// TODO: GEN_ERROR: Lhs operand must be variable access
																		}
																		if (swapOther.isValid() && !swapOther.isVariableAccess()){
																			allSemanticChecksOk = false;
																			// TODO: GEN_ERROR: Lhs operand must be variable access
																		}

																		if (isSwapOperatorDefined && allSemanticChecksOk) {
																			statement.emplace(std::make_shared<syrec::SwapStatement>(syrec::SwapStatement(swapMe.getAsVariableAccess().value(),
																																						 swapOther.getAsVariableAccess().value())));
																		}
																	.)
.


/*-------------------------------------------------------------------------
SkipStatement production
-------------------------------------------------------------------------*/

SkipStatement<. std::optional<Statement::ptr> &statement .>
=
"skip"															(.	statement.emplace(std::make_shared<syrec::SkipStatement>(syrec::SkipStatement()));	.)
.


/*-------------------------------------------------------------------------
Signal production
-------------------------------------------------------------------------*/

Signal<SignalEvaluationResult &signalAccess, const bool simplifyIfPossible>			(.	std::optional<VariableAccess::ptr> accessedSignal;
																						const unsigned int defaultIndexExpressionBitwidth = 1u;
																						unsigned int indexExpressionBitwidth = defaultIndexExpressionBitwidth;

																						// TODO: Using global zero_based indexing flag to initialize default value
																						std::size_t accessedDimensionIdx = 0;
																					.)
=
	ident																			(.	const std::string signalIdent = convert_to_uniform_text_format(t->val);
																						if (check_ident_was_declared(signalIdent)) {
																							const auto symbolTableEntryForSignal = currSymTabScope->getVariable(signalIdent);
																							if (symbolTableEntryForSignal.has_value() && std::holds_alternative<Variable::ptr>(symbolTableEntryForSignal.value())) {
																								const VariableAccess::ptr container = std::make_shared<VariableAccess>(VariableAccess());
																								container->setVar(std::get<Variable::ptr>(symbolTableEntryForSignal.value()));
																								accessedSignal.emplace(container);
																								indexExpressionBitwidth = accessedSignal.value()->bitwidth();
																							}
																						}
																						bool isValidSignalAccess = accessedSignal.has_value();
																						bool indexExpressionsSemanticallyOk = isValidSignalAccess;
																					.)
{"["																				(.	ExpressionEvaluationResult::ptr dimensionExpression = createExpressionEvalutionResultContainer(); .)
	Expression<dimensionExpression, indexExpressionBitwidth, simplifyIfPossible>	(.	indexExpressionsSemanticallyOk &= dimensionExpression->hasValue();
																			
																						if (indexExpressionsSemanticallyOk) {
																							const std::optional<unsigned int> &constantValueForAccessedDimension = dimensionExpression->getAsConstant();
																							if (constantValueForAccessedDimension.has_value()) {
																								// TODO: Using global flag indicating zero_based indexing or not
																								indexExpressionsSemanticallyOk = range_check::isValidDimensionAccess(accessedSignal.value()->getVar(), constantValueForAccessedDimension.value(), true);

																								if (!indexExpressionsSemanticallyOk) {
																									// TODO: Using global flag indicating zero_based indexing or not
																									const range_check::IndexAccessRangeConstraint constraintForCurrentDimension = range_check::getConstraintsForValidDimensionAccess(accessedSignal.value()->getVar(), accessedDimensionIdx, true).value();
																									// TODO: GEN_ERROR
																								}
																							}

																							if (indexExpressionsSemanticallyOk) {
																								accessedSignal.value()->indexes.emplace_back(dimensionExpression->getOrConvertToExpression(indexExpressionBitwidth).value());
																							}
																						}
																						accessedDimensionIdx++;
																					.)
"]"		
}																					(.	isValidSignalAccess = indexExpressionsSemanticallyOk;	.)
[																					(.	std::optional<Number::ptr> bitRangeStart;
																						std::optional<Number::ptr> bitRangeEnd;
																						bool rangeExplicitlyDefined = false;
																					.)
	"." Number<bitRangeStart, false>									
	[
		":" Number<bitRangeEnd, false>												(.	rangeExplicitlyDefined = true;	.)
	]																				(.	isValidSignalAccess &= bitRangeStart.has_value() && (rangeExplicitlyDefined ? bitRangeEnd.has_value() : true);
																						if (isValidSignalAccess) {
																							const std::pair<Number::ptr, Number::ptr> bitRange(bitRangeStart.value(), rangeExplicitlyDefined ? bitRangeEnd.value() : bitRangeStart.value());
																							const std::pair<std::size_t, std::size_t> bitRangeEvaluated(bitRange.first->evaluate({}), bitRange.second->evaluate({}));
																						
																							const Variable::ptr &accessedVariable = accessedSignal.value()->getVar();
																							if (rangeExplicitlyDefined) {
																								// TODO: Using global zero_based indexing flag
																								if (!range_check::isValidBitRangeAccess(accessedVariable, bitRangeEvaluated, true)){
																									isValidSignalAccess = false;
																									// TODO: GEN_ERROR
																								}
																							}
																							else {
																								// TODO: Using global zero_based indexing flag	
																								if (!range_check::isValidBitAccess(accessedVariable, bitRangeEvaluated.first, true)){
																									isValidSignalAccess = false;
																									// TODO: GEN_ERROR
																								}
																							}

																							if (isValidSignalAccess) {
																								accessedSignal.value()->range.emplace(bitRange);
																							}
																						}
																					.)
	]																				(.	if (isValidSignalAccess) {
																							signalAccess.updateResultToVariableAccess(accessedSignal.value());
																						}
																					.)
.

/*-------------------------------------------------------------------------
Expressions variants
-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
Expression production
-------------------------------------------------------------------------*/

// TODO: Add flag to indicate whether the given bitwidth should be forced on the expression or the larger of the two should be choosen
Expression<const ExpressionEvaluationResult::ptr &userDefinedExpression, const unsigned int bitwidth, const bool simplifyIfPossible>	(.	SignalEvaluationResult signal;
																																			std::optional<Number::ptr> number;
																																		.)
=
(
	IF (check_if_expression_is_number()) Number<number, simplifyIfPossible>																(.	if (number.has_value()) {
																																				const NumericExpression::ptr expr = std::make_shared<NumericExpression>(NumericExpression(number.value(), bitwidth));
																																				userDefinedExpression->setResult(expr);
																																			}
																																		.)
	| IF (check_if_expression_is_binary_expression()) BinaryExpression<userDefinedExpression, bitwidth, simplifyIfPossible>
	| ShiftExpression<userDefinedExpression, bitwidth, simplifyIfPossible>
)
	| Signal<signal, simplifyIfPossible>																								(.	if (!signal.isValid()) {
																																				return;
																																			}

																																			if (signal.isVariableAccess()) {
																																				userDefinedExpression->setResult(std::make_shared<VariableExpression>(VariableExpression(signal.getAsVariableAccess().value())));
																																			}
																																			else if (signal.isConstant()) {
																																				userDefinedExpression->setResult(std::make_shared<NumericExpression>(NumericExpression(signal.getAsNumber().value(), bitwidth)));
																																			}
																																		.)
	| UnaryExpression<userDefinedExpression, bitwidth, simplifyIfPossible>
.

/*-------------------------------------------------------------------------
BinaryExpression production
-------------------------------------------------------------------------*/

BinaryExpression<const ExpressionEvaluationResult::ptr &parsedBinaryExpression, const unsigned int bitwidth, const bool simplifyIfPossible>	(.	ExpressionEvaluationResult::ptr binaryExprLhs = createExpressionEvalutionResultContainer();
																																				ExpressionEvaluationResult::ptr binaryExprRhs = createExpressionEvalutionResultContainer();
																																				std::optional<syrec_operation::operation> binaryOperation;
																																				unsigned int expectedBitWidth = bitwidth;
																																			.)	
=
"(" Expression<binaryExprLhs, bitwidth, simplifyIfPossible>																					(.	if (binaryExprLhs->hasValue()) {
																																					expectedBitWidth = std::max(binaryExprLhs->getOrConvertToExpression(std::nullopt).value()->bitwidth(), expectedBitWidth);
																																				}
																																			.)
	(
		"+"																																	(.	binaryOperation.emplace(syrec_operation::operation::addition);	.)
		| "-"																																(.	binaryOperation.emplace(syrec_operation::operation::subtraction);	.)
		| "^"																																(.	binaryOperation.emplace(syrec_operation::operation::bitwise_xor);	.)
		| "*"																																(.	binaryOperation.emplace(syrec_operation::operation::multiplication);	.)
		| "/"																																(.	binaryOperation.emplace(syrec_operation::operation::division);	.)
		| "%"																																(.	binaryOperation.emplace(syrec_operation::operation::modulo);	.)
		| "*>"																																(.	binaryOperation.emplace(syrec_operation::operation::upper_bits_multiplication);	.)
		| "&&"																																(.	binaryOperation.emplace(syrec_operation::operation::logical_and);	.)
		| "||"																																(.	binaryOperation.emplace(syrec_operation::operation::logical_or);	.)
		| "&"																																(.	binaryOperation.emplace(syrec_operation::operation::bitwise_and);	.)
		| "|"																																(.	binaryOperation.emplace(syrec_operation::operation::bitwise_or);	.)
		| "<"																																(.	binaryOperation.emplace(syrec_operation::operation::less_than);	.)
		| ">"																																(.	binaryOperation.emplace(syrec_operation::operation::greater_than);	.)
		| "="																																(.	binaryOperation.emplace(syrec_operation::operation::equals);	.)
		| "!="																																(.	binaryOperation.emplace(syrec_operation::operation::not_equals);	.)
		| "<="																																(.	binaryOperation.emplace(syrec_operation::operation::less_equals);	.)
		| ">="																																(.	binaryOperation.emplace(syrec_operation::operation::greater_equals);	.)
	)																																		(.	if (!binaryOperation.has_value()) {
																																					// TODO: GEN_ERROR Expected one of n possible operands but non was specified
																																				}
																																			.)
	Expression<binaryExprRhs, expectedBitWidth, simplifyIfPossible>																
")"																																			(.	if (binaryExprLhs->hasValue() && binaryOperation.has_value() && binaryExprRhs->hasValue()) {
																																				const std::optional<unsigned int> mappedOperation = map_operation_to_binary_operation(binaryOperation.value());
																																				if (!mappedOperation.has_value()) {
																																					return;
																																				}

																																				if (binaryExprLhs->evaluatedToConstant() && binaryExprRhs->evaluatedToConstant()) {
																																					const unsigned int lhsValueEvaluated = binaryExprLhs->getAsConstant().value();
																																					const unsigned int rhsValueEvaluated = binaryExprRhs->getAsConstant().value();
																																					const std::optional<unsigned int> operationApplicationResult = apply_binary_operation(binaryOperation.value(), lhsValueEvaluated, rhsValueEvaluated);
																																					if (operationApplicationResult.has_value()) {
																																						parsedBinaryExpression->setResult(operationApplicationResult.value(), expectedBitWidth);
																																					}
																																				}
																																				else {
																																					const expression::ptr lhsOperand = binaryExprLhs->getOrConvertToExpression(std::nullopt).value();
																																					const expression::ptr rhsOperand = binaryExprRhs->getOrConvertToExpression(std::nullopt).value();
																																					parsedBinaryExpression->setResult(std::make_shared<syrec::BinaryExpression>(syrec::BinaryExpression(lhsOperand, 
																																																												 mappedOperation.value(),
																																																												 rhsOperand)));
																																				}
																																			}
																																		.)
.


/*-------------------------------------------------------------------------
UnaryExpression production
-------------------------------------------------------------------------*/

UnaryExpression<const ExpressionEvaluationResult::ptr &unaryExpression, const unsigned int bitwidth, const bool simplifyIfPossible>	(.	ExpressionEvaluationResult::ptr unaryExpressionOperand = createExpressionEvalutionResultContainer();
																																		std::optional<syrec_operation::operation> unaryOperation;
																																	.)	
=
(
	"!"																																(.	unaryOperation.emplace(syrec_operation::operation::logical_negation);	.)
	| "~"																															(.	unaryOperation.emplace(syrec_operation::operation::bitwise_negation);	.)
)		
Expression<unaryExpressionOperand, bitwidth, simplifyIfPossible>																	(.	// TODO: Notify user (i.e. via error) that reference parser currently does not support unary statements - we will ignore them for now
																																		return;
																																	.)	
.


/*-------------------------------------------------------------------------
ShiftExpression production
-------------------------------------------------------------------------*/

ShiftExpression<const ExpressionEvaluationResult::ptr &userDefinedShiftExpression, const unsigned int bitwidth, const bool simplifyIfPossible>	(.	ExpressionEvaluationResult::ptr shiftExpressionLhs = createExpressionEvalutionResultContainer();
																																					std::optional<Number::ptr> shiftAmount;
																																					std::optional<syrec_operation::operation> shiftOperation;
																																				.)
=
"(" Expression<shiftExpressionLhs, bitwidth, simplifyIfPossible> 
(
	"<<"																																		(.	shiftOperation.emplace(syrec_operation::operation::shift_left);	.)
	| ">>"																																		(.	shiftOperation.emplace(syrec_operation::operation::shift_right);	.)
) Number<shiftAmount, simplifyIfPossible>																										(.	if (!shiftExpressionLhs->hasValue() || !shiftOperation.has_value() || !shiftAmount.has_value()) {
																																						return;
																																					}
																																					const std::optional<unsigned int> mappedShiftOperation = map_operation_to_shift_operation(shiftOperation.value());
																																					const expression::ptr lhsOperandExpression = shiftExpressionLhs->getOrConvertToExpression(bitwidth).value();
																																		
																																					// One could replace the shift statement with a skip statement if the shift amount is zero 
																																					const std::optional<unsigned int> shiftAmountValueEvaluated = evaluate_number_container_to_constant(shiftAmount.value());
																																					const std::optional<unsigned int> lhsOperandValueEvaluated = shiftExpressionLhs->getAsConstant();

																																					if (shiftAmountValueEvaluated.has_value() && lhsOperandValueEvaluated.has_value()) {
																																						const std::optional<unsigned int> shiftApplicationResult = syrec_operation::apply(shiftOperation.value(), lhsOperandValueEvaluated.value(), shiftAmountValueEvaluated.value());
																																						if (shiftApplicationResult.has_value()) {
																																							userDefinedShiftExpression->setResult(shiftApplicationResult.value(), bitwidth);
																																						}
																																						else {
																																							// TODO: GEN_ERROR
																																							return;
																																						}
																																					}
																																					else {
																																						userDefinedShiftExpression->setResult(std::make_shared<syrec::ShiftExpression>(lhsOperandExpression,
																																																									mappedShiftOperation.value(),
																																																									shiftAmount.value()));
																																					}
																																				.)
")"
.

END SyReC.