/*-------------------------------------------------------------------------
ATG for SyReC: A Programming Language for Synthesis of Reversible Circuits
(specification available @ http://www.revlib.org/doc/docu/revlib_2_0_1.pdf)

User manual for Coco/R is available @
https://ssw.jku.at/Research/Projects/Coco/Doc/UserManual.pdf
-------------------------------------------------------------------------*/
/*-- $checkEOF=false --*/

// Place includes here
#include <optional>
#include <string>
#include <vector>

#include "core/syrec/module.hpp"
#include "core/syrec/parser/expression_evaluation_result.hpp"
#include "core/syrec/parser/grammar_conflict_resolver.hpp"
#include "core/syrec/parser/method_call_guess.hpp"
#include "core/syrec/parser/operation.hpp"
#include "core/syrec/parser/range_check.hpp"
#include "core/syrec/parser/signal_evaluation_result.hpp"
#include "core/syrec/parser/symbol_table.hpp"
#include "core/syrec/parser/text_utils.hpp"

COMPILER SyReC
	// Place declarations of objects referenced in this ATG
	syrec::Module::vec modules;
	SymbolTable::ptr currSymTabScope;

	syrec::Number::loop_variable_mapping loop_variable_mapping_lookup;

	// This method will be called by the contructor if it exits.
	// This support is specific to the C++ version of Coco/R.
	void Init() {
		// nothing to do
		SymbolTable::openScope(currSymTabScope);
	}

	// Uncomment this method if cleanup is necessary,
	// this method will be called by the destructor if it exists.
	// This support is specific to the C++ version of Coco/R.
	// void Destroy() {
		// nothing to do
	// }

	[[nodiscard]] std::optional<unsigned int> convert_token_value_to_number(const Token &token) {
		std::optional<unsigned int> token_as_number;
		try {
			token_as_number.emplace(std::stoul(convert_to_uniform_text_format(token.val)));
		} 
		catch (std::invalid_argument const &ex) {
			// TODO: GEN_ERROR
		}
		catch (std::out_of_range const &ex) {
			// TODO: GEN_ERROR
		}
		return token_as_number;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_assign_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::add_assign:
				mapping_result.emplace(syrec::AssignStatement::Add);
				break;
			case syrec_operation::operation::minus_assign:
				mapping_result.emplace(syrec::AssignStatement::Subtract);
				break;
			case syrec_operation::operation::xor_assign:
				mapping_result.emplace(syrec::AssignStatement::Exor);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_unary_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::increment_assign:
				mapping_result.emplace(syrec::UnaryStatement::Increment);
				break;
			case syrec_operation::operation::decrement_assign:
				mapping_result.emplace(syrec::UnaryStatement::Decrement);
				break;
			case syrec_operation::operation::negate_assign:
				mapping_result.emplace(syrec::UnaryStatement::Invert);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_shift_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::shift_left:
				mapping_result.emplace(syrec::ShiftExpression::Left);
				break;
			case syrec_operation::operation::shift_right:
				mapping_result.emplace(syrec::ShiftExpression::Right);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_binary_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::addition:
				mapping_result.emplace(syrec::BinaryExpression::Add);
				break;
			case syrec_operation::operation::subtraction:
				mapping_result.emplace(syrec::BinaryExpression::Subtract);
				break;
				case syrec_operation::operation::multiplication:
				mapping_result.emplace(syrec::BinaryExpression::Multiply);
				break;		
			case syrec_operation::operation::division:
				mapping_result.emplace(syrec::BinaryExpression::Divide);
				break;			
			case syrec_operation::operation::modulo:
				mapping_result.emplace(syrec::BinaryExpression::Modulo);
				break;		
			case syrec_operation::operation::upper_bits_multiplication:
				mapping_result.emplace(syrec::BinaryExpression::FracDivide);
				break;		
			case syrec_operation::operation::bitwise_xor:
				mapping_result.emplace(syrec::BinaryExpression::Exor);
				break;		
			case syrec_operation::operation::logical_and:
				mapping_result.emplace(syrec::BinaryExpression::LogicalAnd);
				break;		
			case syrec_operation::operation::logical_or:
				mapping_result.emplace(syrec::BinaryExpression::LogicalOr);
				break;		
			case syrec_operation::operation::bitwise_and:
				mapping_result.emplace(syrec::BinaryExpression::BitwiseAnd);
				break;	
			case syrec_operation::operation::bitwise_or:
				mapping_result.emplace(syrec::BinaryExpression::BitwiseOr);
				break;	
			case syrec_operation::operation::less_than:
				mapping_result.emplace(syrec::BinaryExpression::LessThan);
				break;	
			case syrec_operation::operation::greater_than:
				mapping_result.emplace(syrec::BinaryExpression::GreaterThan);
				break;	
			case syrec_operation::operation::equals:
				mapping_result.emplace(syrec::BinaryExpression::Equals);
				break;		
			case syrec_operation::operation::not_equals:
				mapping_result.emplace(syrec::BinaryExpression::NotEquals);
				break;		
			case syrec_operation::operation::less_equals:
				mapping_result.emplace(syrec::BinaryExpression::LessEquals);
				break;		
			case syrec_operation::operation::greater_equals:
				mapping_result.emplace(syrec::BinaryExpression::GreaterEquals);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	bool checkIdentWasDeclaredOrLogError(const std::string_view& ident) const {
		if (!currSymTabScope->contains(ident)) {
			// TOOD: GEN_ERROR
			return false;
		}
		return true;
	}

	[[nodiscard]] static std::optional<unsigned int> applyBinaryOperation(const syrec_operation::operation operation, const unsigned int leftOperand, const unsigned int rightOperand) {
		if (operation == syrec_operation::operation::division && rightOperand == 0) {
			// TODO: GEN_ERROR
			return std::nullopt;	
		}
		else {
			return syrec_operation::apply(operation, leftOperand, rightOperand);	
		}
	}

	[[nodiscard]] std::optional<unsigned int> evaluateNumberContainer(const syrec::Number::ptr &numberContainer) const {
		if (numberContainer->isLoopVariable()) {
			const std::string& loopVariableIdentToResolve = numberContainer->variableName();
			if (loop_variable_mapping_lookup.find(loopVariableIdentToResolve) == loop_variable_mapping_lookup.end()) {
				// TODO: GEN_ERROR
				return std::nullopt;
			}
		}
		return std::optional(numberContainer->evaluate(loop_variable_mapping_lookup));
	}

	[[nodiscard]] ExpressionEvaluationResult::ptr createExpressionEvalutionResultContainer() const {
		return std::make_shared<ExpressionEvaluationResult>(ExpressionEvaluationResult());
	}

/*-------------------------------------------------------------------------*/

CHARACTERS
	letter		= 'A' .. 'Z' + 'a' .. 'z'.
	digit		= '0' .. '9'.

	cr        = '\r'.
	lf        = '\n'.
	tab       = '\t'.

TOKENS
	ident		= ('_' | letter) {('_' | letter | digit)}.
	int			= digit {digit}.
	
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/
PRODUCTIONS


/*-------------------------------------------------------------------------
syrec::Number production

Since Coco/R does not accept recursive token definitions, 
we redefine the token 'syrec::Number as a non-terminal symbol
-------------------------------------------------------------------------*/
// TODO: Current data structure does not handle negative numbers well, one migitation could be to use the two-complement representation (which would require to update the calculation for many operations (i.e. division, etc.))
// TODO: Currently synthesis uses ident without '$' prefix for its loop mappings
// TODO: For now no loop variable mappings will get added to the lookup (since currently no support for iterating a list of statements is supported)

// TODO: Expression productions still require checks that the bitwidth of the internal expressions (i.e. the left and right expression in a binary expression) are not larger than the input one

Number<. std::optional<syrec::Number::ptr> &parsedNumber, const bool simplifyIfPossible .>									
=
int																			(.	const std::optional<unsigned int> conversion_result = convert_token_value_to_number(*t);
																				if (conversion_result.has_value()) {
																					const syrec::Number::ptr result = std::make_shared<syrec::Number>(syrec::Number(conversion_result.value())); 
																					parsedNumber.emplace(result);
																				}
																			.)
| '#' ident																	(.	const std::string signalIdent = convert_to_uniform_text_format(t->val);
																				if (!checkIdentWasDeclaredOrLogError(signalIdent)) {
																					return;
																				}

																				const auto &symTabEntry = currSymTabScope->getVariable(signalIdent);
																				if (symTabEntry.has_value() && std::holds_alternative<syrec::Variable::ptr>(symTabEntry.value())) {
																					parsedNumber.emplace(std::make_shared<syrec::Number>(syrec::Number(std::get<syrec::Variable::ptr>(symTabEntry.value())->bitwidth)));
																				}
																				else {
																					// TODO: GEN_ERROR, this should not happen but check anyways
																					return;
																				}
																			.)
| '$' ident																	(.	const std::string signalIdent = convert_to_uniform_text_format(t->val);
																				if (!checkIdentWasDeclaredOrLogError(signalIdent)) {
																					return;
																				}
																				
																				const auto &symTabEntry = currSymTabScope->getVariable(signalIdent);
																				if (symTabEntry.has_value() && std::holds_alternative<syrec::Number::ptr>(symTabEntry.value())) {
																					// TODO: An optimization that can be done here would be the replacement of the loop variable with its current value from the mapping
																					parsedNumber.emplace(std::get<syrec::Number::ptr>(symTabEntry.value()));
																				}
																				else {
																					// TODO: GEN_ERROR, this should not happen but check anyways
																				}
																			.)
| (																			(.	std::optional<syrec::Number::ptr> lhsOperand, rhsOperand;  
																				std::optional<syrec_operation::operation> op;
																			.)
	'(' 
		Number<lhsOperand, simplifyIfPossible>
		('+'																(.	op.emplace(syrec_operation::operation::addition);		.)
		|'-'																(.	op.emplace(syrec_operation::operation::subtraction);	.)
		|'*'																(.	op.emplace(syrec_operation::operation::multiplication);	.)
		|'/'																(.	op.emplace(syrec_operation::operation::division);		.)
		) 
		Number<rhsOperand, simplifyIfPossible>								(.	if (!op.has_value()) {
																					// TODO: GEN_ERROR Expected one of n operand but not of them was specified
																					return;
																				}

																				if (!lhsOperand.has_value() || !rhsOperand.has_value()){
																					return;
																				}

																				const std::optional<unsigned int> lhsEvaluated = evaluateNumberContainer(lhsOperand.value());
																				const std::optional<unsigned int> rhsEvaluated = evaluateNumberContainer(rhsOperand.value());

																				if (lhsEvaluated.has_value() && rhsEvaluated.has_value()) {
																					const std::optional<unsigned int> evaluationResult = applyBinaryOperation(op.value(), lhsEvaluated.value(), rhsEvaluated.value());

																					if (evaluationResult.has_value()) {
																						const syrec::Number::ptr result = std::make_shared<syrec::Number>(syrec::Number(evaluationResult.value())); 
																						parsedNumber.emplace(result);
																					}
																				}
																			.)
	')'																	
)
.

/*-------------------------------------------------------------------------
Program and Modules
-------------------------------------------------------------------------*/

SyReC										(.	std::optional<syrec::Module::ptr> module;	.)
=
Module<module>								(.	if (module.has_value()) {
													currSymTabScope->addEntry(module.value());
													this->modules.emplace_back(module.value());
												}
											.)
{											(.	module.reset();	.)
	Module<module>							(.	if (module.has_value()) {
													const syrec::Module::ptr well_formed_module = module.value();
													if (currSymTabScope->contains(well_formed_module)) {
														// TODO: GEN_ERROR 
														// TODO: Do not cancel parsing	
													}
													else {
														currSymTabScope->addEntry(well_formed_module);
														this->modules.emplace_back(module.value());
													}
												}
											.)
}
.

/*-------------------------------------------------------------------------
syrec::Module production
-------------------------------------------------------------------------*/

Module <. std::optional<syrec::Module::ptr> &parsed_module	.>			(.	SymbolTable::openScope(currSymTabScope);
																			std::optional<std::vector<syrec::Variable::ptr>> locals;	
																			bool valid_module_definition = false;
																			syrec::Statement::vec module_body {};
																		.)	
=
"module" ident															(.	const std::string module_name = convert_to_uniform_text_format(t->val);	
																			syrec::Module::ptr user_defined_module = std::make_shared<syrec::Module>(syrec::Module(module_name));
																		.)	
"(" [ParameterList<valid_module_definition, user_defined_module>] ")" 
{
	SignalList<locals>													(.	valid_module_definition &= locals.has_value();	.)
}														
StatementList<module_body>												(.	SymbolTable::closeScope(currSymTabScope);
																			if (module_body.empty()) {
																				valid_module_definition = false;
																				// TODO: GEN_ERROR
																			}

																			if (valid_module_definition) {
																				user_defined_module->variables = locals.value_or(std::vector<syrec::Variable::ptr>{});
																				for (const auto &statement : module_body) {
																					user_defined_module->addStatement(statement);
																				}
																				parsed_module.emplace(user_defined_module);
																			}
																		.)
.


/*-------------------------------------------------------------------------
ParameterList production
-------------------------------------------------------------------------*/

ParameterList<bool &is_valid_module_definition, const syrec::Module::ptr &module>			(.	std::optional<syrec::Variable::ptr> parameter;	.)
=
Parameter<parameter>																(.	is_valid_module_definition = parameter.has_value();
																						if (is_valid_module_definition) {
																							module->addParameter(parameter.value());
																							currSymTabScope->addEntry(parameter.value());
																						}
																					.)
{																					(.	parameter.reset();	.)
	"," Parameter<parameter>														(.	is_valid_module_definition = parameter.has_value();
																						if (is_valid_module_definition) {	
																							const syrec::Variable::ptr &well_formed_parameter = parameter.value();
																							if (!currSymTabScope->contains(well_formed_parameter->name)) {
																								module->addParameter(well_formed_parameter);
																								currSymTabScope->addEntry(well_formed_parameter);
																							}
																							else {
																								is_valid_module_definition = false;
																								// TODO: GEN_ERROR 
																							}
																						}
																					.)
}															
.


/*-------------------------------------------------------------------------
Parameter production
-------------------------------------------------------------------------*/

Parameter<. std::optional<syrec::Variable::ptr> &parameter .>								(.	syrec::Variable::Types parameter_type = syrec::Variable::Wire;
																						bool valid_variable_type = true;
																					.)	
= 
(
	"in"																			(.	parameter_type = syrec::Variable::In;	.)
	| "out"																			(.	parameter_type = syrec::Variable::Out;	.)
	| "inout"																		(.	parameter_type = syrec::Variable::Inout;	.)	
)																					(.	if (syrec::Variable::Wire == parameter_type) {
																							// TODO: GEN_ERROR 
																							// TODO: Do not cancel parsing
																							valid_variable_type = false;
																						}
																					.)
SignalDeclaration<parameter_type, parameter>										(.	if (!valid_variable_type) {
																							parameter.reset();
																						}
																					.)
.

/*-------------------------------------------------------------------------
SignalList production
-------------------------------------------------------------------------*/

SignalList <. std::optional<std::vector<syrec::Variable::ptr>> &signals .>	(.	syrec::Variable::Types signal_type = syrec::Variable::In;
																		std::optional<syrec::Variable::ptr> declared_signal;
																		bool valid_signal_type = true;
																		std::vector<syrec::Variable::ptr> valid_signal_declarations;
																	.)
=
(
	"wire"															(.	signal_type = syrec::Variable::Wire;		.)
	| "state"														(.	signal_type = syrec::Variable::State;		.)
)																	(.	if (syrec::Variable::Wire != signal_type && syrec::Variable::State != signal_type) {
																			// TODO: GEN_ERROR ?
																			// TODO: Do not cancel parsing
																			valid_signal_type = false;
																		}
																	.)
SignalDeclaration<signal_type, declared_signal>						(.	if (valid_signal_type && declared_signal.has_value()) {
																			const syrec::Variable::ptr &valid_signal_declaration = declared_signal.value();
																			if (currSymTabScope->contains(valid_signal_declaration->name)) {
																				// TODO: GEN_ERROR 
																				// TODO: Do not cancel parsing
																			}
																			else {
																				valid_signal_declarations.emplace_back(valid_signal_declaration);
																				currSymTabScope->addEntry(valid_signal_declaration);
																			}
																		}
																	.)
{																	(.	declared_signal.reset();			.)	
	"," SignalDeclaration<signal_type, declared_signal>				(.	if (valid_signal_type && declared_signal.has_value()) {
																			const syrec::Variable::ptr &valid_signal_declaration = declared_signal.value();
																			if (currSymTabScope->contains(valid_signal_declaration->name)) {
																				// TODO: GEN_ERROR 
																				// TODO: Do not cancel parsing
																			}
																			else {
																				valid_signal_declarations.emplace_back(valid_signal_declaration);
																				currSymTabScope->addEntry(valid_signal_declaration);
																			}
																		}
																	.)
}																	(.	if (valid_signal_declarations.size()){
																			signals.emplace(valid_signal_declarations);
																		}
																	.)
.


/*-------------------------------------------------------------------------
SignalDeclaration production
-------------------------------------------------------------------------*/

SignalDeclaration<. const syrec::Variable::Types variable_type, std::optional<syrec::Variable::ptr> &declared_signal .>	(.	std::vector<unsigned int> dimensions{};
																												// TODO: Use default bit width
																												unsigned int signal_width = 0;	
																												bool valid_declaration = true;
																											.)
=
ident																										(.	const std::string signal_ident = convert_to_uniform_text_format(t->val);	.)
{"[" 
	int																										(.	const std::optional<unsigned int> dimension = convert_token_value_to_number(*t);
																												if (!dimension.has_value()) {
																													valid_declaration = false;
																													// TODO: GEN_ERROR
																												}
																												else {
																													dimensions.emplace_back(dimension.value());	
																												}
																											.)
"]"}																									
["(" 
	int																									(.	const std::optional<unsigned int> user_defined_signal_width = convert_token_value_to_number(*t);
																											if (!user_defined_signal_width.has_value()) {
																												// TODO: GEN_ERROR
																												valid_declaration = false;
																											}
																											else {
																												signal_width = user_defined_signal_width.value();
																											}
																										.)
")"]																									(.	// TODO: What if no dimensions is specified, add default dimension entry ?
																											if (valid_declaration) {
																												declared_signal.emplace(std::make_shared<syrec::Variable>(syrec::Variable(variable_type, signal_ident, dimensions, signal_width)));
																											}
																										.)	
.

/*-------------------------------------------------------------------------
syrec::Statement variants
-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
StatementList
-------------------------------------------------------------------------*/

// TODO: Add check that every call statement has its matching counterpart, no uncall can be made before its corresponding call was called
StatementList<. syrec::Statement::vec &statements .>						(.	std::optional<syrec::Statement::ptr> user_defined_statement;	.)
=
Statement<user_defined_statement>											(.	if (user_defined_statement.has_value()) {
																					statements.emplace_back(user_defined_statement.value());
																				}
																			.)
{																			(.	user_defined_statement.reset();	.)	
	";" Statement<user_defined_statement>									(.	if (user_defined_statement.has_value()) {
																					statements.emplace_back(user_defined_statement.value());
																				}
																			.)
}
.


/*-------------------------------------------------------------------------
syrec::Statement production
-------------------------------------------------------------------------*/

Statement<. std::optional<syrec::Statement::ptr> &user_defined_statement .>
=
CallStatement<user_defined_statement>
| ForStatement<user_defined_statement>
| IfStatement<user_defined_statement>
| UnaryStatement<user_defined_statement>
| SkipStatement<user_defined_statement>
| IF (shouldTakeAssignInsteadOfSwapAlternative(this)) AssignStatement<user_defined_statement>
| SwapStatement<user_defined_statement>
.


/*-------------------------------------------------------------------------
CallStatement production
-------------------------------------------------------------------------*/

// TODO: Are aliases between the formal and actual parameters necessary (i.e. in a call statement should the parameter be replaced with the actual value)
CallStatement<. std::optional<syrec::Statement::ptr> &statement .>							(.	std::optional<bool> isCallStatement;
																						std::vector<std::string> calleeArguments {};
																						std::size_t numActualParameters = 0;
																						bool isValidCallOperation = true;
																					.)
=
(
	"call"																			(.	isCallStatement.emplace(true);	.)
	| "uncall"																		(.	isCallStatement.emplace(false);	.)
)																					(.	isValidCallOperation = isCallStatement.has_value();	.)
ident																				(.	std::string methodIdent = convert_to_uniform_text_format(t->val);
																						const MethodCallGuess::ptr guessesForPossibleCall = std::make_shared<MethodCallGuess>(MethodCallGuess(currSymTabScope, methodIdent));
																						if (!guessesForPossibleCall->hasSomeMatches()) {
																							// TODO: GEN_ERROR no method for ident declared
																							isValidCallOperation = false;
																						}
																					.)
"(" 
	ident																			(.	std::string parameterIdent = convert_to_uniform_text_format(t->val);
																						isValidCallOperation &= checkIdentWasDeclaredOrLogError(parameterIdent);

																						if (isValidCallOperation) {
																							const std::optional<std::variant<syrec::Variable::ptr, syrec::Number::ptr>> paramSymTabEntry = currSymTabScope->getVariable(parameterIdent);
																							isValidCallOperation = paramSymTabEntry.has_value() && std::holds_alternative<syrec::Variable::ptr>(paramSymTabEntry.value());

																							if (isValidCallOperation) {
																								guessesForPossibleCall->refineWithNextParameter(std::get<syrec::Variable::ptr>(paramSymTabEntry.value()));
																								calleeArguments.emplace_back(parameterIdent);
																							}
																							else {
																								// TODO: GEN_ERROR Declared identifier was not a variable (but a loop variable)
																							}
																						}
																						else {
																							// TODO: GEN_ERROR Use of undeclared identifier
																						}
																						numActualParameters++;
																					.)
	{
		"," ident																	(.	std::string parameterIdent = convert_to_uniform_text_format(t->val);
																						isValidCallOperation &= checkIdentWasDeclaredOrLogError(parameterIdent);

																						if (isValidCallOperation) {
																							const std::optional<std::variant<syrec::Variable::ptr, syrec::Number::ptr>> paramSymTabEntry = currSymTabScope->getVariable(parameterIdent);
																							isValidCallOperation = paramSymTabEntry.has_value() && std::holds_alternative<syrec::Variable::ptr>(paramSymTabEntry.value());

																							if (isValidCallOperation) {
																								guessesForPossibleCall->refineWithNextParameter(std::get<syrec::Variable::ptr>(paramSymTabEntry.value()));
																								calleeArguments.emplace_back(parameterIdent);
																							}
																							else {
																								// TODO: GEN_ERROR Declared identifier was not a variable (but a loop variable)
																							}
																						}
																						else {
																							// TODO: GEN_ERROR Use of undeclared identifier
																						}
																						numActualParameters++;
																					.)
	}																
")"																					(.	if (!isValidCallOperation){
																							return;
																						}

																						if (!guessesForPossibleCall->hasSomeMatches()) {
																							return;		
																						}
																						
																						guessesForPossibleCall->discardGuessesWithMoreThanNParameters(numActualParameters);
																						if (!guessesForPossibleCall->hasSomeMatches()) {
																							// TODO: GEN_ERROR All of the declared methods that matched had more than n parameters
																							return;
																						}

																						syrec::Module::vec possibleCalls = guessesForPossibleCall->getMatchesForGuess().value();
																						if (possibleCalls.size() > 1) {
																							// TODO: GEN_ERROR Ambiguous call, more than one match for current setups
																							return;
																						}
																						const syrec::Module::ptr matchingModuleForCall = possibleCalls.at(0);
																						if (isCallStatement.value()) {
																							statement.emplace(std::make_shared<syrec::CallStatement>(syrec::CallStatement(matchingModuleForCall, calleeArguments)));
																						}
																						else {
																							statement.emplace(std::make_shared<syrec::UncallStatement>(syrec::UncallStatement(matchingModuleForCall, calleeArguments)));
																						}
																					.)
.


/*-------------------------------------------------------------------------
ForStatement production
-------------------------------------------------------------------------*/

// TODO: Currently no negative numbers are supported
ForStatement<. std::optional<syrec::Statement::ptr> &statement .>								(.	std::optional<std::string> loopVariableIdent;
																							std::optional<syrec::Number::ptr> iterationRangeStart;
																							std::optional<syrec::Number::ptr> iterationRangeEnd;
																							std::optional<syrec::Number::ptr> customStepSize;
																							bool negativeStepSize = false;
																							syrec::Statement::vec loopBody{};
																							bool explicitRangeStartDefined = false;
																							bool explicitStepSizeDefined = false;
																						.)
=
"for" 
[IF (checkIsLoopInitialValueExplicitlyDefined(this)) (
	[
		IF (checkIsLoopVariableExplicitlyDefined(this)) (
			"$" ident																	(.	const std::string &loopVarIdent = convert_to_uniform_text_format(t->val);
																							if (!checkIdentWasDeclaredOrLogError(loopVarIdent)) {
																								loopVariableIdent.emplace(convert_to_uniform_text_format(t->val));
																								SymbolTable::openScope(currSymTabScope);
																								const syrec::Number::ptr loopVariableEntry = std::make_shared<syrec::Number>(syrec::Number(loopVarIdent));
																								currSymTabScope->addEntry(loopVariableEntry);
																							}
																						.)
			"="
		)
	] 
	Number<iterationRangeStart, true>													(.	explicitRangeStartDefined = true;	.)
	"to"
)] 
Number<iterationRangeEnd, true>															(.	if (!explicitRangeStartDefined){
																								iterationRangeStart = iterationRangeEnd;
																							}
																						.)
["step"																					(.	explicitStepSizeDefined = true;	.)
	[	"-"																				(.	negativeStepSize = true;	.)
	] 
Number<customStepSize, true>															(.	if (customStepSize.has_value() && !customStepSize.value()->evaluate({})) {
																								// TODO: GEN_ERROR step size cannot be zero ?
																							}
																						.)		
]																						(.	if (!explicitStepSizeDefined) {
																								customStepSize.emplace(std::make_shared<syrec::Number>(syrec::Number(1)));
																							}

																							bool validLoopHeader = loopVariableIdent.has_value() 
																															&& (explicitRangeStartDefined ? iterationRangeStart.has_value() : true)
																															&& iterationRangeEnd.has_value()
																															&& (explicitStepSizeDefined ? customStepSize.has_value() : true);
																							if (validLoopHeader) {
																								const unsigned int iterationRangeStartValue = iterationRangeStart.value()->evaluate({});
																								const unsigned int iterationRangeEndValue = iterationRangeEnd.value()->evaluate({});
																								const unsigned int stepSize = customStepSize.value()->evaluate({});

																								unsigned int numIterations;
																								if ((negativeStepSize && iterationRangeEndValue > iterationRangeStartValue)
																									|| (!negativeStepSize && iterationRangeStartValue > iterationRangeEndValue)
																									|| !stepSize) {
																									// TODO: Either generate error or warning
																									numIterations = 0;	
																									validLoopHeader = false;
																								}
																								else {
																									numIterations = negativeStepSize 
																										? (iterationRangeStartValue - iterationRangeEndValue)
																										: (iterationRangeEndValue - iterationRangeStartValue);
																									numIterations = (numIterations + 1) / stepSize;
																								}
																							}
																						.)
"do" 
StatementList<loopBody>																	(.	if (loopBody.empty()) {
																								// TODO: GEN_ERROR
																							}
																						.)
"rof"																					(.	if (loopVariableIdent.has_value()) {
																								SymbolTable::closeScope(currSymTabScope);
																							}

																							// TODO: If a statement must be generated, one could create a skip statement instead of simply returning 
																							if (!validLoopHeader || loopBody.empty()) {
																								return;
																							}

																							const std::shared_ptr<syrec::ForStatement> loopStatement = std::make_shared<syrec::ForStatement>();
																							loopStatement->loopVariable = loopVariableIdent.value();
																							loopStatement->range = std::pair(iterationRangeStart.value(), iterationRangeEnd.value());
																							loopStatement->step = customStepSize.value();
																							loopStatement->statements = loopBody;
																							statement.emplace(loopStatement);
																						.)
.

/*-------------------------------------------------------------------------
IfStatement production
-------------------------------------------------------------------------*/

IfStatement<. std::optional<syrec::Statement::ptr> &statement .>		(.	const ExpressionEvaluationResult::ptr condition = createExpressionEvalutionResultContainer();
																	const ExpressionEvaluationResult::ptr closingCondition = createExpressionEvalutionResultContainer();
																	syrec::Statement::vec trueBranch{};
																	syrec::Statement::vec falseBranch{};
																.)	
=
"if" Expression<condition, 1u, false> 
"then" 
StatementList<trueBranch> 
"else" StatementList<falseBranch>
"fi" Expression<closingCondition, 1u, false>					(.	// TODO: Add check that condition and closing_condition match, closingCondition should use same bitwidth as condition
																	const bool conditionalWellFormed = condition->hasValue() 
																		&& closingCondition->hasValue()
																		&& !trueBranch.empty()
																		&& !falseBranch.empty();
																	if (!conditionalWellFormed) {
																		return;
																	}
															
																	const std::shared_ptr<syrec::IfStatement> &conditional = std::make_shared<syrec::IfStatement>();
																	conditional->condition = condition->getOrConvertToExpression(1u).value();
																	conditional->fiCondition = closingCondition->getOrConvertToExpression(1u).value();
																	conditional->thenStatements                    = trueBranch;
																	conditional->elseStatements                    = falseBranch;
																	statement.emplace(conditional);
																.)
.

/*-------------------------------------------------------------------------
UnaryStatement production
-------------------------------------------------------------------------*/

UnaryStatement<. std::optional<syrec::Statement::ptr> &statement .>			(.	SignalEvaluationResult unaryStmtOperand;
																			std::optional<syrec_operation::operation> unaryOperation;	
																		.)
=
(
	"~"																	(.	unaryOperation.emplace(syrec_operation::operation::negate_assign);	.)
	| "++"																(.	unaryOperation.emplace(syrec_operation::operation::increment_assign);	.)
	| "--"																(.	unaryOperation.emplace(syrec_operation::operation::decrement_assign);	.)
) 
"=" Signal<unaryStmtOperand, false>										(.	bool allSemanticChecksOk = true;
																			if (!unaryOperation.has_value()){
																				allSemanticChecksOk = false;
																				// TODO: GEN_ERROR Expected a valid unary operand
																			}
																			if (unaryStmtOperand.isValid() && !unaryStmtOperand.isVariableAccess()) {
																				allSemanticChecksOk = false;
																				// TODO: GEN_ERROR Operand can only be variable access
																			}

																			const std::optional<unsigned int> mappedOperation = map_operation_to_unary_operation(unaryOperation.value());
																			allSemanticChecksOk &= mappedOperation.has_value();
																			if (!allSemanticChecksOk) {
																				return;
																			}

																			const syrec::VariableAccess::ptr unaryOperandAsVarAccess = unaryStmtOperand.getAsVariableAccess().value();
																			statement.emplace(std::make_shared<syrec::UnaryStatement>(syrec::UnaryStatement(mappedOperation.value(), unaryOperandAsVarAccess)));
																		.)
.


/*-------------------------------------------------------------------------
AssignStatement production
-------------------------------------------------------------------------*/

AssignStatement<. std::optional<syrec::Statement::ptr> &statement .>	(.		SignalEvaluationResult assignStmtLhs;
																		const ExpressionEvaluationResult::ptr assignStmtRhs = createExpressionEvalutionResultContainer();
																		std::optional<syrec_operation::operation> assignOperation;
																		unsigned int expressionBitwidth = 1u;

																		std::optional<syrec::VariableAccess::ptr> assigned_to_obj;
																		bool allSemanticChecksOk = true;
																.)
=
Signal<assignStmtLhs, false>									(.		allSemanticChecksOk = assignStmtLhs.isValid();
																		if (allSemanticChecksOk){
																			if (!assignStmtLhs.isVariableAccess()) {
																				allSemanticChecksOk = false;
																				// TODO: GEN_ERROR: Lhs operand must be variable access
																			}
																			else {
																				expressionBitwidth = assignStmtLhs.getAsVariableAccess().value()->bitwidth();
																			}
																		}
																.)
(
	"^"															(.		assignOperation.emplace(syrec_operation::operation::xor_assign);	.)
	| "+"														(.		assignOperation.emplace(syrec_operation::operation::add_assign);	.)
	| "-"														(.		assignOperation.emplace(syrec_operation::operation::minus_assign);	.)
)					
"=" Expression<assignStmtRhs, expressionBitwidth, false>		(.		if (!allSemanticChecksOk || !assignOperation.has_value() || !assignStmtRhs->hasValue()) {
																			return;
																		}

																		// TODO: To not break reversability of operation, check that expression does not contain the assigned to signal 
																		const std::optional<unsigned int> mappedOperation = map_operation_to_assign_operation(assignOperation.value());
																		if (mappedOperation.has_value()) {
																			statement.emplace(std::make_shared<syrec::AssignStatement>(syrec::AssignStatement(assignStmtLhs.getAsVariableAccess().value(),
																																				mappedOperation.value(),
																																				assignStmtRhs->getOrConvertToExpression(expressionBitwidth).value())));
																		}
																.)		
.

/*-------------------------------------------------------------------------
SwapStatement production
-------------------------------------------------------------------------*/

SwapStatement<. std::optional<syrec::Statement::ptr> &statement .>			(.	SignalEvaluationResult swapMe, swapOther;
																		bool isSwapOperatorDefined = false;
																	.)
=
Signal<swapMe, false> 
"<=>"																(.	isSwapOperatorDefined = true;	.)
Signal<swapOther, false>											(.	bool allSemanticChecksOk = true;
																		if (swapMe.isValid() && !swapMe.isVariableAccess()) {
																			allSemanticChecksOk = false;
																			// TODO: GEN_ERROR: Lhs operand must be variable access
																		}
																		if (swapOther.isValid() && !swapOther.isVariableAccess()){
																			allSemanticChecksOk = false;
																			// TODO: GEN_ERROR: Lhs operand must be variable access
																		}

																		if (isSwapOperatorDefined && allSemanticChecksOk) {
																			statement.emplace(std::make_shared<syrec::SwapStatement>(syrec::SwapStatement(swapMe.getAsVariableAccess().value(),
																																						 swapOther.getAsVariableAccess().value())));
																		}
																	.)
.


/*-------------------------------------------------------------------------
SkipStatement production
-------------------------------------------------------------------------*/

SkipStatement<. std::optional<syrec::Statement::ptr> &statement .>
=
"skip"															(.	statement.emplace(std::make_shared<syrec::SkipStatement>(syrec::SkipStatement()));	.)
.


/*-------------------------------------------------------------------------
Signal production
-------------------------------------------------------------------------*/

Signal<SignalEvaluationResult &signalAccess, const bool simplifyIfPossible>			(.	std::optional<syrec::VariableAccess::ptr> accessedSignal;
																						const unsigned int defaultIndexExpressionBitwidth = 1u;
																						unsigned int indexExpressionBitwidth = defaultIndexExpressionBitwidth;

																						// TODO: Using global zero_based indexing flag to initialize default value
																						std::size_t accessedDimensionIdx = 0;
																					.)
=
	ident																			(.	const std::string signalIdent = convert_to_uniform_text_format(t->val);
																						if (checkIdentWasDeclaredOrLogError(signalIdent)) {
																							const auto symbolTableEntryForSignal = currSymTabScope->getVariable(signalIdent);
																							if (symbolTableEntryForSignal.has_value() && std::holds_alternative<syrec::Variable::ptr>(symbolTableEntryForSignal.value())) {
																								const syrec::VariableAccess::ptr container = std::make_shared<syrec::VariableAccess>(syrec::VariableAccess());
																								container->setVar(std::get<syrec::Variable::ptr>(symbolTableEntryForSignal.value()));
																								accessedSignal.emplace(container);
																								indexExpressionBitwidth = accessedSignal.value()->bitwidth();
																							}
																						}
																						bool isValidSignalAccess = accessedSignal.has_value();
																						bool indexExpressionsSemanticallyOk = isValidSignalAccess;
																					.)
{"["																				(.	ExpressionEvaluationResult::ptr dimensionExpression = createExpressionEvalutionResultContainer(); .)
	Expression<dimensionExpression, indexExpressionBitwidth, simplifyIfPossible>	(.	indexExpressionsSemanticallyOk &= dimensionExpression->hasValue();
																			
																						if (indexExpressionsSemanticallyOk) {
																							const std::optional<unsigned int> &constantValueForAccessedDimension = dimensionExpression->getAsConstant();
																							if (constantValueForAccessedDimension.has_value()) {
																								// TODO: Using global flag indicating zero_based indexing or not
																								indexExpressionsSemanticallyOk = isValidDimensionAccess(accessedSignal.value()->getVar(), constantValueForAccessedDimension.value(), true);

																								if (!indexExpressionsSemanticallyOk) {
																									// TODO: Using global flag indicating zero_based indexing or not
																									const IndexAccessRangeConstraint constraintForCurrentDimension = getConstraintsForValidDimensionAccess(accessedSignal.value()->getVar(), accessedDimensionIdx, true).value();
																									// TODO: GEN_ERROR
																								}
																							}

																							if (indexExpressionsSemanticallyOk) {
																								accessedSignal.value()->indexes.emplace_back(dimensionExpression->getOrConvertToExpression(indexExpressionBitwidth).value());
																							}
																						}
																						accessedDimensionIdx++;
																					.)
"]"		
}																					(.	isValidSignalAccess = indexExpressionsSemanticallyOk;	.)
[																					(.	std::optional<syrec::Number::ptr> bitRangeStart;
																						std::optional<syrec::Number::ptr> bitRangeEnd;
																						bool rangeExplicitlyDefined = false;
																					.)
	"." Number<bitRangeStart, false>									
	[
		":" Number<bitRangeEnd, false>												(.	rangeExplicitlyDefined = true;	.)
	]																				(.	isValidSignalAccess &= bitRangeStart.has_value() && (rangeExplicitlyDefined ? bitRangeEnd.has_value() : true);
																						if (isValidSignalAccess) {
																							const std::pair<syrec::Number::ptr, syrec::Number::ptr> bitRange(bitRangeStart.value(), rangeExplicitlyDefined ? bitRangeEnd.value() : bitRangeStart.value());
																							const std::pair<std::size_t, std::size_t> bitRangeEvaluated(bitRange.first->evaluate({}), bitRange.second->evaluate({}));
																						
																							const syrec::Variable::ptr &accessedVariable = accessedSignal.value()->getVar();
																							if (rangeExplicitlyDefined) {
																								// TODO: Using global zero_based indexing flag
																								if (!isValidBitRangeAccess(accessedVariable, bitRangeEvaluated, true)){
																									isValidSignalAccess = false;
																									// TODO: GEN_ERROR
																								}
																							}
																							else {
																								// TODO: Using global zero_based indexing flag	
																								if (!isValidBitAccess(accessedVariable, bitRangeEvaluated.first, true)){
																									isValidSignalAccess = false;
																									// TODO: GEN_ERROR
																								}
																							}

																							if (isValidSignalAccess) {
																								accessedSignal.value()->range.emplace(bitRange);
																							}
																						}
																					.)
	]																				(.	if (isValidSignalAccess) {
																							signalAccess.updateResultToVariableAccess(accessedSignal.value());
																						}
																					.)
.

/*-------------------------------------------------------------------------
Expressions variants
-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
Expression production
-------------------------------------------------------------------------*/

// TODO: Add flag to indicate whether the given bitwidth should be forced on the expression or the larger of the two should be choosen
Expression<const ExpressionEvaluationResult::ptr &userDefinedExpression, const unsigned int bitwidth, const bool simplifyIfPossible>	(.	SignalEvaluationResult signal;
																																			std::optional<syrec::Number::ptr> number;
																																		.)
=
(
	IF (shouldTakeNumberInsteadOfBinaryAlternative(this)) Number<number, simplifyIfPossible>									(.	if (number.has_value()) {
																																				const syrec::NumericExpression::ptr expr = std::make_shared<syrec::NumericExpression>(syrec::NumericExpression(number.value(), bitwidth));
																																				userDefinedExpression->setResult(expr);
																																			}
																																		.)
	| IF (shouldTakeBinaryInsteadOfShiftAlternative(this)) BinaryExpression<userDefinedExpression, bitwidth, simplifyIfPossible>
	| ShiftExpression<userDefinedExpression, bitwidth, simplifyIfPossible>
)
	| Signal<signal, simplifyIfPossible>																								(.	if (!signal.isValid()) {
																																				return;
																																			}

																																			if (signal.isVariableAccess()) {
																																				userDefinedExpression->setResult(std::make_shared<syrec::VariableExpression>(syrec::VariableExpression(signal.getAsVariableAccess().value())));
																																			}
																																			else if (signal.isConstant()) {
																																				userDefinedExpression->setResult(std::make_shared<syrec::NumericExpression>(syrec::NumericExpression(signal.getAsNumber().value(), bitwidth)));
																																			}
																																		.)
	| UnaryExpression<userDefinedExpression, bitwidth, simplifyIfPossible>
.

/*-------------------------------------------------------------------------
BinaryExpression production
-------------------------------------------------------------------------*/

BinaryExpression<const ExpressionEvaluationResult::ptr &parsedBinaryExpression, const unsigned int bitwidth, const bool simplifyIfPossible>	(.	ExpressionEvaluationResult::ptr binaryExprLhs = createExpressionEvalutionResultContainer();
																																				ExpressionEvaluationResult::ptr binaryExprRhs = createExpressionEvalutionResultContainer();
																																				std::optional<syrec_operation::operation> binaryOperation;
																																				unsigned int expectedBitWidth = bitwidth;
																																			.)	
=
"(" Expression<binaryExprLhs, bitwidth, simplifyIfPossible>																					(.	if (binaryExprLhs->hasValue()) {
																																					expectedBitWidth = std::max(binaryExprLhs->getOrConvertToExpression(std::nullopt).value()->bitwidth(), expectedBitWidth);
																																				}
																																			.)
	(
		"+"																																	(.	binaryOperation.emplace(syrec_operation::operation::addition);	.)
		| "-"																																(.	binaryOperation.emplace(syrec_operation::operation::subtraction);	.)
		| "^"																																(.	binaryOperation.emplace(syrec_operation::operation::bitwise_xor);	.)
		| "*"																																(.	binaryOperation.emplace(syrec_operation::operation::multiplication);	.)
		| "/"																																(.	binaryOperation.emplace(syrec_operation::operation::division);	.)
		| "%"																																(.	binaryOperation.emplace(syrec_operation::operation::modulo);	.)
		| "*>"																																(.	binaryOperation.emplace(syrec_operation::operation::upper_bits_multiplication);	.)
		| "&&"																																(.	binaryOperation.emplace(syrec_operation::operation::logical_and);	.)
		| "||"																																(.	binaryOperation.emplace(syrec_operation::operation::logical_or);	.)
		| "&"																																(.	binaryOperation.emplace(syrec_operation::operation::bitwise_and);	.)
		| "|"																																(.	binaryOperation.emplace(syrec_operation::operation::bitwise_or);	.)
		| "<"																																(.	binaryOperation.emplace(syrec_operation::operation::less_than);	.)
		| ">"																																(.	binaryOperation.emplace(syrec_operation::operation::greater_than);	.)
		| "="																																(.	binaryOperation.emplace(syrec_operation::operation::equals);	.)
		| "!="																																(.	binaryOperation.emplace(syrec_operation::operation::not_equals);	.)
		| "<="																																(.	binaryOperation.emplace(syrec_operation::operation::less_equals);	.)
		| ">="																																(.	binaryOperation.emplace(syrec_operation::operation::greater_equals);	.)
	)																																		(.	if (!binaryOperation.has_value()) {
																																					// TODO: GEN_ERROR Expected one of n possible operands but non was specified
																																				}
																																			.)
	Expression<binaryExprRhs, expectedBitWidth, simplifyIfPossible>																
")"																																			(.	if (binaryExprLhs->hasValue() && binaryOperation.has_value() && binaryExprRhs->hasValue()) {
																																				const std::optional<unsigned int> mappedOperation = map_operation_to_binary_operation(binaryOperation.value());
																																				if (!mappedOperation.has_value()) {
																																					return;
																																				}

																																				if (binaryExprLhs->evaluatedToConstant() && binaryExprRhs->evaluatedToConstant()) {
																																					const unsigned int lhsValueEvaluated = binaryExprLhs->getAsConstant().value();
																																					const unsigned int rhsValueEvaluated = binaryExprRhs->getAsConstant().value();
																																					const std::optional<unsigned int> operationApplicationResult = applyBinaryOperation(binaryOperation.value(), lhsValueEvaluated, rhsValueEvaluated);
																																					if (operationApplicationResult.has_value()) {
																																						parsedBinaryExpression->setResult(operationApplicationResult.value(), expectedBitWidth);
																																					}
																																				}
																																				else {
																																					const syrec::expression::ptr lhsOperand = binaryExprLhs->getOrConvertToExpression(std::nullopt).value();
																																					const syrec::expression::ptr rhsOperand = binaryExprRhs->getOrConvertToExpression(std::nullopt).value();
																																					parsedBinaryExpression->setResult(std::make_shared<syrec::BinaryExpression>(syrec::BinaryExpression(lhsOperand, 
																																																												 mappedOperation.value(),
																																																												 rhsOperand)));
																																				}
																																			}
																																		.)
.


/*-------------------------------------------------------------------------
UnaryExpression production
-------------------------------------------------------------------------*/

UnaryExpression<const ExpressionEvaluationResult::ptr &unaryExpression, const unsigned int bitwidth, const bool simplifyIfPossible>	(.	ExpressionEvaluationResult::ptr unaryExpressionOperand = createExpressionEvalutionResultContainer();
																																		std::optional<syrec_operation::operation> unaryOperation;
																																	.)	
=
(
	"!"																																(.	unaryOperation.emplace(syrec_operation::operation::logical_negation);	.)
	| "~"																															(.	unaryOperation.emplace(syrec_operation::operation::bitwise_negation);	.)
)		
Expression<unaryExpressionOperand, bitwidth, simplifyIfPossible>																	(.	// TODO: Notify user (i.e. via error) that reference parser currently does not support unary statements - we will ignore them for now
																																		return;
																																	.)	
.


/*-------------------------------------------------------------------------
ShiftExpression production
-------------------------------------------------------------------------*/

ShiftExpression<const ExpressionEvaluationResult::ptr &userDefinedShiftExpression, const unsigned int bitwidth, const bool simplifyIfPossible>	(.	ExpressionEvaluationResult::ptr shiftExpressionLhs = createExpressionEvalutionResultContainer();
																																					std::optional<syrec::Number::ptr> shiftAmount;
																																					std::optional<syrec_operation::operation> shiftOperation;
																																				.)
=
"(" Expression<shiftExpressionLhs, bitwidth, simplifyIfPossible> 
(
	"<<"																																		(.	shiftOperation.emplace(syrec_operation::operation::shift_left);	.)
	| ">>"																																		(.	shiftOperation.emplace(syrec_operation::operation::shift_right);	.)
) Number<shiftAmount, simplifyIfPossible>																										(.	if (!shiftExpressionLhs->hasValue() || !shiftOperation.has_value() || !shiftAmount.has_value()) {
																																						return;
																																					}
																																					const std::optional<unsigned int> mappedShiftOperation = map_operation_to_shift_operation(shiftOperation.value());
																																					const syrec::expression::ptr lhsOperandExpression = shiftExpressionLhs->getOrConvertToExpression(bitwidth).value();
																																		
																																					// One could replace the shift statement with a skip statement if the shift amount is zero 
																																					const std::optional<unsigned int> shiftAmountValueEvaluated = evaluateNumberContainer(shiftAmount.value());
																																					const std::optional<unsigned int> lhsOperandValueEvaluated = shiftExpressionLhs->getAsConstant();

																																					if (shiftAmountValueEvaluated.has_value() && lhsOperandValueEvaluated.has_value()) {
																																						const std::optional<unsigned int> shiftApplicationResult = syrec_operation::apply(shiftOperation.value(), lhsOperandValueEvaluated.value(), shiftAmountValueEvaluated.value());
																																						if (shiftApplicationResult.has_value()) {
																																							userDefinedShiftExpression->setResult(shiftApplicationResult.value(), bitwidth);
																																						}
																																						else {
																																							// TODO: GEN_ERROR
																																							return;
																																						}
																																					}
																																					else {
																																						userDefinedShiftExpression->setResult(std::make_shared<syrec::ShiftExpression>(lhsOperandExpression,
																																																									mappedShiftOperation.value(),
																																																									shiftAmount.value()));
																																					}
																																				.)
")"
.

END SyReC.