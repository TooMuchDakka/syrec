/*-------------------------------------------------------------------------
ATG for SyReC: A Programming Language for Synthesis of Reversible Circuits
(specification available @ http://www.revlib.org/doc/docu/revlib_2_0_1.pdf)

User manual for Coco/R is available @
https://ssw.jku.at/Research/Projects/Coco/Doc/UserManual.pdf
-------------------------------------------------------------------------*/
$namespace=syrec
/*-- $checkEOF=false --*/

// Place includes here
#include <cwchar>
#include <optional>
#include <set>
#include <stdexcept>
#include <string>
#include <variant>
#include <vector>

#include "core/syrec/module.hpp"
#include "core/syrec/parser/operation.hpp"
#include "core/syrec/parser/parser_error_message_generator.hpp"
#include "core/syrec/parser/range_check.hpp"
#include "core/syrec/parser/symbol_table.hpp"
#include "core/syrec/parser/text_utils.hpp"

COMPILER SyReC

	struct expression_or_constant {
		public:
			expression_or_constant(const unsigned int constant_value) : variants(constant_value)
			{
			}

			expression_or_constant(const expression::ptr &expression) : variants(expression) 
			{
			}
				
			[[nodiscard]] bool is_constant() const {
				return std::holds_alternative<unsigned int>(variants);
			}

			[[nodiscard]] unsigned int get_constant_value() const {
				return std::get<unsigned int>(variants);
			}

			[[nodiscard]] expression::ptr get_expression() const {
				return std::get<expression::ptr>(variants);
			}

			[[nodiscard]] expression::ptr convert_to_expression() const {
				if (is_constant()) {
					const number::ptr &constant_value_wrapper = std::make_shared<number>(get_constant_value());
					// TODO: Fix calculation of bitwidth for constant value
					const expression::ptr expression_for_constant = std::make_shared<numeric_expression>(constant_value_wrapper, 0);
					return expression_for_constant;
				}
				else {
					return get_expression();	
				}
			}
			
		private:
			std::variant<expression::ptr, unsigned int> variants;
	};

	typedef std::optional<std::variant<variable_access::ptr, number::ptr>> signal_evaluation_result;
	typedef std::optional<expression_or_constant> expression_evaluation_result;

	// Place declarations of objects referenced in this ATG
	module::vec modules;
	parser_error_message_generator error_message_generator;
	symbol_table::ptr current_symbol_table_scope;

	// This method will be called by the contructor if it exits.
	// This support is specific to the C++ version of Coco/R.
	void Init() {
		// nothing to do
		symbol_table::open_scope(current_symbol_table_scope);
	}

	// Uncomment this method if cleanup is necessary,
	// this method will be called by the destructor if it exists.
	// This support is specific to the C++ version of Coco/R.
	// void Destroy() {
		// nothing to do
	// }

	[[nodiscard]] bool are_token_values_equal(const wchar_t *my_token_value, const wchar_t *other_token_value) const {
		if (my_token_value == nullptr || other_token_value == nullptr) {
			// TODO: Could also throw exception
			return false;
		}
		return !wcscmp(my_token_value, other_token_value);
	}

	[[nodiscard]] bool token_matches_one_of(const Token *tokenToCheck, std::vector<std::wstring> one_of_many_token_values) const {
        const std::set<std::wstring> set_of_matching_token_values{std::begin(one_of_many_token_values), std::end(one_of_many_token_values)};
        return set_of_matching_token_values.count(tokenToCheck->val);
	}

	[[nodiscard]] bool find_matching_token(std::vector<std::wstring> matching_token_values, std::vector<std::wstring> token_values_allowing_stop_of_search) const {
		const std::set<std::wstring> set_of_matching_token_values { std::begin(matching_token_values), std::end(matching_token_values) };
		const std::set<std::wstring> set_of_token_values_allowing_stop_of_search { std::begin(token_values_allowing_stop_of_search), std::end(token_values_allowing_stop_of_search) };
		bool found_matching_operator = false;
		bool can_cancel_search = false;

		while (!can_cancel_search) {
			const Token *peeked_token = scanner->Peek();
			found_matching_operator = set_of_matching_token_values.count(peeked_token->val);
			can_cancel_search = found_matching_operator || peeked_token->kind == _EOF || set_of_token_values_allowing_stop_of_search.count(peeked_token->val);
		}
		return found_matching_operator;
	}

	[[nodiscard]] bool check_if_is_assign_statement() const {
		const std::vector<std::wstring> matching_tokens = {L"^", L"+", L"-"};
		const std::vector<std::wstring> tokens_resulting_in_check_being_false = {L";", L"<=>"};

		return find_matching_token(matching_tokens, tokens_resulting_in_check_being_false);
	}

	[[nodiscard]] bool check_if_expression_is_binary_expression() const {
		// Since first LL(1) conflict resolver already started peeking and failed to resolve the conflict, we need to reset the peek position to original one
		scanner->ResetPeek();

		const std::set<std::wstring> tokens_resulting_in_check_being_false {L"+", L"-", L"^", L"*", L"/", L"%", L"*>", L"&&", L"||", L"&", L"|", L"<", L">", L"=", L"!=", L"<=", L">="};
		const std::set<std::wstring> set_of_operator_token_values_of_alternative {L"<<", L">>"};

		bool found_matching_operator = false;
		bool can_cancel_search = false;
		int expression_nesting_level = 0;

		while (!can_cancel_search) {
			const Token *peeked_token = scanner->Peek();

			if (are_token_values_equal(peeked_token->val, L"(")) {
				expression_nesting_level++;
			} 
			else if (are_token_values_equal(peeked_token->val, L")")) {
				expression_nesting_level--;
			}
			else {
				found_matching_operator = expression_nesting_level == 0 && tokens_resulting_in_check_being_false.count(peeked_token->val);
				can_cancel_search = found_matching_operator || set_of_operator_token_values_of_alternative.count(peeked_token->val) || peeked_token->kind == _EOF;			
			}

		}
		return found_matching_operator;
	}

	[[nodiscard]] bool is_token_not_nested_number(const Token *token) const {
		if (token == nullptr) {
			return false;
		}
		return token->kind == _int || are_token_values_equal(token->val, L"#") || are_token_values_equal(token->val, L"$");
	}
		
	[[nodiscard]] bool check_if_expression_is_number(const Token *first_token_of_expression) const {
        bool found_matching_operator;
        const std::vector<std::wstring> matching_tokens = {L"^", L"+", L"-", L"*"};

        if (are_token_values_equal(first_token_of_expression->val, L"(")) {
            found_matching_operator = check_if_expression_is_number(scanner->Peek())
                && token_matches_one_of(scanner->Peek(), matching_tokens)
                && check_if_expression_is_number(scanner->Peek())
                && are_token_values_equal(scanner->Peek()->val, L")");
        } else {
            found_matching_operator = is_token_not_nested_number(first_token_of_expression);
        }
        return found_matching_operator;
	}

	[[nodiscard]] bool check_if_expression_is_number() const {
        return la != nullptr && check_if_expression_is_number(la);
	}

	[[nodiscard]] bool check_if_loop_variable_is_defined() const {
		// Since first LL(1) conflict resolver already started peeking and failed to resolve the conflict, we need to reset the peek position to original one
		scanner->ResetPeek();
		const std::vector<std::wstring> matching_tokens = {L"="};
		const std::vector<std::wstring> tokens_resulting_in_check_being_false = {L"rof"};

		return find_matching_token(matching_tokens, tokens_resulting_in_check_being_false);
	}

	[[nodiscard]] bool check_if_loop_iteration_range_start_is_defined() const {
		const std::vector<std::wstring> matching_tokens = {L"to"};
		const std::vector<std::wstring> tokens_resulting_in_check_being_false = {L"rof"};

		return find_matching_token(matching_tokens, tokens_resulting_in_check_being_false);
	}

	[[nodiscard]] std::optional<unsigned int> convert_token_value_to_number(const Token &token) {
		std::optional<unsigned int> token_as_number;
		try {
			token_as_number.emplace(std::stoul(convert_to_uniform_text_format(token.val)));
		} 
		catch (std::invalid_argument const &ex) {
			// TODO: GEN_ERROR
		}
		catch (std::out_of_range const &ex) {
			// TODO: GEN_ERROR
		}
		return token_as_number;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_assign_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::add_assign:
				mapping_result.emplace(assign_statement::add);
				break;
			case syrec_operation::operation::minus_assign:
				mapping_result.emplace(assign_statement::subtract);
				break;
			case syrec_operation::operation::xor_assign:
				mapping_result.emplace(assign_statement::exor);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_unary_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::increment_assign:
				mapping_result.emplace(unary_statement::increment);
				break;
			case syrec_operation::operation::decrement_assign:
				mapping_result.emplace(unary_statement::decrement);
				break;
			case syrec_operation::operation::negate_assign:
				mapping_result.emplace(unary_statement::invert);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	bool check_ident_was_declared(const std::string &ident) const {
		if (!current_symbol_table_scope->contains(ident)) {
			// TOOD: GEN_ERROR
			return false;
		}
		return true;
	}

	[[nodiscard]] static std::optional<unsigned int> get_value_if_expression_is_constant(const expression_evaluation_result &expression){
		std::optional<unsigned int> constant_value;
		if (expression.has_value() && expression.value().is_constant()) {
			constant_value.emplace(expression.value().get_constant_value());
		}
		return constant_value;
	}

	// TODO: Generate error/s in case of exceptions
	[[nodiscard]] static std::optional<unsigned int> apply_unary_operation(const syrec_operation::operation operation, const number::ptr &left_operand) {
		std::optional<unsigned int> operation_result;
		try {
			operation_result.emplace(syrec_operation::apply(operation, left_operand->evaluate({})));
		}
		catch (std::overflow_error &err) {
		
		}
		catch(std::invalid_argument &err) {
		
		}
        return operation_result;
	}

	// TODO: Generate error/s in case of exceptions
	[[nodiscard]] static std::optional<unsigned int> apply_binary_operation(const syrec_operation::operation operation, const number::ptr &left_operand, const number::ptr &right_operand) {
		std::optional<unsigned int> operation_result;
		try {
			operation_result.emplace(syrec_operation::apply(operation, left_operand->evaluate({}), right_operand->evaluate({})));
		}
		catch (std::overflow_error &err) {
		
		}
		catch(std::invalid_argument &err) {
		
		}
        return operation_result;
	}

/*-------------------------------------------------------------------------*/

CHARACTERS
	letter		= 'A' .. 'Z' + 'a' .. 'z'.
	digit		= '0' .. '9'.

	cr        = '\r'.
	lf        = '\n'.
	tab       = '\t'.

TOKENS
	ident		= ('_' | letter) {('_' | letter | digit)}.
	int			= digit {digit}.
	
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/
PRODUCTIONS


/*-------------------------------------------------------------------------
Number production

Since Coco/R does not accept recursive token definitions, 
we redefine the token 'number as a non-terminal symbol
-------------------------------------------------------------------------*/
Number<. std::optional<number::ptr> &parsed_number, bool simplify_if_possible .>									
=
int																			(.	const std::optional<unsigned int> conversion_result = convert_token_value_to_number(*t);
																				if (conversion_result.has_value()) {
																					const number::ptr result = std::make_shared<number>(number(conversion_result.value())); 
																					parsed_number.emplace(result);
																				}
																				else {
																					// TODO: GEN_ERROR
																				}
																			.)
| '#' ident 
| '$' ident 
| (																			(.	std::optional<number::ptr> lhs_operand, rhs_operand;  
																				std::optional<syrec_operation::operation> op;
																			.)
	'(' 
		Number<lhs_operand, simplify_if_possible>
		('+'																(.	op.emplace(syrec_operation::operation::addition);		.)
		|'-'																(.	op.emplace(syrec_operation::operation::subtraction);	.)
		|'*'																(.	op.emplace(syrec_operation::operation::multiplication);	.)
		|'/'																(.	op.emplace(syrec_operation::operation::division);		.)
		) 
		Number<rhs_operand, simplify_if_possible>							(.	if (op.has_value() && lhs_operand.has_value() && rhs_operand.has_value()){
																					const std::optional<unsigned int> op_result = apply_binary_operation(op.value(), lhs_operand.value(), rhs_operand.value());
																					if (op_result.has_value()) {
																						const number::ptr result = std::make_shared<number>(number(op_result.value())); 
																						parsed_number.emplace(result);
																					}
																				}
																			.)
	')'																	
)
.

/*-------------------------------------------------------------------------
Program and Modules
-------------------------------------------------------------------------*/

SyReC										(.	std::optional<module::ptr> module;	.)
=
Module<module>								(.	if (module.has_value()) {
													current_symbol_table_scope->add_entry(module.value());
												}
											.)
{											(.	module.reset();	.)
	Module<module>							(.	if (module.has_value()) {
													const module::ptr well_formed_module = module.value();
													if (current_symbol_table_scope->contains(well_formed_module)) {
														// TODO: GEN_ERROR 
														// TODO: Do not cancel parsing	
													}
													else {
														current_symbol_table_scope->add_entry(well_formed_module);
													}
												}
											.)
}
.

/*-------------------------------------------------------------------------
Module production
-------------------------------------------------------------------------*/

Module <. std::optional<module::ptr> &parsed_module	.>			(.	symbol_table::open_scope(current_symbol_table_scope);
																	std::optional<std::vector<variable::ptr>> locals;	
																	bool valid_module_definition = false;
																	statement::vec module_body {};
																.)	
=
"module" ident													(.	const std::string module_name = convert_to_uniform_text_format(t->val);	
																	module::ptr user_defined_module = std::make_shared<module>(module(module_name));
																.)	
"(" [ParameterList<valid_module_definition, user_defined_module>] ")" 
{
	SignalList<locals>											(.	valid_module_definition &= locals.has_value();	.)
}														
StatementList<module_body>										(.	symbol_table::close_scope(current_symbol_table_scope);
																	if (module_body.empty()) {
																		valid_module_definition = false;
																		// TODO: GEN_ERROR
																	}

																	if (valid_module_definition) {
																		user_defined_module->variables = locals.value_or(std::vector<variable::ptr>{});
																		for (const auto &statement : module_body) {
																			user_defined_module->add_statement(statement);
																		}
																		parsed_module.emplace(user_defined_module);
																	}
																.)
.


/*-------------------------------------------------------------------------
ParameterList production
-------------------------------------------------------------------------*/

ParameterList<bool &is_valid_module_definition, const module::ptr &module>			(.	std::optional<variable::ptr> parameter;	.)
=
Parameter<parameter>																(.	is_valid_module_definition = parameter.has_value();
																						if (is_valid_module_definition) {
																							module->add_parameter(parameter.value());
																							current_symbol_table_scope->add_entry(parameter.value());
																						}
																					.)
{																					(.	parameter.reset();	.)
	"," Parameter<parameter>														(.	is_valid_module_definition = parameter.has_value();
																						const variable::ptr well_formed_parameter = parameter.value();
																						if (is_valid_module_definition && !current_symbol_table_scope->contains(well_formed_parameter->name)) {
																							module->add_parameter(well_formed_parameter);
																							current_symbol_table_scope->add_entry(well_formed_parameter);
																						}
																						else {
																							// TODO: GEN_ERROR 
																						}
																					.)
}															
.


/*-------------------------------------------------------------------------
Parameter production
-------------------------------------------------------------------------*/

Parameter<. std::optional<variable::ptr> &parameter .>								(.	variable::types parameter_type = variable::wire;
																						bool valid_variable_type = true;
																					.)	
= 
(
	"in"																			(.	parameter_type = variable::in;	.)
	| "out"																			(.	parameter_type = variable::out;	.)
	| "inout"																		(.	parameter_type = variable::inout;	.)	
)																					(.	if (variable::wire == parameter_type) {
																							// TODO: GEN_ERROR 
																							// TODO: Do not cancel parsing
																							valid_variable_type = false;
																						}
																					.)
SignalDeclaration<parameter_type, parameter>										(.	if (!valid_variable_type) {
																							parameter.reset();
																						}
																					.)
.

/*-------------------------------------------------------------------------
SignalList production
-------------------------------------------------------------------------*/

SignalList <. std::optional<std::vector<variable::ptr>> &signals .>	(.	variable::types signal_type = variable::in;
																		std::optional<variable::ptr> declared_signal;
																		bool valid_signal_type = true;
																		std::vector<variable::ptr> valid_signal_declarations;
																	.)
=
(
	"wire"															(.	signal_type = variable::wire;		.)
	| "signal"														(.	signal_type = variable::state;		.)
)																	(.	if (variable::wire != signal_type && variable::state != signal_type) {
																			// TODO: GEN_ERROR ?
																			// TODO: Do not cancel parsing
																			valid_signal_type = false;
																		}
																	.)
SignalDeclaration<signal_type, declared_signal>						(.	if (valid_signal_type && declared_signal.has_value()) {
																			const variable::ptr &valid_signal_declaration = declared_signal.value();
																			if (current_symbol_table_scope->contains(valid_signal_declaration->name)) {
																				// TODO: GEN_ERROR 
																				// TODO: Do not cancel parsing
																			}
																			else {
																				valid_signal_declarations.emplace_back(valid_signal_declaration);
																				current_symbol_table_scope->add_entry(valid_signal_declaration);
																			}
																		}
																	.)
{																	(.	declared_signal.reset();			.)	
	"," SignalDeclaration<signal_type, declared_signal>				(.	if (valid_signal_type && declared_signal.has_value()) {
																			const variable::ptr &valid_signal_declaration = declared_signal.value();
																			if (current_symbol_table_scope->contains(valid_signal_declaration->name)) {
																				// TODO: GEN_ERROR 
																				// TODO: Do not cancel parsing
																			}
																			else {
																				valid_signal_declarations.emplace_back(valid_signal_declaration);
																				current_symbol_table_scope->add_entry(valid_signal_declaration);
																			}
																		}
																	.)
}																	(.	if (valid_signal_declarations.size()){
																			signals.emplace(valid_signal_declarations);
																		}
																	.)
.


/*-------------------------------------------------------------------------
SignalDeclaration production
-------------------------------------------------------------------------*/

SignalDeclaration<. variable::types variable_type, std::optional<variable::ptr> &declared_signal .>			(.	std::vector<unsigned int> dimensions{};
																												// TODO: Use default bit width
																												unsigned int signal_width = 0;	
																												bool valid_declaration = true;
																											.)
=
ident																										(.	const std::string signal_ident = convert_to_uniform_text_format(t->val);	.)
{"[" 
	int																										(.	const std::optional<unsigned int> dimension = convert_token_value_to_number(*t);
																												if (!dimension.has_value()) {
																													valid_declaration = false;
																													// TODO: GEN_ERROR
																												}
																												else {
																													dimensions.emplace_back(dimension.value());	
																												}
																											.)
"]"} 
["(" 
	int																									(.	const std::optional<unsigned int> user_defined_signal_width = convert_token_value_to_number(*t);
																											if (!user_defined_signal_width.has_value()) {
																												// TODO: GEN_ERROR
																												valid_declaration = false;
																											}
																											else {
																												signal_width = user_defined_signal_width.value();
																											}
																										.)
")"]																									(.	// TODO: What if no dimensions is specified, add default dimension entry ?
																											if (valid_declaration) {
																												declared_signal.emplace(std::make_shared<variable>(variable(variable_type, signal_ident, dimensions, signal_width)));
																											}
																										.)	
.

/*-------------------------------------------------------------------------
Statement variants
-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
StatementList
-------------------------------------------------------------------------*/

StatementList<. statement::vec &statements .>								(.	std::optional<statement::ptr> user_defined_statement;	.)
=
Statement<user_defined_statement>											(.	if (user_defined_statement.has_value()) {
																					statements.emplace_back(user_defined_statement.value());
																				}
																			.)
{																			(.	user_defined_statement.reset();	.)	
	";" Statement<user_defined_statement>									(.	if (user_defined_statement.has_value()) {
																					statements.emplace_back(user_defined_statement.value());
																				}
																			.)
}
.


/*-------------------------------------------------------------------------
Statement production
-------------------------------------------------------------------------*/

Statement<. std::optional<statement::ptr> &user_defined_statement .>
=
CallStatement<user_defined_statement>
| ForStatement<user_defined_statement>
| IfStatement<user_defined_statement>
| UnaryStatement<user_defined_statement>
| SkipStatement<user_defined_statement>
| IF (check_if_is_assign_statement()) AssignStatement<user_defined_statement>
| SwapStatement<user_defined_statement>
.


/*-------------------------------------------------------------------------
CallStatement production
-------------------------------------------------------------------------*/

CallStatement<. std::optional<statement::ptr> &statement .>
=
("call" | "uncall") ident "(" ident {"," ident} ")"
.


/*-------------------------------------------------------------------------
ForStatement production
-------------------------------------------------------------------------*/

ForStatement<. std::optional<statement::ptr> &statement .>								(.	std::optional<number::ptr> number;
																							statement::vec loop_body{};
																						.)
=
"for" 
[IF (check_if_loop_iteration_range_start_is_defined()) (
	[
		IF (check_if_loop_variable_is_defined()) (
			"$" ident 
			"="
		)
	] 
	Number<number, false>
	"to"
)] 
Number<number, false>
["step" 
	[	"-"
	] 
Number<number, false>
] 
"do" 
StatementList<loop_body> 
"rof"
.

/*-------------------------------------------------------------------------
IfStatement production
-------------------------------------------------------------------------*/

IfStatement<. std::optional<statement::ptr> &statement .>		(.	expression_evaluation_result condition;
																	expression_evaluation_result closing_condition;
																	statement::vec true_branch{};
																	statement::vec false_branch{};
																.)	
=
"if" Expression<condition, false> 
"then" 
StatementList<true_branch> 
"else" StatementList<false_branch>
"fi" Expression<closing_condition, false>						(.	// TODO: Add check that condition and closing_condition match
																	const bool conditional_well_formed = condition.has_value() 
																		&& closing_condition.has_value()
																		&& !true_branch.empty()
																		&& !false_branch.empty();
																	if (!conditional_well_formed) {
																		return;
																	}
															
																	if_statement::ptr stmt_pointer = std::make_shared<if_statement>(if_statement());
																	if_statement      reference_stmt = dynamic_cast<if_statement&>(*stmt_pointer);

																	reference_stmt.condition = condition.value().convert_to_expression();
																	reference_stmt.fi_condition = closing_condition.value().convert_to_expression();
																	reference_stmt.then_statements = true_branch;
																	reference_stmt.else_statements = false_branch;

																	statement.emplace(stmt_pointer);
																.)
.

/*-------------------------------------------------------------------------
UnaryStatement production
-------------------------------------------------------------------------*/

UnaryStatement<. std::optional<statement::ptr> &statement .>			(.	signal_evaluation_result unary_stmt_operand;
																			std::optional<syrec_operation::operation> unary_operation;	
																		.)
=
(
	"~"																	(.	unary_operation.emplace(syrec_operation::operation::negate_assign);	.)
	| "++"																(.	unary_operation.emplace(syrec_operation::operation::increment_assign);	.)
	| "--"																(.	unary_operation.emplace(syrec_operation::operation::decrement_assign);	.)
) 
"=" Signal<unary_stmt_operand, false>									(.	if (!unary_operation.has_value() || !unary_stmt_operand.has_value() || nullptr == std::get<variable_access::ptr>(unary_stmt_operand.value())) {
																				return;
																			}

																			const variable_access::ptr unary_operand_variable = std::get<variable_access::ptr>(unary_stmt_operand.value());
																			const std::optional<unsigned int> mapped_operation = map_operation_to_unary_operation(unary_operation.value());
																			if (mapped_operation.has_value()) {
																				statement.emplace(std::make_shared<unary_statement>(unary_statement(mapped_operation.value(), unary_operand_variable)));
																			}
																		.)
.


/*-------------------------------------------------------------------------
AssignStatement production
-------------------------------------------------------------------------*/

AssignStatement<. std::optional<statement::ptr> &statement .>	(.		signal_evaluation_result assign_stmt_lhs;
																		expression_evaluation_result assign_stmt_rhs;
																		std::optional<syrec_operation::operation> assign_operation;
																.)
=
Signal<assign_stmt_lhs, false> 
(
	"^"															(.		assign_operation.emplace(syrec_operation::operation::xor_assign);	.)
	| "+"														(.		assign_operation.emplace(syrec_operation::operation::add_assign);	.)
	| "-"														(.		assign_operation.emplace(syrec_operation::operation::minus_assign);	.)
)					
"=" Expression<assign_stmt_rhs, false>							(.		if (!assign_stmt_lhs.has_value() || std::holds_alternative<variable_access::ptr>(assign_stmt_lhs.value()) || !assign_operation.has_value() || !assign_stmt_rhs.has_value()) {
																			return;
																		}
																		const variable_access::ptr assigned_to_obj = std::get<variable_access::ptr>(assign_stmt_lhs.value());
																		const std::optional<unsigned int> mapped_operation = map_operation_to_assign_operation(assign_operation.value());
																		if (mapped_operation.has_value()) {
																			statement.emplace(std::make_shared<assign_statement>(assign_statement(assigned_to_obj,
																																				mapped_operation.value(),
																																				assign_stmt_rhs.value().convert_to_expression())));
																		}
																.)		
.

/*-------------------------------------------------------------------------
SwapStatement production
-------------------------------------------------------------------------*/

SwapStatement<. std::optional<statement::ptr> &statement .>			(.	signal_evaluation_result swap_me, swap_other;
																		bool swap_operator_specified = false;
																	.)
=
Signal<swap_me, false> 
"<=>"																(.	swap_operator_specified = true;	.)
Signal<swap_other, false>											(.	const bool lhs_operand_valid = swap_me.has_value() && std::holds_alternative<variable_access::ptr>(swap_me.value());
																		const bool rhs_operand_valid = swap_other.has_value() && std::holds_alternative<variable_access::ptr>(swap_other.value());

																		if (swap_operator_specified && lhs_operand_valid && rhs_operand_valid) {
																			const variable_access::ptr &lhs = std::get<variable_access::ptr>(swap_me.value());
																			const variable_access::ptr &rhs = std::get<variable_access::ptr>(swap_other.value());
																			statement.emplace(std::make_shared<swap_statement>(swap_statement(lhs, rhs)));
																		}			
																	.)
.


/*-------------------------------------------------------------------------
SkipStatement production
-------------------------------------------------------------------------*/

SkipStatement<. std::optional<statement::ptr> &statement .>
=
"skip"															(.	statement.emplace(std::make_shared<skip_statement>(skip_statement()));	.)
.


/*-------------------------------------------------------------------------
Signal production
-------------------------------------------------------------------------*/

Signal<signal_evaluation_result &signal_access, bool simplify_if_possible>	(.	std::optional<variable::ptr> signal;	
																				variable_access::ptr declared_signal_access;
																				bool valid_signal_access = true;
																				// TODO: Using global zero_based indexing flag to initialize default value
																				std::size_t dimension_index = 0;
																			.)				
=
ident																		(.	const std::string signal_ident = convert_to_uniform_text_format(t->val);
																				if (check_ident_was_declared(signal_ident)) {
																					signal.emplace(current_symbol_table_scope->get_variable(signal_ident).value());
																					declared_signal_access = std::make_shared<variable_access>(variable_access());
																					declared_signal_access->set_var(signal.value());
																				}
																				else {
																					valid_signal_access = false;
																				}
																			.)
{"["																		(.	expression_evaluation_result index_expression;	.)
	Expression<index_expression, simplify_if_possible>						(.	valid_signal_access &= index_expression.has_value();
																				if (signal.has_value() && index_expression.has_value()) {
																					const std::optional<unsigned int> &optional_dimension_access_value = get_value_if_expression_is_constant(index_expression);

																					if (optional_dimension_access_value.has_value()) {
																						const unsigned int constant_dimension_access_value = optional_dimension_access_value.value();

																						// TODO: Using global zero_based indexing flag
																						if (!range_check::is_valid_dimension_access(signal.value(), dimension_index, constant_dimension_access_value, true)) {
																							valid_signal_access = false;

																							// TODO: Using global zero_based indexing flag
																							const range_check::valid_index_access_range valid_dimension_access_range = range_check::get_valid_dimension_access_range(signal.value(), true);
																							// TODO: GEN_ERROR
																						}
																						else {
																							declared_signal_access->indexes.emplace_back(index_expression.value().convert_to_expression());
																						}
																					}
																					else {
																						declared_signal_access->indexes.emplace_back(index_expression.value().get_expression());
																					}
																				}
																				dimension_index++;
																			.)
"]"
} 
[																			(.	std::optional<number::ptr> range_start, range_end;
																				bool defined_range = false;
																			.)
	"." Number<range_start, false>									
	[
		":" Number<range_end, false>										(.	defined_range = true;	.)
	]																		(.	valid_signal_access &= range_start.has_value() && (defined_range ? range_end.has_value() : true);
																				if (valid_signal_access) {
																					const variable::ptr &accessed_variable = signal.value();

																					const bool is_bit_access = !range_end.has_value();
																					const number::ptr &bit_or_range_access_start = range_start.value();
																					const number::ptr &bit_or_range_access_end = is_bit_access ? bit_or_range_access_start : range_end.value();
																					
																					if (is_bit_access) {
																						const unsigned int bit_access_value = range_start.value()->evaluate({});

																						// TODO: Check bitwidth is within range [0, bitwidth - 1]
																						// TODO: Using global zero_based indexing flag
																						if (!range_check::is_valid_bit_access(accessed_variable, bit_access_value, true)) {
																							valid_signal_access = false;
																							// TODO: GEN_ERROR
																							// TODO: Using global zero_based indexing flag
																							const range_check::valid_index_access_range valid_dimension_access_range = range_check::get_valid_bit_access_range(accessed_variable, true);
																						}
																					}
																					else {
																						// TODO: Check user defined range is within [0, bitwidth - 1]
																						// TODO: Using global zero_based indexing flag
																						if (!range_check::is_valid_range_access(accessed_variable, 
																																range_start.value()->evaluate({}),
																																range_end.value()->evaluate({}),
																																true)){
																							valid_signal_access = false;
																							// TODO: GEN_ERROR
																							// TODO: Using global zero_based indexing flag
																							const range_check::valid_index_access_range valid_dimension_access_range = range_check::get_valid_range_access_range(accessed_variable, true);
																						}
																					}

																					if (valid_signal_access){
																						declared_signal_access->range.emplace(std::pair<number::ptr, number::ptr>(bit_or_range_access_start, bit_or_range_access_end));
																					}
																				}
																			.)
]																			(.	if (valid_signal_access) {
																					signal_access.emplace(declared_signal_access);
																				}
																			.)
.

/*-------------------------------------------------------------------------
Expressions variants
-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
Expression production
-------------------------------------------------------------------------*/

Expression<expression_evaluation_result &expression, bool simplify_if_possible>			(.	signal_evaluation_result signal;
																							std::optional<number::ptr> number;
																						.)
=
(
	IF (check_if_expression_is_number()) Number<number, simplify_if_possible>									
	| IF (check_if_expression_is_binary_expression()) BinaryExpression<expression, simplify_if_possible>
	| ShiftExpression<expression, simplify_if_possible>
)
	| Signal<signal, simplify_if_possible>					
	| UnaryExpression<expression, simplify_if_possible>
.

/*-------------------------------------------------------------------------
BinaryExpression production
-------------------------------------------------------------------------*/

BinaryExpression<expression_evaluation_result &binary_expression, bool simplify_if_possible>						(.	expression_evaluation_result binary_expr_lhs;
																														expression_evaluation_result binary_expr_rhs;
																													.)	
=
"(" Expression<binary_expr_lhs, simplify_if_possible> 
	("+" | "-" | "^" | "*" | "/" | "%" | "*>" | "&&" | "||" | "&" | "|" | "<" | ">" | "=" | "!=" | "<=" | ">=") 
	Expression<binary_expr_rhs, simplify_if_possible>
")"
.


/*-------------------------------------------------------------------------
UnaryExpression production
-------------------------------------------------------------------------*/

UnaryExpression<expression_evaluation_result &unary_expression, bool simplify_if_possible>							(.	expression_evaluation_result unary_expression_operand;	.)
=
("!" | "~") Expression<unary_expression_operand, simplify_if_possible>
.


/*-------------------------------------------------------------------------
ShiftExpression production
-------------------------------------------------------------------------*/

ShiftExpression<expression_evaluation_result &shift_expression, bool simplify_if_possible>	(.	expression_evaluation_result shift_expression_lhs;
																								std::optional<number::ptr> shift_amount;
																							.)
=
"(" Expression<shift_expression_lhs, simplify_if_possible> ("<<" | ">>") Number<shift_amount, simplify_if_possible> ")"
.

END SyReC.