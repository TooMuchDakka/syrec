/*-------------------------------------------------------------------------
ATG for SyReC: A Programming Language for Synthesis of Reversible Circuits
(specification available @ http://www.revlib.org/doc/docu/revlib_2_0_1.pdf)

User manual for Coco/R is available @
https://ssw.jku.at/Research/Projects/Coco/Doc/UserManual.pdf
-------------------------------------------------------------------------*/
/*-- $checkEOF=false --*/

// Place includes here
#include <fmt/format.h>
#include <optional>
#include <stack>
#include <string>
#include <vector>

#include "core/syrec/module.hpp"
#include "core/syrec/parser/custom_semantic_errors.hpp"
#include "core/syrec/parser/expression_evaluation_result.hpp"
#include "core/syrec/parser/grammar_conflict_resolver.hpp"
#include "core/syrec/parser/method_call_guess.hpp"
#include "core/syrec/parser/operation.hpp"
#include "core/syrec/parser/range_check.hpp"
#include "core/syrec/parser/parser_config.hpp"
#include "core/syrec/parser/signal_evaluation_result.hpp"
#include "core/syrec/parser/symbol_table.hpp"
#include "core/syrec/parser/text_utils.hpp"

COMPILER SyReC
	// Place declarations of objects referenced in this ATG
	syrec::Module::vec modules;
	SymbolTable::ptr currSymTabScope;
	ParserConfig config;

	std::stack<std::pair<std::string, std::vector<std::string>>> callStack;

	syrec::Number::loop_variable_mapping loopVariableMappingLookup;

	// This method will be called by the contructor if it exits.
	// This support is specific to the C++ version of Coco/R.
	void Init() {
		// nothing to do
		SymbolTable::openScope(currSymTabScope);
	}

	// Uncomment this method if cleanup is necessary,
	// this method will be called by the destructor if it exists.
	// This support is specific to the C++ version of Coco/R.
	// void Destroy() {
		// nothing to do
	// }

	[[nodiscard]] std::optional<unsigned int> convert_token_value_to_number(const Token &token) {
		std::optional<unsigned int> token_as_number;
		try {
			token_as_number.emplace(std::stoul(convert_to_uniform_text_format(token.val)));
		} 
		catch (std::invalid_argument const &ex) {
			// TODO: GEN_ERROR
		}
		catch (std::out_of_range const &ex) {
			// TODO: GEN_ERROR
		}
		return token_as_number;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_assign_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::add_assign:
				mapping_result.emplace(syrec::AssignStatement::Add);
				break;
			case syrec_operation::operation::minus_assign:
				mapping_result.emplace(syrec::AssignStatement::Subtract);
				break;
			case syrec_operation::operation::xor_assign:
				mapping_result.emplace(syrec::AssignStatement::Exor);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_unary_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::increment_assign:
				mapping_result.emplace(syrec::UnaryStatement::Increment);
				break;
			case syrec_operation::operation::decrement_assign:
				mapping_result.emplace(syrec::UnaryStatement::Decrement);
				break;
			case syrec_operation::operation::negate_assign:
				mapping_result.emplace(syrec::UnaryStatement::Invert);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_shift_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::shift_left:
				mapping_result.emplace(syrec::ShiftExpression::Left);
				break;
			case syrec_operation::operation::shift_right:
				mapping_result.emplace(syrec::ShiftExpression::Right);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_binary_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::addition:
				mapping_result.emplace(syrec::BinaryExpression::Add);
				break;
			case syrec_operation::operation::subtraction:
				mapping_result.emplace(syrec::BinaryExpression::Subtract);
				break;
				case syrec_operation::operation::multiplication:
				mapping_result.emplace(syrec::BinaryExpression::Multiply);
				break;		
			case syrec_operation::operation::division:
				mapping_result.emplace(syrec::BinaryExpression::Divide);
				break;			
			case syrec_operation::operation::modulo:
				mapping_result.emplace(syrec::BinaryExpression::Modulo);
				break;		
			case syrec_operation::operation::upper_bits_multiplication:
				mapping_result.emplace(syrec::BinaryExpression::FracDivide);
				break;		
			case syrec_operation::operation::bitwise_xor:
				mapping_result.emplace(syrec::BinaryExpression::Exor);
				break;		
			case syrec_operation::operation::logical_and:
				mapping_result.emplace(syrec::BinaryExpression::LogicalAnd);
				break;		
			case syrec_operation::operation::logical_or:
				mapping_result.emplace(syrec::BinaryExpression::LogicalOr);
				break;		
			case syrec_operation::operation::bitwise_and:
				mapping_result.emplace(syrec::BinaryExpression::BitwiseAnd);
				break;	
			case syrec_operation::operation::bitwise_or:
				mapping_result.emplace(syrec::BinaryExpression::BitwiseOr);
				break;	
			case syrec_operation::operation::less_than:
				mapping_result.emplace(syrec::BinaryExpression::LessThan);
				break;	
			case syrec_operation::operation::greater_than:
				mapping_result.emplace(syrec::BinaryExpression::GreaterThan);
				break;	
			case syrec_operation::operation::equals:
				mapping_result.emplace(syrec::BinaryExpression::Equals);
				break;		
			case syrec_operation::operation::not_equals:
				mapping_result.emplace(syrec::BinaryExpression::NotEquals);
				break;		
			case syrec_operation::operation::less_equals:
				mapping_result.emplace(syrec::BinaryExpression::LessEquals);
				break;		
			case syrec_operation::operation::greater_equals:
				mapping_result.emplace(syrec::BinaryExpression::GreaterEquals);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	[[nodiscard]] const wchar_t* convertErrorMsgToRequiredFormat(const std::string& errorMsg) {
		return std::wstring(errorMsg.begin(), errorMsg.end()).c_str();
	}

	bool checkIdentWasDeclaredOrLogError(const std::string_view& ident) {
		if (!currSymTabScope->contains(ident)) {
			// TODO: GEN_ERROR
			SemErr(convertErrorMsgToRequiredFormat(fmt::format(UndeclaredIdent, ident)));
			return false;
		}
		return true;
	}

	bool isIdentAssignableOtherwiseLogError(const syrec::VariableAccess::ptr& assignedToVariable) {
		if (syrec::Variable::Types::In == assignedToVariable->getVar()->type){
			SemErr(convertErrorMsgToRequiredFormat(fmt::format(AssignmentToReadonlyVariable, assignedToVariable->getVar()->name)));
			return false;
		}
		return true;
	}

	[[nodiscard]] std::optional<unsigned int> applyBinaryOperation(const syrec_operation::operation operation, const unsigned int leftOperand, const unsigned int rightOperand) {
		if (operation == syrec_operation::operation::division && rightOperand == 0) {
			// TODO: GEN_ERROR
			SemErr(convertErrorMsgToRequiredFormat(DivisionByZero));
			return std::nullopt;	
		}
		else {
			return syrec_operation::apply(operation, leftOperand, rightOperand);	
		}
	}

	[[nodiscard]] std::optional<unsigned int> evaluateNumberContainer(const syrec::Number::ptr &numberContainer) {
		if (numberContainer->isLoopVariable()) {
			const std::string& loopVariableIdentToResolve = numberContainer->variableName();
			if (loopVariableMappingLookup.find(loopVariableIdentToResolve) == loopVariableMappingLookup.end()) {
				// TODO: GEN_ERROR
				SemErr(convertErrorMsgToRequiredFormat(fmt::format(NoMappingForLoopVariable, loopVariableIdentToResolve)));
				return std::nullopt;
			}
		}
		return std::optional(numberContainer->evaluate(loopVariableMappingLookup));
	}

	[[nodiscard]] ExpressionEvaluationResult::ptr createExpressionEvalutionResultContainer() const {
		return std::make_shared<ExpressionEvaluationResult>(ExpressionEvaluationResult());
	}

	void setConfig(const ParserConfig& customConfig) {
		this->config = customConfig;
	}

/*-------------------------------------------------------------------------*/

CHARACTERS
	letter		= 'A' .. 'Z' + 'a' .. 'z'.
	digit		= '0' .. '9'.

	cr        = '\r'.
	lf        = '\n'.
	tab       = '\t'.

TOKENS
	ident		= ('_' | letter) {('_' | letter | digit)}.
	int			= digit {digit}.
	
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/
PRODUCTIONS


/*-------------------------------------------------------------------------
syrec::Number production

Since Coco/R does not accept recursive token definitions, 
we redefine the token 'syrec::Number as a non-terminal symbol
-------------------------------------------------------------------------*/
// TODO: Current data structure does not handle negative numbers well, one migitation could be to use the two-complement representation (which would require to update the calculation for many operations (i.e. division, etc.))
// TODO: Currently synthesis uses ident without '$' prefix for its loop mappings
// TODO: For now no loop variable mappings will get added to the lookup (since currently no support for iterating a list of statements is supported)

// TODO: Expression productions still require checks that the bitwidth of the internal expressions (i.e. the left and right expression in a binary expression) are not larger than the input one

Number<. std::optional<syrec::Number::ptr> &parsedNumber, const bool simplifyIfPossible .>									
=
int																			(.	const std::optional<unsigned int> conversion_result = convert_token_value_to_number(*t);
																				if (conversion_result.has_value()) {
																					const syrec::Number::ptr result = std::make_shared<syrec::Number>(syrec::Number(conversion_result.value())); 
																					parsedNumber.emplace(result);
																				}
																			.)
| '#' ident																	(.	const std::string signalIdent = convert_to_uniform_text_format(t->val);
																				if (!checkIdentWasDeclaredOrLogError(signalIdent)) {
																					return;
																				}

																				const auto &symTabEntry = currSymTabScope->getVariable(signalIdent);
																				if (symTabEntry.has_value() && std::holds_alternative<syrec::Variable::ptr>(symTabEntry.value())) {
																					parsedNumber.emplace(std::make_shared<syrec::Number>(syrec::Number(std::get<syrec::Variable::ptr>(symTabEntry.value())->bitwidth)));
																				}
																				else {
																					// TODO: GEN_ERROR, this should not happen but check anyways
																					return;
																				}
																			.)
| '$' ident																	(.	const std::string signalIdent = "$" + convert_to_uniform_text_format(t->val);
																				if (!checkIdentWasDeclaredOrLogError(signalIdent)) {
																					return;
																				}
																				
																				const auto &symTabEntry = currSymTabScope->getVariable(signalIdent);
																				if (symTabEntry.has_value() && std::holds_alternative<syrec::Number::ptr>(symTabEntry.value())) {
																					// TODO: An optimization that can be done here would be the replacement of the loop variable with its current value from the mapping
																					parsedNumber.emplace(std::get<syrec::Number::ptr>(symTabEntry.value()));
																				}
																				else {
																					// TODO: GEN_ERROR, this should not happen but check anyways
																				}
																			.)
| (																			(.	std::optional<syrec::Number::ptr> lhsOperand, rhsOperand;  
																				std::optional<syrec_operation::operation> op;
																			.)
	'(' 
		Number<lhsOperand, simplifyIfPossible>
		('+'																(.	op.emplace(syrec_operation::operation::addition);		.)
		|'-'																(.	op.emplace(syrec_operation::operation::subtraction);	.)
		|'*'																(.	op.emplace(syrec_operation::operation::multiplication);	.)
		|'/'																(.	op.emplace(syrec_operation::operation::division);		.)
		) 
		Number<rhsOperand, simplifyIfPossible>								(.	if (!op.has_value()) {
																					// TODO: GEN_ERROR Expected one of n operand but not of them was specified
																					SemErr(convertErrorMsgToRequiredFormat(InvalidOrMissingNumberExpressionOperation));
																					return;
																				}

																				if (!lhsOperand.has_value() || !rhsOperand.has_value()){
																					return;
																				}

																				const std::optional<unsigned int> lhsEvaluated = evaluateNumberContainer(lhsOperand.value());
																				const std::optional<unsigned int> rhsEvaluated = evaluateNumberContainer(rhsOperand.value());

																				if (lhsEvaluated.has_value() && rhsEvaluated.has_value()) {
																					const std::optional<unsigned int> evaluationResult = applyBinaryOperation(op.value(), lhsEvaluated.value(), rhsEvaluated.value());

																					if (evaluationResult.has_value()) {
																						const syrec::Number::ptr result = std::make_shared<syrec::Number>(syrec::Number(evaluationResult.value())); 
																						parsedNumber.emplace(result);
																					}
																				}
																			.)
	')'																	
)
.

/*-------------------------------------------------------------------------
Program and Modules
-------------------------------------------------------------------------*/

SyReC										(.	std::optional<syrec::Module::ptr> module;	.)
=
Module<module>								(.	if (module.has_value()) {
													currSymTabScope->addEntry(module.value());
													this->modules.emplace_back(module.value());
												}
											.)
{											(.	module.reset();	.)
	Module<module>							(.	if (!module.has_value())
													return;

												const syrec::Module::ptr userDefinedModule = module.value();
												if (currSymTabScope->contains(userDefinedModule)){
													// TODO: GEN_ERROR 
													// TODO: Do not cancel parsing	
													SemErr(convertErrorMsgToRequiredFormat(fmt::format(DuplicateModuleIdentDeclaration, userDefinedModule->name)));
												}
												else {
													currSymTabScope->addEntry(userDefinedModule);
													this->modules.emplace_back(module.value());
												}
											.)
}
.

/*-------------------------------------------------------------------------
syrec::Module production
-------------------------------------------------------------------------*/

Module <. std::optional<syrec::Module::ptr> &parsedModule	.>			(.	SymbolTable::openScope(currSymTabScope);
																			std::optional<std::vector<syrec::Variable::ptr>> locals;	
																			bool isValidModuleDefinition = true;
																			syrec::Statement::vec moduleStmts {};
																		.)	
=
"module" ident															(.	const std::string moduleName = convert_to_uniform_text_format(t->val);	
																			syrec::Module::ptr userDefinedModule = std::make_shared<syrec::Module>(syrec::Module(moduleName));
																		.)	
"(" [ParameterList<userDefinedModule, isValidModuleDefinition>] ")" 
{																		
	SignalList<userDefinedModule, isValidModuleDefinition>					
}														
StatementList<moduleStmts>												(.	SymbolTable::closeScope(currSymTabScope);
																			if (moduleStmts.empty()) {
																				isValidModuleDefinition = false;
																				// TODO: GEN_ERROR
																			}

																			if (isValidModuleDefinition) {
																				for (const auto &statement : moduleStmts) {
																					userDefinedModule->addStatement(statement);
																				}
																				parsedModule.emplace(userDefinedModule);
																			}
																		.)
.


/*-------------------------------------------------------------------------
ParameterList production
-------------------------------------------------------------------------*/

ParameterList<const syrec::Module::ptr &module, bool &isValidModuleDefinition>		(.	std::optional<syrec::Variable::ptr> parameter;	.)
=
Parameter<parameter>																(.	isValidModuleDefinition &= parameter.has_value();
																						if (isValidModuleDefinition) {
																							module->addParameter(parameter.value());
																						}
																					.)
{																					(.	parameter.reset();	.)
	"," Parameter<parameter>														(.	isValidModuleDefinition &= parameter.has_value();
																						if (isValidModuleDefinition)
																							module->addParameter(parameter.value());
																					.)
}															
.


/*-------------------------------------------------------------------------
Parameter production
-------------------------------------------------------------------------*/

Parameter<. std::optional<syrec::Variable::ptr> &parameter .>						(.	std::optional<syrec::Variable::Types> parameterType;	.)	
= 
(
	"in"																			(.	parameterType.emplace(syrec::Variable::In);	.)
	| "out"																			(.	parameterType.emplace(syrec::Variable::Out);	.)
	| "inout"																		(.	parameterType.emplace(syrec::Variable::Inout);	.)	
)																					(.	if (!parameterType.has_value())
																							// TODO: GEN_ERROR
																							SemErr(convertErrorMsgToRequiredFormat(InvalidParameterType));
																					.)
SignalDeclaration<parameterType, parameter>									
.

/*-------------------------------------------------------------------------
SignalList production
-------------------------------------------------------------------------*/

SignalList <. const syrec::Module::ptr& module, bool &isValidModuleDefinition .>		(.	std::optional<syrec::Variable::Types> signalType;
																							std::optional<syrec::Variable::ptr> declaredSignal;
																						.)
=
(
	"wire"																				(.	signalType.emplace(syrec::Variable::Wire);		.)
	| "state"																			(.	signalType.emplace(syrec::Variable::State);		.)
)																						(.	if (!signalType.has_value())
																								SemErr(convertErrorMsgToRequiredFormat(InvalidLocalType));
																						.)
SignalDeclaration<signalType, declaredSignal>											(.	isValidModuleDefinition &= declaredSignal.has_value();
																							if (isValidModuleDefinition)
																								module->addVariable(declaredSignal.value());
																						.)
{																						(.	declaredSignal.reset();			.)	
	"," SignalDeclaration<signalType, declaredSignal>									(.	isValidModuleDefinition &= declaredSignal.has_value();
																							if (isValidModuleDefinition)
																								module->addVariable(declaredSignal.value());
																						.)
}.


/*-------------------------------------------------------------------------
SignalDeclaration production
-------------------------------------------------------------------------*/

SignalDeclaration<. const std::optional<syrec::Variable::Types> variableType, std::optional<syrec::Variable::ptr> &signalDeclaration .>	(.	std::vector<unsigned int> dimensions{};
																																			unsigned int signalWidth = config.cDefaultSignalWidth;	
																																			bool isValidSignalDeclaration = variableType.has_value();
																																		.)
=
ident																																	(.	const std::string signalIdent = convert_to_uniform_text_format(t->val);
																																			if (currSymTabScope->contains(signalIdent)) {
																																				isValidSignalDeclaration = false;
																																				SemErr(convertErrorMsgToRequiredFormat(fmt::format(DuplicateDeclarationOfIdent, signalIdent)));
																																			}
																																		.)
{"[" 
	int																																	(.	const std::optional<unsigned int> dimension = convert_token_value_to_number(*t);
																																			if (!dimension.has_value()) {
																																				isValidSignalDeclaration = false;
																																			}
																																			else {
																																				dimensions.emplace_back(dimension.value());	
																																			}
																																		.)
"]"}																										
["(" 
	int																																	(.	const std::optional<unsigned int> customSignalWidth = convert_token_value_to_number(*t);
																																			if (!customSignalWidth.has_value()) {
																																				isValidSignalDeclaration = false;
																																			}
																																			else {
																																				signalWidth = customSignalWidth.value();
																																			}
																																		.)
")"]																																	(.	if (isValidSignalDeclaration) {
																																				signalDeclaration.emplace(std::make_shared<syrec::Variable>(syrec::Variable(variableType.value(), signalIdent, dimensions, signalWidth)));
																																				// TODO: What should happen if there is an error here
																																				currSymTabScope->addEntry(signalDeclaration.value());
																																			}
																																		.)	
.

/*-------------------------------------------------------------------------
syrec::Statement variants
-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
StatementList
-------------------------------------------------------------------------*/

// TODO: Add check that every call statement has its matching counterpart, no uncall can be made before its corresponding call was called
StatementList<. syrec::Statement::vec &statements .>						(.	std::optional<syrec::Statement::ptr> user_defined_statement;	.)
=
Statement<user_defined_statement>											(.	if (user_defined_statement.has_value()) {
																					statements.emplace_back(user_defined_statement.value());
																				}
																			.)
{																			(.	user_defined_statement.reset();	.)	
	";" Statement<user_defined_statement>									(.	if (user_defined_statement.has_value()) {
																					statements.emplace_back(user_defined_statement.value());
																				}
																			.)
}
.


/*-------------------------------------------------------------------------
syrec::Statement production
-------------------------------------------------------------------------*/

Statement<. std::optional<syrec::Statement::ptr> &user_defined_statement .>
=
CallStatement<user_defined_statement>
| ForStatement<user_defined_statement>
| IfStatement<user_defined_statement>
| UnaryStatement<user_defined_statement>
| SkipStatement<user_defined_statement>
| IF (shouldTakeAssignInsteadOfSwapAlternative(this)) AssignStatement<user_defined_statement>
| SwapStatement<user_defined_statement>
.


/*-------------------------------------------------------------------------
CallStatement production
-------------------------------------------------------------------------*/

// TODO: Are aliases between the formal and actual parameters necessary (i.e. in a call statement should the parameter be replaced with the actual value)
// TODO: Determine if function overloading is supported, can loop variables be passed as a parameter
CallStatement<. std::optional<syrec::Statement::ptr> &statement .>					(.	std::optional<bool> isCallStatement;
																						std::vector<std::string> calleeArguments {};
																						std::size_t numActualParameters = 0;
																						bool isValidCallOperation = true;
																					.)
=
(
	"call"																			(.	isCallStatement.emplace(true);
																						if (!callStack.empty()){
																							// TODO: GEN_ERROR
																							SemErr(convertErrorMsgToRequiredFormat(PreviousCallWasNotUncalled));
																							isValidCallOperation = false;
																						}
																					.)
	| "uncall"																		(.	isCallStatement.emplace(false); 
																						if (callStack.empty()) {
																							// TODO: GEN_ERROR
																							SemErr(convertErrorMsgToRequiredFormat(UncallWithoutPreviousCall));
																							isValidCallOperation = false;
																						}
																					.)
)																					(.	isValidCallOperation = isCallStatement.has_value();	.)
ident																				(.	std::string methodIdent = convert_to_uniform_text_format(t->val);
																						const MethodCallGuess::ptr guessesForPossibleCall = std::make_shared<MethodCallGuess>(MethodCallGuess(currSymTabScope, methodIdent));
																						if (!guessesForPossibleCall->hasSomeMatches()) {
																							SemErr(convertErrorMsgToRequiredFormat(fmt::format(UndeclaredIdent, methodIdent)));
																							isValidCallOperation = false;
																						}
																						// After the method ident is declared after the uncall is defined, check that method ident matches the one of the previous call statement
																						else if (isValidCallOperation && !isCallStatement.value() && !callStack.empty()) {
																							const std::string_view previouslyCalledMethodIdent = callStack.top().first;
																							if (previouslyCalledMethodIdent != methodIdent){
																								// TODO: GEN_ERROR
																								SemErr(convertErrorMsgToRequiredFormat(fmt::format(MissmatchOfModuleIdentBetweenCalledAndUncall, previouslyCalledMethodIdent, methodIdent)));
																								isValidCallOperation = false;
																							}
																						}
																					.)
"(" 
	ident																			(.	std::string parameterIdent = convert_to_uniform_text_format(t->val);
																						isValidCallOperation &= checkIdentWasDeclaredOrLogError(parameterIdent) && currSymTabScope->contains(parameterIdent);

																						if (isValidCallOperation) {
																							const std::variant<syrec::Variable::ptr, syrec::Number::ptr> paramSymTabEntry = currSymTabScope->getVariable(parameterIdent).value();
																							isValidCallOperation = std::holds_alternative<syrec::Variable::ptr>(paramSymTabEntry);

																							if (isValidCallOperation) {
																								guessesForPossibleCall->refineWithNextParameter(std::get<syrec::Variable::ptr>(paramSymTabEntry));
																								calleeArguments.emplace_back(parameterIdent);
																							}
																							else {
																								// TODO: GEN_ERROR Declared identifier was not a variable (but a loop variable)
																							}
																						}
																						numActualParameters++;
																					.)
	{
		"," ident																	(.	std::string parameterIdent = convert_to_uniform_text_format(t->val);
																						isValidCallOperation &= checkIdentWasDeclaredOrLogError(parameterIdent) && currSymTabScope->contains(parameterIdent);

																						if (isValidCallOperation) {
																							const std::variant<syrec::Variable::ptr, syrec::Number::ptr> paramSymTabEntry = currSymTabScope->getVariable(parameterIdent).value();
																							isValidCallOperation = std::holds_alternative<syrec::Variable::ptr>(paramSymTabEntry);

																							if (isValidCallOperation) {
																								guessesForPossibleCall->refineWithNextParameter(std::get<syrec::Variable::ptr>(paramSymTabEntry));
																								calleeArguments.emplace_back(parameterIdent);
																							}
																							else {
																								// TODO: GEN_ERROR Declared identifier was not a variable (but a loop variable)
																							}
																						}
																						numActualParameters++;
																					.)
	}																
")"																					(.	if (!isValidCallOperation){
																							return;
																						}

																						if (!guessesForPossibleCall->hasSomeMatches()) {
																							// TODO: GEN_ERROR Not enough parameters defined
																							// TODO: Provide number of expected formal parameters
																							SemErr(convertErrorMsgToRequiredFormat(fmt::format(NumberOfFormalParametersDoesNotMatchActual, methodIdent, 0, calleeArguments.size())));
																							return;		
																						}
																						
																						guessesForPossibleCall->discardGuessesWithMoreThanNParameters(numActualParameters);
																						if (!guessesForPossibleCall->hasSomeMatches()) {
																							// TODO: GEN_ERROR All of the declared methods that matched had more than n parameters
																							// TODO: Provide number of expected formal parameters
																							SemErr(convertErrorMsgToRequiredFormat(fmt::format(NumberOfFormalParametersDoesNotMatchActual, methodIdent, 0, calleeArguments.size())));
																							return;
																						}

																						const syrec::Module::vec possibleCalls = guessesForPossibleCall->getMatchesForGuess().value();
																						if (possibleCalls.size() > 1) {
																							// TODO: GEN_ERROR Ambiguous call, more than one match for current setups
																							return;
																						}

																						// Check if provided arguments in call and uncall match
																						if (!callStack.empty() && !isCallStatement.value()){
																							if (!std::equal(
																								calleeArguments.cbegin(),
																								calleeArguments.cend(),
																								callStack.top().second.cbegin()
																							)){
																								SemErr(convertErrorMsgToRequiredFormat(fmt::format(CallAndUncallArgumentsMissmatch, methodIdent)));
																								return;
																							}
																						}

																						const syrec::Module::ptr matchingModuleForCall = possibleCalls.at(0);
																						if (isCallStatement.value()) {
																							statement.emplace(std::make_shared<syrec::CallStatement>(syrec::CallStatement(matchingModuleForCall, calleeArguments)));
																							callStack.push(std::make_pair(methodIdent, calleeArguments));
																						}
																						else {
																							statement.emplace(std::make_shared<syrec::UncallStatement>(syrec::UncallStatement(matchingModuleForCall, calleeArguments)));
																							callStack.pop();
																						}
																					.)
.


/*-------------------------------------------------------------------------
ForStatement production
-------------------------------------------------------------------------*/

// TODO: Currently no negative numbers are supported
ForStatement<. std::optional<syrec::Statement::ptr> &statement .>						(.	std::optional<std::string> loopVariableIdent;
																							std::optional<syrec::Number::ptr> iterationRangeStart;
																							std::optional<syrec::Number::ptr> iterationRangeEnd;
																							std::optional<syrec::Number::ptr> customStepSize;
																							bool negativeStepSize = false;
																							syrec::Statement::vec loopBody{};
																							bool explicitRangeStartDefined = false;
																							bool explicitStepSizeDefined = false;
																						.)
=
"for" 
[IF (checkIsLoopInitialValueExplicitlyDefined(this)) (
	[
		IF (checkIsLoopVariableExplicitlyDefined(this)) (
			"$" ident																	(.	// TODO: Maybe replace opening scope for loop variable with remove from symbol table
																							const std::string &loopVarIdent = "$" + convert_to_uniform_text_format(t->val);
																							if (!currSymTabScope->contains(loopVarIdent)) {
																								loopVariableIdent.emplace(loopVarIdent);
																								SymbolTable::openScope(currSymTabScope);
																								const syrec::Number::ptr loopVariableEntry = std::make_shared<syrec::Number>(syrec::Number(loopVarIdent));
																								currSymTabScope->addEntry(loopVariableEntry);
																							}
																							else {
																								SemErr(convertErrorMsgToRequiredFormat(fmt::format(DuplicateDeclarationOfIdent, loopVarIdent)));
																							}
																						.)
			"="
		)
	] 
	Number<iterationRangeStart, true>													(.	explicitRangeStartDefined = true;	.)
	"to"
)] 
Number<iterationRangeEnd, true>															(.	if (!explicitRangeStartDefined){
																								iterationRangeStart = iterationRangeEnd;
																							}
																						.)
["step"																					(.	explicitStepSizeDefined = true;	.)
	[	"-"																				(.	negativeStepSize = true;	.)
	] 
Number<customStepSize, true>															(.	if (customStepSize.has_value() && !customStepSize.value()->evaluate({})) {
																								// TODO: GEN_ERROR step size cannot be zero ?
																							}
																						.)		
]																						(.	if (!explicitStepSizeDefined) {
																								customStepSize.emplace(std::make_shared<syrec::Number>(syrec::Number(1)));
																							}

																							bool validLoopHeader = loopVariableIdent.has_value() 
																															&& (explicitRangeStartDefined ? iterationRangeStart.has_value() : true)
																															&& iterationRangeEnd.has_value()
																															&& (explicitStepSizeDefined ? customStepSize.has_value() : true);
																							if (validLoopHeader) {
																								const unsigned int iterationRangeStartValue = iterationRangeStart.value()->evaluate({});
																								const unsigned int iterationRangeEndValue = iterationRangeEnd.value()->evaluate({});
																								const unsigned int stepSize = customStepSize.value()->evaluate({});

																								unsigned int numIterations;
																								if ((negativeStepSize && iterationRangeEndValue > iterationRangeStartValue)
																									|| (!negativeStepSize && iterationRangeStartValue > iterationRangeEndValue)
																									|| !stepSize) {
																									// TODO: Either generate error or warning
																									numIterations = 0;	
																									validLoopHeader = false;
																								}
																								else {
																									numIterations = negativeStepSize 
																										? (iterationRangeStartValue - iterationRangeEndValue)
																										: (iterationRangeEndValue - iterationRangeStartValue);
																									numIterations = (numIterations + 1) / stepSize;
																								}
																							}
																						.)
"do" 
StatementList<loopBody>																	(.	if (loopBody.empty()) {
																								// TODO: GEN_ERROR
																							}
																						.)
"rof"																					(.	if (loopVariableIdent.has_value()) {
																								SymbolTable::closeScope(currSymTabScope);
																							}

																							// TODO: If a statement must be generated, one could create a skip statement instead of simply returning 
																							if (!validLoopHeader || loopBody.empty()) {
																								return;
																							}

																							const std::shared_ptr<syrec::ForStatement> loopStatement = std::make_shared<syrec::ForStatement>();
																							loopStatement->loopVariable = loopVariableIdent.value();
																							loopStatement->range = std::pair(iterationRangeStart.value(), iterationRangeEnd.value());
																							loopStatement->step = customStepSize.value();
																							loopStatement->statements = loopBody;
																							statement.emplace(loopStatement);
																						.)
.

/*-------------------------------------------------------------------------
IfStatement production
-------------------------------------------------------------------------*/

IfStatement<. std::optional<syrec::Statement::ptr> &statement .>		(.	const ExpressionEvaluationResult::ptr condition = createExpressionEvalutionResultContainer();
																	const ExpressionEvaluationResult::ptr closingCondition = createExpressionEvalutionResultContainer();
																	syrec::Statement::vec trueBranch{};
																	syrec::Statement::vec falseBranch{};
																.)	
=
"if" Expression<condition, 1u, false> 
"then" 
StatementList<trueBranch> 
"else" StatementList<falseBranch>
"fi" Expression<closingCondition, 1u, false>					(.	// TODO: Add check that condition and closing_condition match, closingCondition should use same bitwidth as condition
																	const bool conditionalWellFormed = condition->hasValue() 
																		&& closingCondition->hasValue()
																		&& !trueBranch.empty()
																		&& !falseBranch.empty();
																	if (!conditionalWellFormed) {
																		return;
																	}
															
																	const std::shared_ptr<syrec::IfStatement> &conditional = std::make_shared<syrec::IfStatement>();
																	conditional->condition = condition->getOrConvertToExpression(1u).value();
																	conditional->fiCondition = closingCondition->getOrConvertToExpression(1u).value();
																	conditional->thenStatements                    = trueBranch;
																	conditional->elseStatements                    = falseBranch;
																	statement.emplace(conditional);
																.)
.

/*-------------------------------------------------------------------------
UnaryStatement production
-------------------------------------------------------------------------*/

UnaryStatement<. std::optional<syrec::Statement::ptr> &statement .>		(.	SignalEvaluationResult unaryStmtOperand;
																			std::optional<syrec_operation::operation> unaryOperation;	
																		.)
=
(
	"~"																	(.	unaryOperation.emplace(syrec_operation::operation::negate_assign);	.)
	| "++"																(.	unaryOperation.emplace(syrec_operation::operation::increment_assign);	.)
	| "--"																(.	unaryOperation.emplace(syrec_operation::operation::decrement_assign);	.)
) 
"=" Signal<unaryStmtOperand, false>										(.	bool allSemanticChecksOk = true;
																			if (!unaryOperation.has_value()){
																				allSemanticChecksOk = false;
																				// TODO: GEN_ERROR Expected a valid unary operand
																				SemErr(convertErrorMsgToRequiredFormat(InvalidUnaryOperation));
																			}
																			if (unaryStmtOperand.isValid() && !unaryStmtOperand.isVariableAccess()) {
																				allSemanticChecksOk = false;
																				// TODO: GEN_ERROR Operand can only be variable access
																			}

																			const std::optional<unsigned int> mappedOperation = map_operation_to_unary_operation(unaryOperation.value());
																			allSemanticChecksOk &= mappedOperation.has_value();
																			if (!allSemanticChecksOk) {
																				return;
																			}

																			const syrec::VariableAccess::ptr unaryOperandAsVarAccess = unaryStmtOperand.getAsVariableAccess().value();
																			if (isIdentAssignableOtherwiseLogError(unaryOperandAsVarAccess)){
																				statement.emplace(std::make_shared<syrec::UnaryStatement>(syrec::UnaryStatement(mappedOperation.value(), unaryOperandAsVarAccess)));																			
																			}

																		.)
.


/*-------------------------------------------------------------------------
AssignStatement production
-------------------------------------------------------------------------*/

AssignStatement<. std::optional<syrec::Statement::ptr> &statement .>	(.		SignalEvaluationResult assignStmtLhs;
																				const ExpressionEvaluationResult::ptr assignStmtRhs = createExpressionEvalutionResultContainer();
																				std::optional<syrec_operation::operation> assignOperation;
																				unsigned int expressionBitwidth = 1u;

																				std::optional<syrec::VariableAccess::ptr> assigned_to_obj;
																				bool allSemanticChecksOk = true;
																		.)
=
Signal<assignStmtLhs, false>											(.		allSemanticChecksOk = assignStmtLhs.isValid();
																				if (allSemanticChecksOk){
																					if (!assignStmtLhs.isVariableAccess()) {
																						allSemanticChecksOk = false;
																						// TODO: GEN_ERROR: Lhs operand must be variable access
																					}
																					else {
																						allSemanticChecksOk = isIdentAssignableOtherwiseLogError(assignStmtLhs.getAsVariableAccess().value());
																						expressionBitwidth = assignStmtLhs.getAsVariableAccess().value()->bitwidth();
																					}
																				}
																		.)
(
	"^"																	(.		assignOperation.emplace(syrec_operation::operation::xor_assign);	.)
	| "+"																(.		assignOperation.emplace(syrec_operation::operation::add_assign);	.)
	| "-"																(.		assignOperation.emplace(syrec_operation::operation::minus_assign);	.)
)																		(.		if (!assignOperation.has_value()){
																					// TODO: GEN_ERROR Expected a valid unary operand
																					SemErr(convertErrorMsgToRequiredFormat(InvalidBinaryOperation));
																				}
																		.)
"=" Expression<assignStmtRhs, expressionBitwidth, false>				(.		if (!allSemanticChecksOk || !assignOperation.has_value() || !assignStmtRhs->hasValue()) {
																					return;
																				}

																				// TODO: To not break reversability of operation, check that expression does not contain the assigned to signal 
																				const std::optional<unsigned int> mappedOperation = map_operation_to_assign_operation(assignOperation.value());
																				if (mappedOperation.has_value()) {
																					statement.emplace(std::make_shared<syrec::AssignStatement>(syrec::AssignStatement(assignStmtLhs.getAsVariableAccess().value(),
																																						mappedOperation.value(),
																																						assignStmtRhs->getOrConvertToExpression(expressionBitwidth).value())));
																				}
																		.)		
.

/*-------------------------------------------------------------------------
SwapStatement production
-------------------------------------------------------------------------*/

SwapStatement<. std::optional<syrec::Statement::ptr> &statement .>	(.	SignalEvaluationResult swapMe, swapOther;
																		bool isSwapOperatorDefined = false;
																		bool allSemanticChecksOk = true;
																	.)
=
Signal<swapMe, false>												(.	if (swapMe.isValid() && !swapMe.isVariableAccess()) {
																			allSemanticChecksOk = false;
																			// TODO: GEN_ERROR: Lhs operand must be variable access
																		}
																		allSemanticChecksOk &= isIdentAssignableOtherwiseLogError(swapMe.getAsVariableAccess().value());
																	.)
"<=>"																(.	isSwapOperatorDefined = true;	.)
Signal<swapOther, false>											(.	if (swapOther.isValid() && !swapOther.isVariableAccess()){
																			allSemanticChecksOk = false;
																			// TODO: GEN_ERROR: Lhs operand must be variable access
																		}
																		allSemanticChecksOk &= isIdentAssignableOtherwiseLogError(swapOther.getAsVariableAccess().value());

																		if (!isSwapOperatorDefined || !allSemanticChecksOk)
																			return;

																		const syrec::VariableAccess::ptr lhsOperand = swapMe.getAsVariableAccess().value();
																		const syrec::VariableAccess::ptr rhsOperand = swapOther.getAsVariableAccess().value();

																		size_t lhsNumAccessedDimensions = lhsOperand->indexes.empty() ? lhsOperand->getVar()->dimensions.size() : 1;
																		size_t rhsNumAccessedDimensions = lhsOperand->indexes.empty() ? lhsOperand->getVar()->dimensions.size() : 1;

																		if (lhsNumAccessedDimensions != rhsNumAccessedDimensions) {
																			// TODO: GEN_ERROR: lhs had x dimensions while rhs had y
																			SemErr(convertErrorMsgToRequiredFormat(fmt::format(InvalidSwapNumDimensionsMissmatch, lhsNumAccessedDimensions, rhsNumAccessedDimensions)));
																			allSemanticChecksOk = false;
																		}
																		else if (lhsOperand->indexes.empty() && rhsOperand->indexes.empty()) {
																			// TODO: Check all dimensions match
																			const auto& lhsVariableDimensions = lhsOperand->getVar()->dimensions;
																			const auto& rhsVariableDimensions = rhsOperand->getVar()->dimensions;

																			const size_t numDimensionsToCheck = lhsOperand->getVar()->dimensions.size();
																			bool continueCheck = true;
																			for (size_t dimensionIdx = 0; continueCheck && dimensionIdx < numDimensionsToCheck; ++dimensionIdx) {
																				continueCheck = lhsVariableDimensions.at(dimensionIdx) == rhsVariableDimensions.at(dimensionIdx);
																				if (!continueCheck) {
																					// TODO: GEN_ERROR: Missmatch at dimension i 
																					SemErr(convertErrorMsgToRequiredFormat(fmt::format(InvalidSwapValueForDimensionMissmatch, dimensionIdx, lhsVariableDimensions.at(dimensionIdx), rhsVariableDimensions.at(dimensionIdx))));
																					allSemanticChecksOk = false;
																				}
																			}
																		}

																		if (allSemanticChecksOk) {
																			// TODO: Evaluation of accessed range to correct size
																			size_t lhsBitwidth = lhsOperand->getVar()->bitwidth;
																			size_t rhsBitwidth = rhsOperand->getVar()->bitwidth;

																			// TODO: Safe fetch of loop variable mapping, the statement below could potentially throw
																			// TODO: Overflow check
																			if (lhsOperand->range.has_value()) {
																				lhsBitwidth = (lhsOperand->range.value().second->evaluate(loopVariableMappingLookup) - lhsOperand->range.value().first->evaluate(loopVariableMappingLookup)) + 1;
																			}

																			if (rhsOperand->range.has_value()) {
																				rhsBitwidth = (rhsOperand->range.value().second->evaluate(loopVariableMappingLookup) - rhsOperand->range.value().first->evaluate(loopVariableMappingLookup)) + 1;
																			}

																			if (lhsBitwidth != rhsBitwidth) {
																				// TODO: GEN_ERROR bitwidth does not match
																				SemErr(convertErrorMsgToRequiredFormat(fmt::format(InvalidSwapSignalWidthMissmatch, lhsBitwidth, rhsBitwidth)));
																			}
																			else {
																				statement.emplace(std::make_shared<syrec::SwapStatement>(syrec::SwapStatement(swapMe.getAsVariableAccess().value(),
																																						swapOther.getAsVariableAccess().value())));	
																			}
																		}
																	.)
.


/*-------------------------------------------------------------------------
SkipStatement production
-------------------------------------------------------------------------*/

SkipStatement<. std::optional<syrec::Statement::ptr> &statement .>
=
"skip"															(.	statement.emplace(std::make_shared<syrec::SkipStatement>(syrec::SkipStatement()));	.)
.


/*-------------------------------------------------------------------------
Signal production
-------------------------------------------------------------------------*/

Signal<SignalEvaluationResult &signalAccess, const bool simplifyIfPossible>			(.	std::optional<syrec::VariableAccess::ptr> accessedSignal;
																						const unsigned int defaultIndexExpressionBitwidth = 1u;
																						unsigned int indexExpressionBitwidth = defaultIndexExpressionBitwidth;

																						// TODO: Using global zero_based indexing flag to initialize default value
																						std::size_t accessedDimensionIdx = 0;
																					.)
=
	ident																			(.	const std::string signalIdent = convert_to_uniform_text_format(t->val);
																						if (checkIdentWasDeclaredOrLogError(signalIdent)) {
																							const auto symbolTableEntryForSignal = currSymTabScope->getVariable(signalIdent);
																							if (symbolTableEntryForSignal.has_value() && std::holds_alternative<syrec::Variable::ptr>(symbolTableEntryForSignal.value())) {
																								const syrec::VariableAccess::ptr container = std::make_shared<syrec::VariableAccess>(syrec::VariableAccess());
																								container->setVar(std::get<syrec::Variable::ptr>(symbolTableEntryForSignal.value()));
																								accessedSignal.emplace(container);
																								indexExpressionBitwidth = accessedSignal.value()->bitwidth();
																							}
																						}
																						bool isValidSignalAccess = accessedSignal.has_value();
																						bool indexExpressionsSemanticallyOk = isValidSignalAccess;
																					.)
{"["																				(.	ExpressionEvaluationResult::ptr dimensionExpression = createExpressionEvalutionResultContainer(); .)
	Expression<dimensionExpression, indexExpressionBitwidth, simplifyIfPossible>	(.	indexExpressionsSemanticallyOk &= dimensionExpression->hasValue();
																			
																						if (indexExpressionsSemanticallyOk) {
																							const std::optional<unsigned int> &constantValueForAccessedDimension = dimensionExpression->getAsConstant();
																							if (constantValueForAccessedDimension.has_value()) {
																								// TODO: Using global flag indicating zero_based indexing or not
																								indexExpressionsSemanticallyOk = isValidDimensionAccess(accessedSignal.value()->getVar(), accessedDimensionIdx, constantValueForAccessedDimension.value(), true);

																								if (!indexExpressionsSemanticallyOk) {
																									// TODO: Using global flag indicating zero_based indexing or not
																									const IndexAccessRangeConstraint constraintForCurrentDimension = getConstraintsForValidDimensionAccess(accessedSignal.value()->getVar(), accessedDimensionIdx, true).value();
																									// TODO: GEN_ERROR
																								}
																							}

																							if (indexExpressionsSemanticallyOk) {
																								accessedSignal.value()->indexes.emplace_back(dimensionExpression->getOrConvertToExpression(indexExpressionBitwidth).value());
																							}
																						}
																						accessedDimensionIdx++;
																					.)
"]"		
}																					(.	isValidSignalAccess = indexExpressionsSemanticallyOk;	.)
[																					(.	std::optional<syrec::Number::ptr> bitRangeStart;
																						std::optional<syrec::Number::ptr> bitRangeEnd;
																						bool rangeExplicitlyDefined = false;
																					.)
	"." Number<bitRangeStart, false>									
	[
		":" Number<bitRangeEnd, false>												(.	rangeExplicitlyDefined = true;	.)
	]																				(.	isValidSignalAccess &= bitRangeStart.has_value() && (rangeExplicitlyDefined ? bitRangeEnd.has_value() : true);
																						if (isValidSignalAccess) {
																							const std::pair<syrec::Number::ptr, syrec::Number::ptr> bitRange(bitRangeStart.value(), rangeExplicitlyDefined ? bitRangeEnd.value() : bitRangeStart.value());
																							const std::pair<std::size_t, std::size_t> bitRangeEvaluated(bitRange.first->evaluate({}), bitRange.second->evaluate({}));
																						
																							const syrec::Variable::ptr &accessedVariable = accessedSignal.value()->getVar();
																							if (rangeExplicitlyDefined) {
																								// TODO: Using global zero_based indexing flag
																								if (!isValidBitRangeAccess(accessedVariable, bitRangeEvaluated, true)){
																									isValidSignalAccess = false;
																									// TODO: GEN_ERROR
																								}
																							}
																							else {
																								// TODO: Using global zero_based indexing flag	
																								if (!isValidBitAccess(accessedVariable, bitRangeEvaluated.first, true)){
																									isValidSignalAccess = false;
																									// TODO: GEN_ERROR
																								}
																							}

																							if (isValidSignalAccess) {
																								accessedSignal.value()->range.emplace(bitRange);
																							}
																						}
																					.)
	]																				(.	if (isValidSignalAccess) {
																							signalAccess.updateResultToVariableAccess(accessedSignal.value());
																						}
																					.)
.

/*-------------------------------------------------------------------------
Expressions variants
-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
Expression production
-------------------------------------------------------------------------*/

// TODO: Add flag to indicate whether the given bitwidth should be forced on the expression or the larger of the two should be choosen
Expression<const ExpressionEvaluationResult::ptr &userDefinedExpression, const unsigned int bitwidth, const bool simplifyIfPossible>	(.	SignalEvaluationResult signal;
																																			std::optional<syrec::Number::ptr> number;
																																		.)
=
(
	IF (shouldTakeNumberInsteadOfBinaryAlternative(this)) Number<number, simplifyIfPossible>									(.	if (number.has_value()) {
																																				const syrec::NumericExpression::ptr expr = std::make_shared<syrec::NumericExpression>(syrec::NumericExpression(number.value(), bitwidth));
																																				userDefinedExpression->setResult(expr);
																																			}
																																		.)
	| IF (shouldTakeBinaryInsteadOfShiftAlternative(this)) BinaryExpression<userDefinedExpression, bitwidth, simplifyIfPossible>
	| ShiftExpression<userDefinedExpression, bitwidth, simplifyIfPossible>
)
	| Signal<signal, simplifyIfPossible>																								(.	if (!signal.isValid()) {
																																				return;
																																			}

																																			if (signal.isVariableAccess()) {
																																				userDefinedExpression->setResult(std::make_shared<syrec::VariableExpression>(syrec::VariableExpression(signal.getAsVariableAccess().value())));
																																			}
																																			else if (signal.isConstant()) {
																																				userDefinedExpression->setResult(std::make_shared<syrec::NumericExpression>(syrec::NumericExpression(signal.getAsNumber().value(), bitwidth)));
																																			}
																																		.)
	| UnaryExpression<userDefinedExpression, bitwidth, simplifyIfPossible>
.

/*-------------------------------------------------------------------------
BinaryExpression production
-------------------------------------------------------------------------*/

BinaryExpression<const ExpressionEvaluationResult::ptr &parsedBinaryExpression, const unsigned int bitwidth, const bool simplifyIfPossible>	(.	ExpressionEvaluationResult::ptr binaryExprLhs = createExpressionEvalutionResultContainer();
																																				ExpressionEvaluationResult::ptr binaryExprRhs = createExpressionEvalutionResultContainer();
																																				std::optional<syrec_operation::operation> binaryOperation;
																																				unsigned int expectedBitWidth = bitwidth;
																																			.)	
=
"(" Expression<binaryExprLhs, bitwidth, simplifyIfPossible>																					(.	if (binaryExprLhs->hasValue()) {
																																					expectedBitWidth = std::max(binaryExprLhs->getOrConvertToExpression(std::nullopt).value()->bitwidth(), expectedBitWidth);
																																				}
																																			.)
	(
		"+"																																	(.	binaryOperation.emplace(syrec_operation::operation::addition);	.)
		| "-"																																(.	binaryOperation.emplace(syrec_operation::operation::subtraction);	.)
		| "^"																																(.	binaryOperation.emplace(syrec_operation::operation::bitwise_xor);	.)
		| "*"																																(.	binaryOperation.emplace(syrec_operation::operation::multiplication);	.)
		| "/"																																(.	binaryOperation.emplace(syrec_operation::operation::division);	.)
		| "%"																																(.	binaryOperation.emplace(syrec_operation::operation::modulo);	.)
		| "*>"																																(.	binaryOperation.emplace(syrec_operation::operation::upper_bits_multiplication);	.)
		| "&&"																																(.	binaryOperation.emplace(syrec_operation::operation::logical_and);	.)
		| "||"																																(.	binaryOperation.emplace(syrec_operation::operation::logical_or);	.)
		| "&"																																(.	binaryOperation.emplace(syrec_operation::operation::bitwise_and);	.)
		| "|"																																(.	binaryOperation.emplace(syrec_operation::operation::bitwise_or);	.)
		| "<"																																(.	binaryOperation.emplace(syrec_operation::operation::less_than);	.)
		| ">"																																(.	binaryOperation.emplace(syrec_operation::operation::greater_than);	.)
		| "="																																(.	binaryOperation.emplace(syrec_operation::operation::equals);	.)
		| "!="																																(.	binaryOperation.emplace(syrec_operation::operation::not_equals);	.)
		| "<="																																(.	binaryOperation.emplace(syrec_operation::operation::less_equals);	.)
		| ">="																																(.	binaryOperation.emplace(syrec_operation::operation::greater_equals);	.)
	)																																		(.	if (!binaryOperation.has_value()) {
																																					// TODO: GEN_ERROR Expected one of n possible operands but non was specified
																																				}
																																			.)
	Expression<binaryExprRhs, expectedBitWidth, simplifyIfPossible>																
")"																																			(.	if (binaryExprLhs->hasValue() && binaryOperation.has_value() && binaryExprRhs->hasValue()) {
																																				const std::optional<unsigned int> mappedOperation = map_operation_to_binary_operation(binaryOperation.value());
																																				if (!mappedOperation.has_value()) {
																																					return;
																																				}

																																				if (binaryExprLhs->evaluatedToConstant() && binaryExprRhs->evaluatedToConstant()) {
																																					const unsigned int lhsValueEvaluated = binaryExprLhs->getAsConstant().value();
																																					const unsigned int rhsValueEvaluated = binaryExprRhs->getAsConstant().value();
																																					const std::optional<unsigned int> operationApplicationResult = applyBinaryOperation(binaryOperation.value(), lhsValueEvaluated, rhsValueEvaluated);
																																					if (operationApplicationResult.has_value()) {
																																						parsedBinaryExpression->setResult(operationApplicationResult.value(), expectedBitWidth);
																																					}
																																				}
																																				else {
																																					const syrec::expression::ptr lhsOperand = binaryExprLhs->getOrConvertToExpression(std::nullopt).value();
																																					const syrec::expression::ptr rhsOperand = binaryExprRhs->getOrConvertToExpression(std::nullopt).value();
																																					parsedBinaryExpression->setResult(std::make_shared<syrec::BinaryExpression>(syrec::BinaryExpression(lhsOperand, 
																																																												 mappedOperation.value(),
																																																												 rhsOperand)));
																																				}
																																			}
																																		.)
.


/*-------------------------------------------------------------------------
UnaryExpression production
-------------------------------------------------------------------------*/

UnaryExpression<const ExpressionEvaluationResult::ptr &unaryExpression, const unsigned int bitwidth, const bool simplifyIfPossible>	(.	ExpressionEvaluationResult::ptr unaryExpressionOperand = createExpressionEvalutionResultContainer();
																																		std::optional<syrec_operation::operation> unaryOperation;
																																	.)	
=
(
	"!"																																(.	unaryOperation.emplace(syrec_operation::operation::logical_negation);	.)
	| "~"																															(.	unaryOperation.emplace(syrec_operation::operation::bitwise_negation);	.)
)		
Expression<unaryExpressionOperand, bitwidth, simplifyIfPossible>																	(.	// TODO: Notify user (i.e. via error) that reference parser currently does not support unary statements - we will ignore them for now
																																		return;
																																	.)	
.


/*-------------------------------------------------------------------------
ShiftExpression production
-------------------------------------------------------------------------*/

ShiftExpression<const ExpressionEvaluationResult::ptr &userDefinedShiftExpression, const unsigned int bitwidth, const bool simplifyIfPossible>	(.	ExpressionEvaluationResult::ptr shiftExpressionLhs = createExpressionEvalutionResultContainer();
																																					std::optional<syrec::Number::ptr> shiftAmount;
																																					std::optional<syrec_operation::operation> shiftOperation;
																																				.)
=
"(" Expression<shiftExpressionLhs, bitwidth, simplifyIfPossible> 
(
	"<<"																																		(.	shiftOperation.emplace(syrec_operation::operation::shift_left);	.)
	| ">>"																																		(.	shiftOperation.emplace(syrec_operation::operation::shift_right);	.)
) Number<shiftAmount, simplifyIfPossible>																										(.	if (!shiftExpressionLhs->hasValue() || !shiftOperation.has_value() || !shiftAmount.has_value()) {
																																						return;
																																					}
																																					const std::optional<unsigned int> mappedShiftOperation = map_operation_to_shift_operation(shiftOperation.value());
																																					const syrec::expression::ptr lhsOperandExpression = shiftExpressionLhs->getOrConvertToExpression(bitwidth).value();
																																		
																																					// One could replace the shift statement with a skip statement if the shift amount is zero 
																																					const std::optional<unsigned int> shiftAmountValueEvaluated = evaluateNumberContainer(shiftAmount.value());
																																					const std::optional<unsigned int> lhsOperandValueEvaluated = shiftExpressionLhs->getAsConstant();

																																					if (shiftAmountValueEvaluated.has_value() && lhsOperandValueEvaluated.has_value()) {
																																						const std::optional<unsigned int> shiftApplicationResult = syrec_operation::apply(shiftOperation.value(), lhsOperandValueEvaluated.value(), shiftAmountValueEvaluated.value());
																																						if (shiftApplicationResult.has_value()) {
																																							userDefinedShiftExpression->setResult(shiftApplicationResult.value(), bitwidth);
																																						}
																																						else {
																																							// TODO: GEN_ERROR
																																							return;
																																						}
																																					}
																																					else {
																																						userDefinedShiftExpression->setResult(std::make_shared<syrec::ShiftExpression>(lhsOperandExpression,
																																																									mappedShiftOperation.value(),
																																																									shiftAmount.value()));
																																					}
																																				.)
")"
.

END SyReC.