/*-------------------------------------------------------------------------
ATG for SyReC: A Programming Language for Synthesis of Reversible Circuits
(specification available @ http://www.revlib.org/doc/docu/revlib_2_0_1.pdf)

User manual for Coco/R is available @
https://ssw.jku.at/Research/Projects/Coco/Doc/UserManual.pdf
-------------------------------------------------------------------------*/
$namespace=syrec
/*-- $checkEOF=false --*/

// Place includes here
#include <algorithm>
#include <cwchar>
#include <optional>
#include <set>
#include <stdexcept>
#include <string>
#include <variant>
#include <vector>

#include "core/syrec/module.hpp"
#include "core/syrec/parser/method_call_guess.hpp"
#include "core/syrec/parser/operation.hpp"
#include "core/syrec/parser/parser_error_message_generator.hpp"
#include "core/syrec/parser/range_check.hpp"
#include "core/syrec/parser/signal_evaluation_result.hpp"
#include "core/syrec/parser/symbol_table.hpp"
#include "core/syrec/parser/text_utils.hpp"

COMPILER SyReC

	struct expression_or_constant {
		public:
            explicit expression_or_constant(const unsigned int constant_value) : constant_value(constant_value) ,variants(constant_value)
			{
			}

			// TODO: Add loop variable mapping lookup as constructor parameter
			explicit expression_or_constant(const expression::ptr &expression)
			{
                syrec::expression* referenced_expression = expression.get();
                const NumericExpression* constant_expression = dynamic_cast<NumericExpression*>(referenced_expression);
                if (nullptr != constant_expression && constant_expression->value->isConstant()) {
                    constant_value.emplace(constant_expression->value->evaluate({}));
					variants.emplace<unsigned int>(constant_value.value());
                }
				else {
					variants.emplace<expression::ptr>(expression);
				}
			}
				
			[[nodiscard]] bool is_constant() const {
                return constant_value.has_value();
			}

			[[nodiscard]] unsigned int get_constant_value() const {
                if (!is_constant()) {
                    throw std::logic_error("TODO x");
                }
                return constant_value.value();
			}

			[[nodiscard]] expression::ptr get_expression() const {
                if (is_constant()) {
                    throw std::logic_error("TODO a");
                }
				return std::get<expression::ptr>(variants);
			}

			[[nodiscard]] expression::ptr convert_to_expression(const unsigned int bitwidth) const {
				if (is_constant()) {
					const Number::ptr &constant_value_wrapper = std::make_shared<syrec::Number>(get_constant_value());
					return std::make_shared<NumericExpression>(constant_value_wrapper, bitwidth);
				}
				else {
					return std::get<expression::ptr>(variants);	
				}
			}
			
		private:
            std::optional<unsigned int> constant_value;
			std::variant<expression::ptr, unsigned int> variants;
	};

	typedef std::optional<expression_or_constant> expression_evaluation_result;

	// Place declarations of objects referenced in this ATG
	Module::vec modules;
	parser_error_message_generator error_message_generator;
	SymbolTable::ptr currSymTabScope;

	Number::loop_variable_mapping loop_variable_mapping_lookup;

	// This method will be called by the contructor if it exits.
	// This support is specific to the C++ version of Coco/R.
	void Init() {
		// nothing to do
		SymbolTable::openScope(currSymTabScope);
	}

	// Uncomment this method if cleanup is necessary,
	// this method will be called by the destructor if it exists.
	// This support is specific to the C++ version of Coco/R.
	// void Destroy() {
		// nothing to do
	// }

	[[nodiscard]] bool are_token_values_equal(const wchar_t *my_token_value, const wchar_t *other_token_value) const {
		if (my_token_value == nullptr || other_token_value == nullptr) {
			// TODO: Could also throw exception
			return false;
		}
		return !wcscmp(my_token_value, other_token_value);
	}

	[[nodiscard]] bool token_matches_one_of(const Token *tokenToCheck, std::vector<std::wstring> one_of_many_token_values) const {
        const std::set<std::wstring> set_of_matching_token_values{std::begin(one_of_many_token_values), std::end(one_of_many_token_values)};
        return set_of_matching_token_values.count(tokenToCheck->val);
	}

	[[nodiscard]] bool find_matching_token(std::vector<std::wstring> matching_token_values, std::vector<std::wstring> token_values_allowing_stop_of_search) const {
		const std::set<std::wstring> set_of_matching_token_values { std::begin(matching_token_values), std::end(matching_token_values) };
		const std::set<std::wstring> set_of_token_values_allowing_stop_of_search { std::begin(token_values_allowing_stop_of_search), std::end(token_values_allowing_stop_of_search) };
		bool found_matching_operator = false;
		bool can_cancel_search = false;

		while (!can_cancel_search) {
			const Token *peeked_token = scanner->Peek();
			found_matching_operator = set_of_matching_token_values.count(peeked_token->val);
			can_cancel_search = found_matching_operator || peeked_token->kind == _EOF || set_of_token_values_allowing_stop_of_search.count(peeked_token->val);
		}
		return found_matching_operator;
	}

	[[nodiscard]] bool check_if_is_assign_statement() const {
		const std::vector<std::wstring> matching_tokens = {L"^", L"+", L"-"};
		const std::vector<std::wstring> tokens_resulting_in_check_being_false = {L";", L"<=>"};

		return find_matching_token(matching_tokens, tokens_resulting_in_check_being_false);
	}

	[[nodiscard]] bool check_if_expression_is_binary_expression() const {
		// Since first LL(1) conflict resolver already started peeking and failed to resolve the conflict, we need to reset the peek position to original one
		scanner->ResetPeek();

		const std::set<std::wstring> tokens_resulting_in_check_being_false {L"+", L"-", L"^", L"*", L"/", L"%", L"*>", L"&&", L"||", L"&", L"|", L"<", L">", L"=", L"!=", L"<=", L">="};
		const std::set<std::wstring> set_of_operator_token_values_of_alternative {L"<<", L">>"};

		bool found_matching_operator = false;
		bool can_cancel_search = false;
		int expression_nesting_level = 0;

		while (!can_cancel_search) {
			const Token *peeked_token = scanner->Peek();

			if (are_token_values_equal(peeked_token->val, L"(")) {
				expression_nesting_level++;
			} 
			else if (are_token_values_equal(peeked_token->val, L")")) {
				expression_nesting_level--;
			}
			else {
				found_matching_operator = expression_nesting_level == 0 && tokens_resulting_in_check_being_false.count(peeked_token->val);
				can_cancel_search = found_matching_operator || set_of_operator_token_values_of_alternative.count(peeked_token->val) || peeked_token->kind == _EOF;			
			}

		}
		return found_matching_operator;
	}

	[[nodiscard]] bool is_token_not_nested_number(const Token *token) const {
		if (token == nullptr) {
			return false;
		}
		return token->kind == _int || are_token_values_equal(token->val, L"#") || are_token_values_equal(token->val, L"$");
	}
		
	[[nodiscard]] bool check_if_expression_is_number(const Token *first_token_of_expression) const {
        bool found_matching_operator;
        const std::vector<std::wstring> matching_tokens = {L"^", L"+", L"-", L"*"};

        if (are_token_values_equal(first_token_of_expression->val, L"(")) {
            found_matching_operator = check_if_expression_is_number(scanner->Peek())
                && token_matches_one_of(scanner->Peek(), matching_tokens)
                && check_if_expression_is_number(scanner->Peek())
                && are_token_values_equal(scanner->Peek()->val, L")");
        } else {
            found_matching_operator = is_token_not_nested_number(first_token_of_expression);
        }
        return found_matching_operator;
	}

	[[nodiscard]] bool check_if_expression_is_number() const {
        return la != nullptr && check_if_expression_is_number(la);
	}

	[[nodiscard]] bool check_if_loop_variable_is_defined() const {
		// Since first LL(1) conflict resolver already started peeking and failed to resolve the conflict, we need to reset the peek position to original one
		scanner->ResetPeek();
		const std::vector<std::wstring> matching_tokens = {L"="};
		const std::vector<std::wstring> tokens_resulting_in_check_being_false = {L"rof"};

		return find_matching_token(matching_tokens, tokens_resulting_in_check_being_false);
	}

	[[nodiscard]] bool check_if_loop_iteration_range_start_is_defined() const {
		const std::vector<std::wstring> matching_tokens = {L"to"};
		const std::vector<std::wstring> tokens_resulting_in_check_being_false = {L"rof"};

		return find_matching_token(matching_tokens, tokens_resulting_in_check_being_false);
	}

	[[nodiscard]] std::optional<unsigned int> convert_token_value_to_number(const Token &token) {
		std::optional<unsigned int> token_as_number;
		try {
			token_as_number.emplace(std::stoul(convert_to_uniform_text_format(token.val)));
		} 
		catch (std::invalid_argument const &ex) {
			// TODO: GEN_ERROR
		}
		catch (std::out_of_range const &ex) {
			// TODO: GEN_ERROR
		}
		return token_as_number;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_assign_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::add_assign:
				mapping_result.emplace(AssignStatement::Add);
				break;
			case syrec_operation::operation::minus_assign:
				mapping_result.emplace(AssignStatement::Subtract);
				break;
			case syrec_operation::operation::xor_assign:
				mapping_result.emplace(AssignStatement::Exor);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_unary_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::increment_assign:
				mapping_result.emplace(UnaryStatement::Increment);
				break;
			case syrec_operation::operation::decrement_assign:
				mapping_result.emplace(UnaryStatement::Decrement);
				break;
			case syrec_operation::operation::negate_assign:
				mapping_result.emplace(UnaryStatement::Invert);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_shift_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::shift_left:
				mapping_result.emplace(ShiftExpression::Left);
				break;
			case syrec_operation::operation::shift_right:
				mapping_result.emplace(ShiftExpression::Right);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_binary_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::addition:
				mapping_result.emplace(BinaryExpression::Add);
				break;
			case syrec_operation::operation::subtraction:
				mapping_result.emplace(BinaryExpression::Subtract);
				break;
				case syrec_operation::operation::multiplication:
				mapping_result.emplace(BinaryExpression::Multiply);
				break;		
			case syrec_operation::operation::division:
				mapping_result.emplace(BinaryExpression::Divide);
				break;			
			case syrec_operation::operation::modulo:
				mapping_result.emplace(BinaryExpression::Modulo);
				break;		
			case syrec_operation::operation::upper_bits_multiplication:
				mapping_result.emplace(BinaryExpression::FracDivide);
				break;		
			case syrec_operation::operation::bitwise_xor:
				mapping_result.emplace(BinaryExpression::Exor);
				break;		
			case syrec_operation::operation::logical_and:
				mapping_result.emplace(BinaryExpression::LogicalAnd);
				break;		
			case syrec_operation::operation::logical_or:
				mapping_result.emplace(BinaryExpression::LogicalOr);
				break;		
			case syrec_operation::operation::bitwise_and:
				mapping_result.emplace(BinaryExpression::BitwiseAnd);
				break;	
			case syrec_operation::operation::bitwise_or:
				mapping_result.emplace(BinaryExpression::BitwiseOr);
				break;	
			case syrec_operation::operation::less_than:
				mapping_result.emplace(BinaryExpression::LessThan);
				break;	
			case syrec_operation::operation::greater_than:
				mapping_result.emplace(BinaryExpression::GreaterThan);
				break;	
			case syrec_operation::operation::equals:
				mapping_result.emplace(BinaryExpression::Equals);
				break;		
			case syrec_operation::operation::not_equals:
				mapping_result.emplace(BinaryExpression::NotEquals);
				break;		
			case syrec_operation::operation::less_equals:
				mapping_result.emplace(BinaryExpression::LessEquals);
				break;		
			case syrec_operation::operation::greater_equals:
				mapping_result.emplace(BinaryExpression::GreaterEquals);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	bool check_ident_was_declared(const std::string &ident) const {
		if (!currSymTabScope->contains(ident)) {
			// TOOD: GEN_ERROR
			return false;
		}
		return true;
	}

	[[nodiscard]] static std::optional<unsigned int> get_value_if_expression_is_constant(const expression_evaluation_result &expression){
		std::optional<unsigned int> constant_value;
		if (expression.has_value() && expression.value().is_constant()) {
			constant_value.emplace(expression.value().get_constant_value());
		}
		return constant_value;
	}

	// TODO: Generate error/s in case of exceptions
	[[nodiscard]] std::optional<unsigned int> apply_unary_operation(const syrec_operation::operation operation, const Number::ptr &left_operand) const {
		std::optional<unsigned int> operation_result;
		try {
			operation_result.emplace(syrec_operation::apply(operation, left_operand->evaluate(loop_variable_mapping_lookup)));
		}
		catch (std::overflow_error &err) {
		
		}
		catch(std::invalid_argument &err) {
		
		}
        return operation_result;
	}

	// TODO: Generate error/s in case of exceptions
	[[nodiscard]] static std::optional<unsigned int> apply_binary_operation(const syrec_operation::operation operation, const unsigned int &left_operand, const unsigned int &right_operand) {
		std::optional<unsigned int> operation_result;
		try {
			operation_result.emplace(syrec_operation::apply(operation, left_operand, right_operand));
		}
		catch (std::overflow_error &err) {
		
		}
		catch(std::invalid_argument &err) {
		
		}
        return operation_result;
	}

	[[nodiscard]] std::optional<unsigned int> evaluate_number_container_to_constant(const Number::ptr &number_container) const {
		std::optional<unsigned int> value_of_number_container;
		if (number_container->isLoopVariable()) {
			const std::string &loop_variable_name = number_container->variableName();
			if (loop_variable_mapping_lookup.find(loop_variable_name) == loop_variable_mapping_lookup.end()) {
				// TODO: GEN_ERROR
			}
			else {
				value_of_number_container.emplace(number_container->evaluate(loop_variable_mapping_lookup));
			}
		}
		else {
			value_of_number_container.emplace(number_container->evaluate(loop_variable_mapping_lookup));
		}
		return value_of_number_container;
	}

/*-------------------------------------------------------------------------*/

CHARACTERS
	letter		= 'A' .. 'Z' + 'a' .. 'z'.
	digit		= '0' .. '9'.

	cr        = '\r'.
	lf        = '\n'.
	tab       = '\t'.

TOKENS
	ident		= ('_' | letter) {('_' | letter | digit)}.
	int			= digit {digit}.
	
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/
PRODUCTIONS


/*-------------------------------------------------------------------------
Number production

Since Coco/R does not accept recursive token definitions, 
we redefine the token 'Number as a non-terminal symbol
-------------------------------------------------------------------------*/
// TODO: Current data structure does not handle negative numbers well, one migitation could be to use the two-complement representation (which would require to update the calculation for many operations (i.e. division, etc.))
// TODO: Currently synthesis uses ident without '$' prefix for its loop mappings
// TODO: For now no loop variable mappings will get added to the lookup (since currently no support for iterating a list of statements is supported)

Number<. std::optional<Number::ptr> &parsed_number, bool simplify_if_possible .>									
=
int																			(.	const std::optional<unsigned int> conversion_result = convert_token_value_to_number(*t);
																				if (conversion_result.has_value()) {
																					const Number::ptr result = std::make_shared<syrec::Number>(syrec::Number(conversion_result.value())); 
																					parsed_number.emplace(result);
																				}
																			.)
| '#' ident																	(.	const std::string signal_ident = convert_to_uniform_text_format(t->val);
																				if (check_ident_was_declared(signal_ident)) {
																					const auto &symbol_table_entry = currSymTabScope->getVariable(signal_ident);
																					if (symbol_table_entry.has_value() && std::holds_alternative<Variable::ptr>(symbol_table_entry.value())) {
																						parsed_number.emplace(std::make_shared<syrec::Number>(syrec::Number(std::get<Variable::ptr>(symbol_table_entry.value())->bitwidth)));
																					}
																					else {
																						// TODO: GEN_ERROR, this should not happen but check anyways
																					}
																				}
																			.)
| '$' ident																	(.	const std::string signal_ident = convert_to_uniform_text_format(t->val);
																				if (check_ident_was_declared(signal_ident)) {
																					const auto &symbol_table_entry = currSymTabScope->getVariable(signal_ident);
																					if (symbol_table_entry.has_value() && std::holds_alternative<Number::ptr>(symbol_table_entry.value())) {
																						parsed_number.emplace(std::get<Number::ptr>(symbol_table_entry.value()));
																					}
																					else {
																						// TODO: GEN_ERROR, this should not happen but check anyways
																					}
																				}
																			.)
| (																			(.	std::optional<Number::ptr> lhs_operand, rhs_operand;  
																				std::optional<syrec_operation::operation> op;
																			.)
	'(' 
		Number<lhs_operand, simplify_if_possible>
		('+'																(.	op.emplace(syrec_operation::operation::addition);		.)
		|'-'																(.	op.emplace(syrec_operation::operation::subtraction);	.)
		|'*'																(.	op.emplace(syrec_operation::operation::multiplication);	.)
		|'/'																(.	op.emplace(syrec_operation::operation::division);		.)
		) 
		Number<rhs_operand, simplify_if_possible>							(.	if (op.has_value() && lhs_operand.has_value() && rhs_operand.has_value()){
																					const std::optional<unsigned int> lhs_value = evaluate_number_container_to_constant(lhs_operand.value());
																					const std::optional<unsigned int> rhs_value = evaluate_number_container_to_constant(rhs_operand.value());

																					if (lhs_value.has_value() && rhs_value.has_value()) {
																						const std::optional<unsigned int> op_result = apply_binary_operation(op.value(),
																																							lhs_operand.value()->evaluate(loop_variable_mapping_lookup),
																																							rhs_operand.value()->evaluate(loop_variable_mapping_lookup));
																						if (op_result.has_value()) {
																							const Number::ptr result = std::make_shared<syrec::Number>(syrec::Number(op_result.value())); 
																							parsed_number.emplace(result);
																						}
																					}
																				}
																			.)
	')'																	
)
.

/*-------------------------------------------------------------------------
Program and Modules
-------------------------------------------------------------------------*/

SyReC										(.	std::optional<Module::ptr> module;	.)
=
Module<module>								(.	if (module.has_value()) {
													currSymTabScope->addEntry(module.value());
													this->modules.emplace_back(module.value());
												}
											.)
{											(.	module.reset();	.)
	Module<module>							(.	if (module.has_value()) {
													const Module::ptr well_formed_module = module.value();
													if (currSymTabScope->contains(well_formed_module)) {
														// TODO: GEN_ERROR 
														// TODO: Do not cancel parsing	
													}
													else {
														currSymTabScope->addEntry(well_formed_module);
														this->modules.emplace_back(module.value());
													}
												}
											.)
}
.

/*-------------------------------------------------------------------------
Module production
-------------------------------------------------------------------------*/

Module <. std::optional<Module::ptr> &parsed_module	.>			(.	SymbolTable::openScope(currSymTabScope);
																	std::optional<std::vector<Variable::ptr>> locals;	
																	bool valid_module_definition = false;
																	Statement::vec module_body {};
																.)	
=
"module" ident													(.	const std::string module_name = convert_to_uniform_text_format(t->val);	
																	Module::ptr user_defined_module = std::make_shared<syrec::Module>(syrec::Module(module_name));
																.)	
"(" [ParameterList<valid_module_definition, user_defined_module>] ")" 
{
	SignalList<locals>											(.	valid_module_definition &= locals.has_value();	.)
}														
StatementList<module_body>										(.	SymbolTable::closeScope(currSymTabScope);
																	if (module_body.empty()) {
																		valid_module_definition = false;
																		// TODO: GEN_ERROR
																	}

																	if (valid_module_definition) {
																		user_defined_module->variables = locals.value_or(std::vector<Variable::ptr>{});
																		for (const auto &statement : module_body) {
																			user_defined_module->addStatement(statement);
																		}
																		parsed_module.emplace(user_defined_module);
																	}
																.)
.


/*-------------------------------------------------------------------------
ParameterList production
-------------------------------------------------------------------------*/

ParameterList<bool &is_valid_module_definition, const Module::ptr &module>			(.	std::optional<Variable::ptr> parameter;	.)
=
Parameter<parameter>																(.	is_valid_module_definition = parameter.has_value();
																						if (is_valid_module_definition) {
																							module->addParameter(parameter.value());
																							currSymTabScope->addEntry(parameter.value());
																						}
																					.)
{																					(.	parameter.reset();	.)
	"," Parameter<parameter>														(.	is_valid_module_definition = parameter.has_value();
																						if (is_valid_module_definition) {	
																							const Variable::ptr &well_formed_parameter = parameter.value();
																							if (!currSymTabScope->contains(well_formed_parameter->name)) {
																								module->addParameter(well_formed_parameter);
																								currSymTabScope->addEntry(well_formed_parameter);
																							}
																							else {
																								is_valid_module_definition = false;
																								// TODO: GEN_ERROR 
																							}
																						}
																					.)
}															
.


/*-------------------------------------------------------------------------
Parameter production
-------------------------------------------------------------------------*/

Parameter<. std::optional<Variable::ptr> &parameter .>								(.	Variable::Types parameter_type = Variable::Wire;
																						bool valid_variable_type = true;
																					.)	
= 
(
	"in"																			(.	parameter_type = Variable::In;	.)
	| "out"																			(.	parameter_type = Variable::Out;	.)
	| "inout"																		(.	parameter_type = Variable::Inout;	.)	
)																					(.	if (Variable::Wire == parameter_type) {
																							// TODO: GEN_ERROR 
																							// TODO: Do not cancel parsing
																							valid_variable_type = false;
																						}
																					.)
SignalDeclaration<parameter_type, parameter>										(.	if (!valid_variable_type) {
																							parameter.reset();
																						}
																					.)
.

/*-------------------------------------------------------------------------
SignalList production
-------------------------------------------------------------------------*/

SignalList <. std::optional<std::vector<Variable::ptr>> &signals .>	(.	Variable::Types signal_type = Variable::In;
																		std::optional<Variable::ptr> declared_signal;
																		bool valid_signal_type = true;
																		std::vector<Variable::ptr> valid_signal_declarations;
																	.)
=
(
	"wire"															(.	signal_type = Variable::Wire;		.)
	| "signal"														(.	signal_type = Variable::State;		.)
)																	(.	if (Variable::Wire != signal_type && Variable::State != signal_type) {
																			// TODO: GEN_ERROR ?
																			// TODO: Do not cancel parsing
																			valid_signal_type = false;
																		}
																	.)
SignalDeclaration<signal_type, declared_signal>						(.	if (valid_signal_type && declared_signal.has_value()) {
																			const Variable::ptr &valid_signal_declaration = declared_signal.value();
																			if (currSymTabScope->contains(valid_signal_declaration->name)) {
																				// TODO: GEN_ERROR 
																				// TODO: Do not cancel parsing
																			}
																			else {
																				valid_signal_declarations.emplace_back(valid_signal_declaration);
																				currSymTabScope->addEntry(valid_signal_declaration);
																			}
																		}
																	.)
{																	(.	declared_signal.reset();			.)	
	"," SignalDeclaration<signal_type, declared_signal>				(.	if (valid_signal_type && declared_signal.has_value()) {
																			const Variable::ptr &valid_signal_declaration = declared_signal.value();
																			if (currSymTabScope->contains(valid_signal_declaration->name)) {
																				// TODO: GEN_ERROR 
																				// TODO: Do not cancel parsing
																			}
																			else {
																				valid_signal_declarations.emplace_back(valid_signal_declaration);
																				currSymTabScope->addEntry(valid_signal_declaration);
																			}
																		}
																	.)
}																	(.	if (valid_signal_declarations.size()){
																			signals.emplace(valid_signal_declarations);
																		}
																	.)
.


/*-------------------------------------------------------------------------
SignalDeclaration production
-------------------------------------------------------------------------*/

SignalDeclaration<. Variable::Types variable_type, std::optional<Variable::ptr> &declared_signal .>			(.	std::vector<unsigned int> dimensions{};
																												// TODO: Use default bit width
																												unsigned int signal_width = 0;	
																												bool valid_declaration = true;
																											.)
=
ident																										(.	const std::string signal_ident = convert_to_uniform_text_format(t->val);	.)
{"[" 
	int																										(.	const std::optional<unsigned int> dimension = convert_token_value_to_number(*t);
																												if (!dimension.has_value()) {
																													valid_declaration = false;
																													// TODO: GEN_ERROR
																												}
																												else {
																													dimensions.emplace_back(dimension.value());	
																												}
																											.)
"]"}																									
["(" 
	int																									(.	const std::optional<unsigned int> user_defined_signal_width = convert_token_value_to_number(*t);
																											if (!user_defined_signal_width.has_value()) {
																												// TODO: GEN_ERROR
																												valid_declaration = false;
																											}
																											else {
																												signal_width = user_defined_signal_width.value();
																											}
																										.)
")"]																									(.	// TODO: What if no dimensions is specified, add default dimension entry ?
																											if (valid_declaration) {
																												declared_signal.emplace(std::make_shared<Variable>(Variable(variable_type, signal_ident, dimensions, signal_width)));
																											}
																										.)	
.

/*-------------------------------------------------------------------------
Statement variants
-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
StatementList
-------------------------------------------------------------------------*/

// TODO: Add check that every call statement has its matching counterpart, no uncall can be made before its corresponding call was called
StatementList<. Statement::vec &statements .>								(.	std::optional<Statement::ptr> user_defined_statement;	.)
=
Statement<user_defined_statement>											(.	if (user_defined_statement.has_value()) {
																					statements.emplace_back(user_defined_statement.value());
																				}
																			.)
{																			(.	user_defined_statement.reset();	.)	
	";" Statement<user_defined_statement>									(.	if (user_defined_statement.has_value()) {
																					statements.emplace_back(user_defined_statement.value());
																				}
																			.)
}
.


/*-------------------------------------------------------------------------
Statement production
-------------------------------------------------------------------------*/

Statement<. std::optional<Statement::ptr> &user_defined_statement .>
=
CallStatement<user_defined_statement>
| ForStatement<user_defined_statement>
| IfStatement<user_defined_statement>
| UnaryStatement<user_defined_statement>
| SkipStatement<user_defined_statement>
| IF (check_if_is_assign_statement()) AssignStatement<user_defined_statement>
| SwapStatement<user_defined_statement>
.


/*-------------------------------------------------------------------------
CallStatement production
-------------------------------------------------------------------------*/

// TODO: Are aliases between the formal and actual parameters necessary (i.e. in a call statement should the parameter be replaced with the actual value)
CallStatement<. std::optional<Statement::ptr> &statement .>							(.	std::optional<bool> isCallStatement;
																						std::vector<std::string> calleeArguments {};
																						std::size_t numActualParameters = 0;
																						bool isValidCallOperation = true;
																					.)
=
(
	"call"																			(.	isCallStatement.emplace(true);	.)
	| "uncall"																		(.	isCallStatement.emplace(false);	.)
)																					(.	isValidCallOperation = isCallStatement.has_value();	.)
ident																				(.	std::string methodIdent = convert_to_uniform_text_format(t->val);
																						MethodCallGuess::ptr guessesForPossibleCall = std::make_shared<MethodCallGuess>(MethodCallGuess(currSymTabScope, methodIdent));
																						if (!guessesForPossibleCall->hasSomeMatches()) {
																							// TODO: GEN_ERROR no method for ident declared
																							isValidCallOperation = false;
																						}
																					.)
"(" 
	ident																			(.	std::string parameterIdent = convert_to_uniform_text_format(t->val);
																						isValidCallOperation &= check_ident_was_declared(parameterIdent);

																						if (isValidCallOperation) {
																							const std::optional<std::variant<Variable::ptr, Number::ptr>> paramSymTabEntry = currSymTabScope->getVariable(parameterIdent);
																							isValidCallOperation = paramSymTabEntry.has_value() && std::holds_alternative<Variable::ptr>(paramSymTabEntry.value());

																							if (isValidCallOperation) {
																								guessesForPossibleCall->refineWithNextParameter(std::get<Variable::ptr>(paramSymTabEntry.value()));
																								calleeArguments.emplace_back(parameterIdent);
																							}
																							else {
																								// TODO: GEN_ERROR Declared identifier was not a variable (but a loop variable)
																							}
																						}
																						else {
																							// TODO: GEN_ERROR Use of undeclared identifier
																						}
																						numActualParameters++;
																					.)
	{
		"," ident																	(.	std::string parameterIdent = convert_to_uniform_text_format(t->val);
																						isValidCallOperation &= check_ident_was_declared(parameterIdent);

																						if (isValidCallOperation) {
																							const std::optional<std::variant<Variable::ptr, Number::ptr>> paramSymTabEntry = currSymTabScope->getVariable(parameterIdent);
																							isValidCallOperation = paramSymTabEntry.has_value() && std::holds_alternative<Variable::ptr>(paramSymTabEntry.value());

																							if (isValidCallOperation) {
																								guessesForPossibleCall->refineWithNextParameter(std::get<Variable::ptr>(paramSymTabEntry.value()));
																								calleeArguments.emplace_back(parameterIdent);
																							}
																							else {
																								// TODO: GEN_ERROR Declared identifier was not a variable (but a loop variable)
																							}
																						}
																						else {
																							// TODO: GEN_ERROR Use of undeclared identifier
																						}
																						numActualParameters++;
																					.)
	}																
")"																					(.	if (!isValidCallOperation){
																							return;
																						}

																						if (!guessesForPossibleCall->hasSomeMatches()) {
																							return;		
																						}
																						
																						guessesForPossibleCall->discardGuessesWithMoreThanNParameters(numActualParameters);
																						if (!guessesForPossibleCall->hasSomeMatches()) {
																							// TODO: GEN_ERROR All of the declared methods that matched had more than n parameters
																							return;
																						}

																						Module::vec possibleCalls = guessesForPossibleCall->getMatchesForGuess().value();
																						if (possibleCalls.size() > 1) {
																							// TODO: GEN_ERROR Ambiguous call, more than one match for current setups
																							return;
																						}
																						const Module::ptr matchingModuleForCall = possibleCalls.at(0);
																						if (isCallStatement.value()) {
																							statement.emplace(std::make_shared<syrec::CallStatement>(syrec::CallStatement(matchingModuleForCall, calleeArguments)));
																						}
																						else {
																							statement.emplace(std::make_shared<syrec::UncallStatement>(syrec::UncallStatement(matchingModuleForCall, calleeArguments)));
																						}
																					.)
.


/*-------------------------------------------------------------------------
ForStatement production
-------------------------------------------------------------------------*/

// TODO: Currently no negative numbers are supported
ForStatement<. std::optional<Statement::ptr> &statement .>								(.	std::optional<std::string> loop_variable_ident;
																							std::optional<Number::ptr> iteration_range_start;
																							std::optional<Number::ptr> iteration_range_end;
																							std::optional<Number::ptr> custom_step_size;
																							bool negative_step_size = false;
																							Statement::vec loop_body{};
																							bool explicit_range_start_defined = false;
																							bool explicit_step_size_defined = false;
																						.)
=
"for" 
[IF (check_if_loop_iteration_range_start_is_defined()) (
	[
		IF (check_if_loop_variable_is_defined()) (
			"$" ident																	(.	const std::string &loop_var_ident = convert_to_uniform_text_format(t->val);
																							if (!check_ident_was_declared(loop_var_ident)) {
																								loop_variable_ident.emplace(convert_to_uniform_text_format(t->val));
																								SymbolTable::openScope(currSymTabScope);
																								const Number::ptr loop_variable_entry = std::make_shared<syrec::Number>(syrec::Number(loop_var_ident));
																								currSymTabScope->addEntry(loop_variable_entry);
																							}
																						.)
			"="
		)
	] 
	Number<iteration_range_start, false>												(.	explicit_range_start_defined = true;	.)
	"to"
)] 
Number<iteration_range_end, false>														(.	if (!explicit_range_start_defined){
																								iteration_range_start = iteration_range_end;
																							}
																						.)
["step"																					(.	explicit_step_size_defined = true;	.)
	[	"-"																				(.	negative_step_size = true;	.)
	] 
Number<custom_step_size, false>															(.	if (custom_step_size.has_value() && !custom_step_size.value()->evaluate({})) {
																								// TODO: GEN_ERROR step size cannot be zero ?
																							}
																						.)		
]																						(.	if (!explicit_step_size_defined) {
																								custom_step_size.emplace(std::make_shared<syrec::Number>(syrec::Number(1)));
																							}

																							bool valid_loop_header = loop_variable_ident.has_value() 
																															&& (explicit_range_start_defined ? iteration_range_start.has_value() : true)
																															&& iteration_range_end.has_value()
																															&& (explicit_step_size_defined ? custom_step_size.has_value() : true);
																							if (valid_loop_header) {
																								const unsigned int iteration_range_start_value = iteration_range_start.value()->evaluate({});
																								const unsigned int iteration_range_end_value = iteration_range_end.value()->evaluate({});
																								const unsigned int step_size = custom_step_size.value()->evaluate({});

																								unsigned int num_iterations;
																								if ((negative_step_size && iteration_range_end_value > iteration_range_start_value)
																									|| (!negative_step_size && iteration_range_start_value > iteration_range_end_value)
																									|| !step_size) {
																									// TODO: Either generate error or warning
																									num_iterations = 0;	
																									valid_loop_header = false;
																								}
																								else {
																									num_iterations = negative_step_size 
																										? (iteration_range_start_value - iteration_range_end_value)
																										: (iteration_range_end_value - iteration_range_start_value);
																									num_iterations = (num_iterations + 1) / step_size;
																								}
																							}
																						.)
"do" 
StatementList<loop_body>																(.	if (loop_body.empty()) {
																								// TODO: GEN_ERROR
																							}
																						.)
"rof"																					(.	if (loop_variable_ident.has_value()) {
																								SymbolTable::closeScope(currSymTabScope);
																							}

																							// TODO: If a statement must be generated, one could create a skip statement instead of simply returning 
																							if (!valid_loop_header || loop_body.empty()) {
																								return;
																							}

																							const std::shared_ptr<syrec::ForStatement> loop_statement = std::make_shared<syrec::ForStatement>(syrec::ForStatement());
																							loop_statement->loopVariable = loop_variable_ident.value();
																							loop_statement->range = std::pair(iteration_range_start.value(), iteration_range_end.value());
																							loop_statement->step = custom_step_size.value();
																							loop_statement->statements = loop_body;
																							statement.emplace(loop_statement);
																						.)
.

/*-------------------------------------------------------------------------
IfStatement production
-------------------------------------------------------------------------*/

IfStatement<. std::optional<Statement::ptr> &statement .>		(.	expression_evaluation_result condition;
																	expression_evaluation_result closing_condition;
																	Statement::vec true_branch{};
																	Statement::vec false_branch{};
																.)	
=
"if" Expression<condition, 1u, false> 
"then" 
StatementList<true_branch> 
"else" StatementList<false_branch>
"fi" Expression<closing_condition, 1u, false>					(.	// TODO: Add check that condition and closing_condition match
																	const bool conditional_well_formed = condition.has_value() 
																		&& closing_condition.has_value()
																		&& !true_branch.empty()
																		&& !false_branch.empty();
																	if (!conditional_well_formed) {
																		return;
																	}
															
																	const std::shared_ptr<syrec::IfStatement> &conditional = std::make_shared<syrec::IfStatement>(syrec::IfStatement());
																	conditional->condition = condition.value().convert_to_expression(1u);
																	conditional->fiCondition = closing_condition.value().convert_to_expression(1u);
																	conditional->thenStatements                    = true_branch;
																	conditional->elseStatements                    = false_branch;
																	statement.emplace(conditional);
																.)
.

/*-------------------------------------------------------------------------
UnaryStatement production
-------------------------------------------------------------------------*/

UnaryStatement<. std::optional<Statement::ptr> &statement .>			(.	SignalEvaluationResult unaryStmtOperand;
																			std::optional<syrec_operation::operation> unaryOperation;	
																		.)
=
(
	"~"																	(.	unaryOperation.emplace(syrec_operation::operation::negate_assign);	.)
	| "++"																(.	unaryOperation.emplace(syrec_operation::operation::increment_assign);	.)
	| "--"																(.	unaryOperation.emplace(syrec_operation::operation::decrement_assign);	.)
) 
"=" Signal<unaryStmtOperand, false>										(.	bool allSemanticChecksOk = true;
																			if (!unaryOperation.has_value()){
																				allSemanticChecksOk = false;
																				// TODO: GEN_ERROR Expected a valid unary operand
																			}
																			if (unaryStmtOperand.isValid() && !unaryStmtOperand.isVariableAccess()) {
																				allSemanticChecksOk = false;
																				// TODO: GEN_ERROR Operand can only be variable access
																			}

																			const std::optional<unsigned int> mappedOperation = map_operation_to_unary_operation(unaryOperation.value());
																			allSemanticChecksOk &= mappedOperation.has_value();
																			if (!allSemanticChecksOk) {
																				return;
																			}

																			const VariableAccess::ptr unaryOperandAsVarAccess = unaryStmtOperand.getAsVariableAccess().value();
																			statement.emplace(std::make_shared<syrec::UnaryStatement>(syrec::UnaryStatement(mappedOperation.value(), unaryOperandAsVarAccess)));
																		.)
.


/*-------------------------------------------------------------------------
AssignStatement production
-------------------------------------------------------------------------*/

AssignStatement<. std::optional<Statement::ptr> &statement .>	(.		SignalEvaluationResult assignStmtLhs;
																		expression_evaluation_result assignStmtRhs;
																		std::optional<syrec_operation::operation> assignOperation;
																		unsigned int expressionBitwidth = 1u;

																		std::optional<VariableAccess::ptr> assigned_to_obj;
																		bool allSemanticChecksOk = true;
																.)
=
Signal<assignStmtLhs, false>									(.		allSemanticChecksOk = assignStmtLhs.isValid();
																		if (allSemanticChecksOk){
																			if (!assignStmtLhs.isVariableAccess()) {
																				allSemanticChecksOk = false;
																				// TODO: GEN_ERROR: Lhs operand must be variable access
																			}
																			else {
																				expressionBitwidth = assignStmtLhs.getAsVariableAccess().value()->bitwidth();
																			}
																		}
																.)
(
	"^"															(.		assignOperation.emplace(syrec_operation::operation::xor_assign);	.)
	| "+"														(.		assignOperation.emplace(syrec_operation::operation::add_assign);	.)
	| "-"														(.		assignOperation.emplace(syrec_operation::operation::minus_assign);	.)
)					
"=" Expression<assignStmtRhs, expressionBitwidth, false>		(.		if (!allSemanticChecksOk || !assignOperation.has_value() || !assignStmtRhs.has_value()) {
																			return;
																		}

																		// TODO: To not break reversability of operation, check that expression does not contain the assigned to signal 
																		const std::optional<unsigned int> mappedOperation = map_operation_to_assign_operation(assignOperation.value());
																		if (mappedOperation.has_value()) {
																			statement.emplace(std::make_shared<syrec::AssignStatement>(syrec::AssignStatement(assignStmtLhs.getAsVariableAccess().value(),
																																				mappedOperation.value(),
																																				assignStmtRhs.value().convert_to_expression(expressionBitwidth))));
																		}
																.)		
.

/*-------------------------------------------------------------------------
SwapStatement production
-------------------------------------------------------------------------*/

SwapStatement<. std::optional<Statement::ptr> &statement .>			(.	SignalEvaluationResult swapMe, swapOther;
																		bool isSwapOperatorDefined = false;
																	.)
=
Signal<swapMe, false> 
"<=>"																(.	isSwapOperatorDefined = true;	.)
Signal<swapOther, false>											(.	bool allSemanticChecksOk = true;
																		if (swapMe.isValid() && !swapMe.isVariableAccess()) {
																			allSemanticChecksOk = false;
																			// TODO: GEN_ERROR: Lhs operand must be variable access
																		}
																		if (swapOther.isValid() && !swapOther.isVariableAccess()){
																			allSemanticChecksOk = false;
																			// TODO: GEN_ERROR: Lhs operand must be variable access
																		}

																		if (isSwapOperatorDefined && allSemanticChecksOk) {
																			statement.emplace(std::make_shared<syrec::SwapStatement>(syrec::SwapStatement(swapMe.getAsVariableAccess().value(),
																																						 swapOther.getAsVariableAccess().value())));
																		}
																	.)
.


/*-------------------------------------------------------------------------
SkipStatement production
-------------------------------------------------------------------------*/

SkipStatement<. std::optional<Statement::ptr> &statement .>
=
"skip"															(.	statement.emplace(std::make_shared<syrec::SkipStatement>(syrec::SkipStatement()));	.)
.


/*-------------------------------------------------------------------------
Signal production
-------------------------------------------------------------------------*/

Signal<SignalEvaluationResult &signalAccess, const bool simplifyIfPossible>			(.	std::optional<VariableAccess::ptr> accessedSignal;
																						const unsigned int defaultIndexExpressionBitwidth = 1u;
																						unsigned int indexExpressionBitwidth = defaultIndexExpressionBitwidth;

																						// TODO: Using global zero_based indexing flag to initialize default value
																						std::size_t accessedDimensionIdx = 0;
																					.)
=
	ident																			(.	const std::string signalIdent = convert_to_uniform_text_format(t->val);
																						if (check_ident_was_declared(signalIdent)) {
																							const auto symbolTableEntryForSignal = currSymTabScope->getVariable(signalIdent);
																							if (symbolTableEntryForSignal.has_value() && std::holds_alternative<Variable::ptr>(symbolTableEntryForSignal.value())) {
																								const VariableAccess::ptr container = std::make_shared<VariableAccess>(VariableAccess());
																								container->setVar(std::get<Variable::ptr>(symbolTableEntryForSignal.value()));
																								accessedSignal.emplace(container);
																								indexExpressionBitwidth = accessedSignal.value()->bitwidth();
																							}
																						}
																						bool isValidSignalAccess = accessedSignal.has_value();
																						bool indexExpressionsSemanticallyOk = isValidSignalAccess;
																					.)
{"["																				(.	expression_evaluation_result dimensionExpression; .)
	Expression<dimensionExpression, indexExpressionBitwidth, simplifyIfPossible>	(.	indexExpressionsSemanticallyOk &= dimensionExpression.has_value();
																			
																						if (indexExpressionsSemanticallyOk) {
																							const std::optional<unsigned int> &constantValueForAccessedDimension = get_value_if_expression_is_constant(dimensionExpression);
																							if (constantValueForAccessedDimension.has_value()) {
																								// TODO: Using global flag indicating zero_based indexing or not
																								indexExpressionsSemanticallyOk = range_check::isValidDimensionAccess(accessedSignal.value()->getVar(), constantValueForAccessedDimension.value(), true);

																								if (!indexExpressionsSemanticallyOk) {
																									// TODO: Using global flag indicating zero_based indexing or not
																									const range_check::IndexAccessRangeConstraint constraintForCurrentDimension = range_check::getConstraintsForValidDimensionAccess(accessedSignal.value()->getVar(), accessedDimensionIdx, true).value();
																									// TODO: GEN_ERROR
																								}
																							}

																							if (indexExpressionsSemanticallyOk) {
																								accessedSignal.value()->indexes.emplace_back(dimensionExpression.value().convert_to_expression(indexExpressionBitwidth));
																							}
																						}
																						accessedDimensionIdx++;
																					.)
"]"		
}																					(.	isValidSignalAccess = indexExpressionsSemanticallyOk;	.)
[																					(.	std::optional<Number::ptr> bitRangeStart;
																						std::optional<Number::ptr> bitRangeEnd;
																						bool rangeExplicitlyDefined = false;
																					.)
	"." Number<bitRangeStart, false>									
	[
		":" Number<bitRangeEnd, false>												(.	rangeExplicitlyDefined = true;	.)
	]																				(.	isValidSignalAccess &= bitRangeStart.has_value() && (rangeExplicitlyDefined ? bitRangeEnd.has_value() : true);
																						if (isValidSignalAccess) {
																							const std::pair<Number::ptr, Number::ptr> bitRange(bitRangeStart.value(), rangeExplicitlyDefined ? bitRangeEnd.value() : bitRangeStart.value());
																							const std::pair<std::size_t, std::size_t> bitRangeEvaluated(bitRange.first->evaluate({}), bitRange.second->evaluate({}));
																						
																							const Variable::ptr &accessedVariable = accessedSignal.value()->getVar();
																							if (rangeExplicitlyDefined) {
																								// TODO: Using global zero_based indexing flag
																								if (!range_check::isValidBitRangeAccess(accessedVariable, bitRangeEvaluated, true)){
																									isValidSignalAccess = false;
																									// TODO: GEN_ERROR
																								}
																							}
																							else {
																								// TODO: Using global zero_based indexing flag	
																								if (!range_check::isValidBitAccess(accessedVariable, bitRangeEvaluated.first, true)){
																									isValidSignalAccess = false;
																									// TODO: GEN_ERROR
																								}
																							}

																							if (isValidSignalAccess) {
																								accessedSignal.value()->range.emplace(bitRange);
																							}
																						}
																					.)
	]																				(.	if (isValidSignalAccess) {
																							signalAccess.updateResultToVariableAccess(accessedSignal.value());
																						}
																					.)
.

/*-------------------------------------------------------------------------
Expressions variants
-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
Expression production
-------------------------------------------------------------------------*/

Expression<expression_evaluation_result &userDefinedExpression, unsigned int bitwidth, bool simplifyIfPossible>		(.	SignalEvaluationResult signal;
																														std::optional<Number::ptr> number;
																													.)
=
(
	IF (check_if_expression_is_number()) Number<number, simplifyIfPossible>										(.	if (number.has_value()) {
																															userDefinedExpression.emplace(std::make_shared<NumericExpression>(NumericExpression(number.value(), bitwidth)));
																														}
																													.)
	| IF (check_if_expression_is_binary_expression()) BinaryExpression<userDefinedExpression, bitwidth, simplifyIfPossible>
	| ShiftExpression<userDefinedExpression, bitwidth, simplifyIfPossible>
)
	| Signal<signal, simplifyIfPossible>																			(.	if (!signal.isValid()) {
																															return;
																														}

																														if (signal.isVariableAccess()) {
																															userDefinedExpression.emplace(std::make_shared<VariableExpression>(VariableExpression(signal.getAsVariableAccess().value())));
																														}
																														else if (signal.isConstant()) {
																															userDefinedExpression.emplace(std::make_shared<NumericExpression>(NumericExpression(signal.getAsNumber().value(), bitwidth)));
																														}
																													.)
	| UnaryExpression<userDefinedExpression, bitwidth, simplifyIfPossible>
.

/*-------------------------------------------------------------------------
BinaryExpression production
-------------------------------------------------------------------------*/

BinaryExpression<expression_evaluation_result &user_defined_binary_expression, unsigned int bitwidth, bool simplify_if_possible>	(.	expression_evaluation_result binary_expr_lhs;
																																		expression_evaluation_result binary_expr_rhs;
																																		std::optional<syrec_operation::operation> binary_operation;
																																		unsigned int operands_bitwidth = 0u;
																																	.)	
=
"(" Expression<binary_expr_lhs, bitwidth, simplify_if_possible>																		(.	if (binary_expr_lhs.has_value()) {
																																			operands_bitwidth = std::max(binary_expr_lhs->convert_to_expression(bitwidth)->bitwidth(), bitwidth);
																																		}
																																	.)
	(
		"+"																											(.	binary_operation.emplace(syrec_operation::operation::addition);	.)
		| "-"																										(.	binary_operation.emplace(syrec_operation::operation::subtraction);	.)
		| "^"																										(.	binary_operation.emplace(syrec_operation::operation::bitwise_xor);	.)
		| "*"																										(.	binary_operation.emplace(syrec_operation::operation::multiplication);	.)
		| "/"																										(.	binary_operation.emplace(syrec_operation::operation::division);	.)
		| "%"																										(.	binary_operation.emplace(syrec_operation::operation::modulo);	.)
		| "*>"																										(.	binary_operation.emplace(syrec_operation::operation::upper_bits_multiplication);	.)
		| "&&"																										(.	binary_operation.emplace(syrec_operation::operation::logical_and);	.)
		| "||"																										(.	binary_operation.emplace(syrec_operation::operation::logical_or);	.)
		| "&"																										(.	binary_operation.emplace(syrec_operation::operation::bitwise_and);	.)
		| "|"																										(.	binary_operation.emplace(syrec_operation::operation::bitwise_or);	.)
		| "<"																										(.	binary_operation.emplace(syrec_operation::operation::less_than);	.)
		| ">"																										(.	binary_operation.emplace(syrec_operation::operation::greater_than);	.)
		| "="																										(.	binary_operation.emplace(syrec_operation::operation::equals);	.)
		| "!="																										(.	binary_operation.emplace(syrec_operation::operation::not_equals);	.)
		| "<="																										(.	binary_operation.emplace(syrec_operation::operation::less_equals);	.)
		| ">="																										(.	binary_operation.emplace(syrec_operation::operation::greater_equals);	.)
	) 
	Expression<binary_expr_rhs, operands_bitwidth, simplify_if_possible>																
")"																													(.	
																														if (binary_expr_lhs.has_value() && binary_operation.has_value() && binary_expr_rhs.has_value()) {
																															const std::optional<unsigned int> mapped_operation = map_operation_to_binary_operation(binary_operation.value());
																															if (mapped_operation.has_value()) {
																																if (binary_expr_lhs->is_constant() && binary_expr_rhs->is_constant()) {
																																	const unsigned int binary_expr_lhs_value = binary_expr_lhs->get_constant_value();
																																	const unsigned int binary_expr_rhs_value = binary_expr_rhs->get_constant_value();
																																	const std::optional<unsigned int> evaluation_result = apply_binary_operation(binary_operation.value(),
																																													binary_expr_lhs_value, binary_expr_rhs_value);
																																	if (evaluation_result.has_value()) {
																																		user_defined_binary_expression.emplace(evaluation_result.value());
																																	}
																																}
																																else {
																																	const expression::ptr lhs_operand = binary_expr_lhs->convert_to_expression(operands_bitwidth);
																																	const expression::ptr rhs_operand = binary_expr_rhs->convert_to_expression(operands_bitwidth);
																																	user_defined_binary_expression.emplace(std::make_shared<syrec::BinaryExpression>(syrec::BinaryExpression(lhs_operand,
																																						mapped_operation.value(),
																																						rhs_operand)));
																																}
																															}
																														}
																													.)
.


/*-------------------------------------------------------------------------
UnaryExpression production
-------------------------------------------------------------------------*/

UnaryExpression<expression_evaluation_result &unary_expression, unsigned int bitwidth, bool simplify_if_possible>	(.	expression_evaluation_result unary_expression_operand;
																														std::optional<syrec_operation::operation> unary_operation;
																													.)
=
(
	"!"																												(.	unary_operation.emplace(syrec_operation::operation::logical_negation);	.)
	| "~"																											(.	unary_operation.emplace(syrec_operation::operation::bitwise_negation);	.)
)		
Expression<unary_expression_operand, bitwidth, simplify_if_possible>												(.	if (unary_operation.has_value() && unary_expression_operand.has_value()){
																															// TODO:
																														}

																														// TODO: Notify user (i.e. via error) that reference parser currently does not support unary statements - we will ignore them for now
																													.)	
.


/*-------------------------------------------------------------------------
ShiftExpression production
-------------------------------------------------------------------------*/

ShiftExpression<expression_evaluation_result &user_defined_shift_expression, unsigned int bitwidth, bool simplify_if_possible>	(.	expression_evaluation_result shift_expression_lhs;
																																	std::optional<Number::ptr> shift_amount;
																																	std::optional<syrec_operation::operation> shift_operation;
																																.)
=
"(" Expression<shift_expression_lhs, bitwidth, simplify_if_possible> 
(
	"<<"																														(.	shift_operation.emplace(syrec_operation::operation::shift_left);	.)
	| ">>"																														(.	shift_operation.emplace(syrec_operation::operation::shift_right);	.)
) Number<shift_amount, simplify_if_possible>																					(.	if (shift_expression_lhs.has_value() && shift_operation.has_value() && shift_amount.has_value()) {
																																		const std::optional<unsigned int> mapped_shift_operation = map_operation_to_shift_operation(shift_operation.value());
																																		const expression::ptr lhs_operand_expression = shift_expression_lhs.value().convert_to_expression(bitwidth);
																																		
																																		// One could replace the shift statement with a skip statement if the shift amount is zero 
																																		const std::optional<unsigned int> shift_amount_value_evaluated = evaluate_number_container_to_constant(shift_amount.value());
																																		if (shift_amount_value_evaluated.has_value() && shift_expression_lhs.value().is_constant()) {
																																			const unsigned int shift_operand_lhs_value = shift_expression_lhs.value().get_constant_value();
																																			const std::optional<unsigned int> shift_application_result = syrec_operation::apply(shift_operation.value(), 
																																																								shift_operand_lhs_value,
																																																								shift_amount_value_evaluated.value());
																															
																																			if (shift_application_result.has_value()) {
																																				user_defined_shift_expression.emplace(expression_or_constant(shift_application_result.value()));
																																			}
																																			else {
																																				// TODO: GEN_ERROR
																																				return;
																																			}
																																		}
																																		else {
																																			const expression::ptr lhs_operand_expression = shift_expression_lhs.value().convert_to_expression(bitwidth);
																																			user_defined_shift_expression.emplace(std::make_shared<syrec::ShiftExpression>(lhs_operand_expression,
																																																	mapped_shift_operation.value(),
																																																	shift_amount.value()));
																																		}
																																	}
																																.)
")"
.

END SyReC.