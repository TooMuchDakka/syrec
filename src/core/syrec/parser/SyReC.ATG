/*-------------------------------------------------------------------------
ATG for SyReC: A Programming Language for Synthesis of Reversible Circuits
(specification available @ http://www.revlib.org/doc/docu/revlib_2_0_1.pdf)

User manual for Coco/R is available @
https://ssw.jku.at/Research/Projects/Coco/Doc/UserManual.pdf
-------------------------------------------------------------------------*/
$namespace=syrec
/*-- $checkEOF=false --*/

// Place includes here
#include <algorithm>
#include <cwchar>
#include <optional>
#include <set>
#include <stdexcept>
#include <string>
#include <variant>
#include <vector>

#include "core/syrec/module.hpp"
#include "core/syrec/parser/method_call_guess.hpp"
#include "core/syrec/parser/operation.hpp"
#include "core/syrec/parser/parser_error_message_generator.hpp"
#include "core/syrec/parser/range_check.hpp"
#include "core/syrec/parser/symbol_table.hpp"
#include "core/syrec/parser/text_utils.hpp"

COMPILER SyReC

	struct expression_or_constant {
		public:
            explicit expression_or_constant(const unsigned int constant_value) : constant_value(constant_value) ,variants(constant_value)
			{
			}

			// TODO: Add loop variable mapping lookup as constructor parameter
			explicit expression_or_constant(const expression::ptr &expression)
			{
                syrec::expression* referenced_expression = expression.get();
                const NumericExpression* constant_expression = dynamic_cast<NumericExpression*>(referenced_expression);
                if (nullptr != constant_expression && constant_expression->value->isConstant()) {
                    constant_value.emplace(constant_expression->value->evaluate({}));
					variants.emplace<unsigned int>(constant_value.value());
                }
				else {
					variants.emplace<expression::ptr>(expression);
				}
			}
				
			[[nodiscard]] bool is_constant() const {
                return constant_value.has_value();
			}

			[[nodiscard]] unsigned int get_constant_value() const {
                if (!is_constant()) {
                    throw std::logic_error("TODO x");
                }
                return constant_value.value();
			}

			[[nodiscard]] expression::ptr get_expression() const {
                if (is_constant()) {
                    throw std::logic_error("TODO a");
                }
				return std::get<expression::ptr>(variants);
			}

			[[nodiscard]] expression::ptr convert_to_expression(const unsigned int bitwidth) const {
				if (is_constant()) {
					const Number::ptr &constant_value_wrapper = std::make_shared<syrec::Number>(get_constant_value());
					return std::make_shared<NumericExpression>(constant_value_wrapper, bitwidth);
				}
				else {
					return std::get<expression::ptr>(variants);	
				}
			}
			
		private:
            std::optional<unsigned int> constant_value;
			std::variant<expression::ptr, unsigned int> variants;
	};

	typedef std::optional<std::variant<VariableAccess::ptr, Number::ptr>> signal_evaluation_result;
	typedef std::optional<expression_or_constant> expression_evaluation_result;

	// Place declarations of objects referenced in this ATG
	Module::vec modules;
	parser_error_message_generator error_message_generator;
	symbol_table::ptr current_symbol_table_scope;

	Number::loop_variable_mapping loop_variable_mapping_lookup;

	// This method will be called by the contructor if it exits.
	// This support is specific to the C++ version of Coco/R.
	void Init() {
		// nothing to do
		symbol_table::open_scope(current_symbol_table_scope);
	}

	// Uncomment this method if cleanup is necessary,
	// this method will be called by the destructor if it exists.
	// This support is specific to the C++ version of Coco/R.
	// void Destroy() {
		// nothing to do
	// }

	[[nodiscard]] bool are_token_values_equal(const wchar_t *my_token_value, const wchar_t *other_token_value) const {
		if (my_token_value == nullptr || other_token_value == nullptr) {
			// TODO: Could also throw exception
			return false;
		}
		return !wcscmp(my_token_value, other_token_value);
	}

	[[nodiscard]] bool token_matches_one_of(const Token *tokenToCheck, std::vector<std::wstring> one_of_many_token_values) const {
        const std::set<std::wstring> set_of_matching_token_values{std::begin(one_of_many_token_values), std::end(one_of_many_token_values)};
        return set_of_matching_token_values.count(tokenToCheck->val);
	}

	[[nodiscard]] bool find_matching_token(std::vector<std::wstring> matching_token_values, std::vector<std::wstring> token_values_allowing_stop_of_search) const {
		const std::set<std::wstring> set_of_matching_token_values { std::begin(matching_token_values), std::end(matching_token_values) };
		const std::set<std::wstring> set_of_token_values_allowing_stop_of_search { std::begin(token_values_allowing_stop_of_search), std::end(token_values_allowing_stop_of_search) };
		bool found_matching_operator = false;
		bool can_cancel_search = false;

		while (!can_cancel_search) {
			const Token *peeked_token = scanner->Peek();
			found_matching_operator = set_of_matching_token_values.count(peeked_token->val);
			can_cancel_search = found_matching_operator || peeked_token->kind == _EOF || set_of_token_values_allowing_stop_of_search.count(peeked_token->val);
		}
		return found_matching_operator;
	}

	[[nodiscard]] bool check_if_is_assign_statement() const {
		const std::vector<std::wstring> matching_tokens = {L"^", L"+", L"-"};
		const std::vector<std::wstring> tokens_resulting_in_check_being_false = {L";", L"<=>"};

		return find_matching_token(matching_tokens, tokens_resulting_in_check_being_false);
	}

	[[nodiscard]] bool check_if_expression_is_binary_expression() const {
		// Since first LL(1) conflict resolver already started peeking and failed to resolve the conflict, we need to reset the peek position to original one
		scanner->ResetPeek();

		const std::set<std::wstring> tokens_resulting_in_check_being_false {L"+", L"-", L"^", L"*", L"/", L"%", L"*>", L"&&", L"||", L"&", L"|", L"<", L">", L"=", L"!=", L"<=", L">="};
		const std::set<std::wstring> set_of_operator_token_values_of_alternative {L"<<", L">>"};

		bool found_matching_operator = false;
		bool can_cancel_search = false;
		int expression_nesting_level = 0;

		while (!can_cancel_search) {
			const Token *peeked_token = scanner->Peek();

			if (are_token_values_equal(peeked_token->val, L"(")) {
				expression_nesting_level++;
			} 
			else if (are_token_values_equal(peeked_token->val, L")")) {
				expression_nesting_level--;
			}
			else {
				found_matching_operator = expression_nesting_level == 0 && tokens_resulting_in_check_being_false.count(peeked_token->val);
				can_cancel_search = found_matching_operator || set_of_operator_token_values_of_alternative.count(peeked_token->val) || peeked_token->kind == _EOF;			
			}

		}
		return found_matching_operator;
	}

	[[nodiscard]] bool is_token_not_nested_number(const Token *token) const {
		if (token == nullptr) {
			return false;
		}
		return token->kind == _int || are_token_values_equal(token->val, L"#") || are_token_values_equal(token->val, L"$");
	}
		
	[[nodiscard]] bool check_if_expression_is_number(const Token *first_token_of_expression) const {
        bool found_matching_operator;
        const std::vector<std::wstring> matching_tokens = {L"^", L"+", L"-", L"*"};

        if (are_token_values_equal(first_token_of_expression->val, L"(")) {
            found_matching_operator = check_if_expression_is_number(scanner->Peek())
                && token_matches_one_of(scanner->Peek(), matching_tokens)
                && check_if_expression_is_number(scanner->Peek())
                && are_token_values_equal(scanner->Peek()->val, L")");
        } else {
            found_matching_operator = is_token_not_nested_number(first_token_of_expression);
        }
        return found_matching_operator;
	}

	[[nodiscard]] bool check_if_expression_is_number() const {
        return la != nullptr && check_if_expression_is_number(la);
	}

	[[nodiscard]] bool check_if_loop_variable_is_defined() const {
		// Since first LL(1) conflict resolver already started peeking and failed to resolve the conflict, we need to reset the peek position to original one
		scanner->ResetPeek();
		const std::vector<std::wstring> matching_tokens = {L"="};
		const std::vector<std::wstring> tokens_resulting_in_check_being_false = {L"rof"};

		return find_matching_token(matching_tokens, tokens_resulting_in_check_being_false);
	}

	[[nodiscard]] bool check_if_loop_iteration_range_start_is_defined() const {
		const std::vector<std::wstring> matching_tokens = {L"to"};
		const std::vector<std::wstring> tokens_resulting_in_check_being_false = {L"rof"};

		return find_matching_token(matching_tokens, tokens_resulting_in_check_being_false);
	}

	[[nodiscard]] std::optional<unsigned int> convert_token_value_to_number(const Token &token) {
		std::optional<unsigned int> token_as_number;
		try {
			token_as_number.emplace(std::stoul(convert_to_uniform_text_format(token.val)));
		} 
		catch (std::invalid_argument const &ex) {
			// TODO: GEN_ERROR
		}
		catch (std::out_of_range const &ex) {
			// TODO: GEN_ERROR
		}
		return token_as_number;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_assign_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::add_assign:
				mapping_result.emplace(AssignStatement::Add);
				break;
			case syrec_operation::operation::minus_assign:
				mapping_result.emplace(AssignStatement::Subtract);
				break;
			case syrec_operation::operation::xor_assign:
				mapping_result.emplace(AssignStatement::Exor);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_unary_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::increment_assign:
				mapping_result.emplace(UnaryStatement::Increment);
				break;
			case syrec_operation::operation::decrement_assign:
				mapping_result.emplace(UnaryStatement::Decrement);
				break;
			case syrec_operation::operation::negate_assign:
				mapping_result.emplace(UnaryStatement::Invert);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_shift_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::shift_left:
				mapping_result.emplace(ShiftExpression::Left);
				break;
			case syrec_operation::operation::shift_right:
				mapping_result.emplace(ShiftExpression::Right);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	[[nodiscard]] static std::optional<unsigned int> map_operation_to_binary_operation(const syrec_operation::operation operation) {
		std::optional<unsigned int> mapping_result;
		switch (operation) {
			case syrec_operation::operation::addition:
				mapping_result.emplace(BinaryExpression::Add);
				break;
			case syrec_operation::operation::subtraction:
				mapping_result.emplace(BinaryExpression::Subtract);
				break;
				case syrec_operation::operation::multiplication:
				mapping_result.emplace(BinaryExpression::Multiply);
				break;		
			case syrec_operation::operation::division:
				mapping_result.emplace(BinaryExpression::Divide);
				break;			
			case syrec_operation::operation::modulo:
				mapping_result.emplace(BinaryExpression::Modulo);
				break;		
			case syrec_operation::operation::upper_bits_multiplication:
				mapping_result.emplace(BinaryExpression::FracDivide);
				break;		
			case syrec_operation::operation::bitwise_xor:
				mapping_result.emplace(BinaryExpression::Exor);
				break;		
			case syrec_operation::operation::logical_and:
				mapping_result.emplace(BinaryExpression::LogicalAnd);
				break;		
			case syrec_operation::operation::logical_or:
				mapping_result.emplace(BinaryExpression::LogicalOr);
				break;		
			case syrec_operation::operation::bitwise_and:
				mapping_result.emplace(BinaryExpression::BitwiseAnd);
				break;	
			case syrec_operation::operation::bitwise_or:
				mapping_result.emplace(BinaryExpression::BitwiseOr);
				break;	
			case syrec_operation::operation::less_than:
				mapping_result.emplace(BinaryExpression::LessThan);
				break;	
			case syrec_operation::operation::greater_than:
				mapping_result.emplace(BinaryExpression::GreaterThan);
				break;	
			case syrec_operation::operation::equals:
				mapping_result.emplace(BinaryExpression::Equals);
				break;		
			case syrec_operation::operation::not_equals:
				mapping_result.emplace(BinaryExpression::NotEquals);
				break;		
			case syrec_operation::operation::less_equals:
				mapping_result.emplace(BinaryExpression::LessEquals);
				break;		
			case syrec_operation::operation::greater_equals:
				mapping_result.emplace(BinaryExpression::GreaterEquals);
				break;
			default:
				// TODO: GEN_ERROR ?
				break;
		}
		return mapping_result;
	}

	bool check_ident_was_declared(const std::string &ident) const {
		if (!current_symbol_table_scope->contains(ident)) {
			// TOOD: GEN_ERROR
			return false;
		}
		return true;
	}

	[[nodiscard]] static std::optional<unsigned int> get_value_if_expression_is_constant(const expression_evaluation_result &expression){
		std::optional<unsigned int> constant_value;
		if (expression.has_value() && expression.value().is_constant()) {
			constant_value.emplace(expression.value().get_constant_value());
		}
		return constant_value;
	}

	// TODO: Generate error/s in case of exceptions
	[[nodiscard]] std::optional<unsigned int> apply_unary_operation(const syrec_operation::operation operation, const Number::ptr &left_operand) const {
		std::optional<unsigned int> operation_result;
		try {
			operation_result.emplace(syrec_operation::apply(operation, left_operand->evaluate(loop_variable_mapping_lookup)));
		}
		catch (std::overflow_error &err) {
		
		}
		catch(std::invalid_argument &err) {
		
		}
        return operation_result;
	}

	// TODO: Generate error/s in case of exceptions
	[[nodiscard]] static std::optional<unsigned int> apply_binary_operation(const syrec_operation::operation operation, const unsigned int &left_operand, const unsigned int &right_operand) {
		std::optional<unsigned int> operation_result;
		try {
			operation_result.emplace(syrec_operation::apply(operation, left_operand, right_operand));
		}
		catch (std::overflow_error &err) {
		
		}
		catch(std::invalid_argument &err) {
		
		}
        return operation_result;
	}

	[[nodiscard]] std::optional<unsigned int> evaluate_number_container_to_constant(const Number::ptr &number_container) const {
		std::optional<unsigned int> value_of_number_container;
		if (number_container->isLoopVariable()) {
			const std::string &loop_variable_name = number_container->variableName();
			if (loop_variable_mapping_lookup.find(loop_variable_name) == loop_variable_mapping_lookup.end()) {
				// TODO: GEN_ERROR
			}
			else {
				value_of_number_container.emplace(number_container->evaluate(loop_variable_mapping_lookup));
			}
		}
		else {
			value_of_number_container.emplace(number_container->evaluate(loop_variable_mapping_lookup));
		}
		return value_of_number_container;
	}

/*-------------------------------------------------------------------------*/

CHARACTERS
	letter		= 'A' .. 'Z' + 'a' .. 'z'.
	digit		= '0' .. '9'.

	cr        = '\r'.
	lf        = '\n'.
	tab       = '\t'.

TOKENS
	ident		= ('_' | letter) {('_' | letter | digit)}.
	int			= digit {digit}.
	
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/
PRODUCTIONS


/*-------------------------------------------------------------------------
Number production

Since Coco/R does not accept recursive token definitions, 
we redefine the token 'Number as a non-terminal symbol
-------------------------------------------------------------------------*/
// TODO: Current data structure does not handle negative numbers well, one migitation could be to use the two-complement representation (which would require to update the calculation for many operations (i.e. division, etc.))
// TODO: Currently synthesis uses ident without '$' prefix for its loop mappings
// TODO: For now no loop variable mappings will get added to the lookup (since currently no support for iterating a list of statements is supported)

Number<. std::optional<Number::ptr> &parsed_number, bool simplify_if_possible .>									
=
int																			(.	const std::optional<unsigned int> conversion_result = convert_token_value_to_number(*t);
																				if (conversion_result.has_value()) {
																					const Number::ptr result = std::make_shared<syrec::Number>(syrec::Number(conversion_result.value())); 
																					parsed_number.emplace(result);
																				}
																			.)
| '#' ident																	(.	const std::string signal_ident = convert_to_uniform_text_format(t->val);
																				if (check_ident_was_declared(signal_ident)) {
																					const auto &symbol_table_entry = current_symbol_table_scope->get_variable(signal_ident);
																					if (symbol_table_entry.has_value() && std::holds_alternative<Variable::ptr>(symbol_table_entry.value())) {
																						parsed_number.emplace(std::make_shared<syrec::Number>(syrec::Number(std::get<Variable::ptr>(symbol_table_entry.value())->bitwidth)));
																					}
																					else {
																						// TODO: GEN_ERROR, this should not happen but check anyways
																					}
																				}
																			.)
| '$' ident																	(.	const std::string signal_ident = convert_to_uniform_text_format(t->val);
																				if (check_ident_was_declared(signal_ident)) {
																					const auto &symbol_table_entry = current_symbol_table_scope->get_variable(signal_ident);
																					if (symbol_table_entry.has_value() && std::holds_alternative<Number::ptr>(symbol_table_entry.value())) {
																						parsed_number.emplace(std::get<Number::ptr>(symbol_table_entry.value()));
																					}
																					else {
																						// TODO: GEN_ERROR, this should not happen but check anyways
																					}
																				}
																			.)
| (																			(.	std::optional<Number::ptr> lhs_operand, rhs_operand;  
																				std::optional<syrec_operation::operation> op;
																			.)
	'(' 
		Number<lhs_operand, simplify_if_possible>
		('+'																(.	op.emplace(syrec_operation::operation::addition);		.)
		|'-'																(.	op.emplace(syrec_operation::operation::subtraction);	.)
		|'*'																(.	op.emplace(syrec_operation::operation::multiplication);	.)
		|'/'																(.	op.emplace(syrec_operation::operation::division);		.)
		) 
		Number<rhs_operand, simplify_if_possible>							(.	if (op.has_value() && lhs_operand.has_value() && rhs_operand.has_value()){
																					const std::optional<unsigned int> lhs_value = evaluate_number_container_to_constant(lhs_operand.value());
																					const std::optional<unsigned int> rhs_value = evaluate_number_container_to_constant(rhs_operand.value());

																					if (lhs_value.has_value() && rhs_value.has_value()) {
																						const std::optional<unsigned int> op_result = apply_binary_operation(op.value(),
																																							lhs_operand.value()->evaluate(loop_variable_mapping_lookup),
																																							rhs_operand.value()->evaluate(loop_variable_mapping_lookup));
																						if (op_result.has_value()) {
																							const Number::ptr result = std::make_shared<syrec::Number>(syrec::Number(op_result.value())); 
																							parsed_number.emplace(result);
																						}
																					}
																				}
																			.)
	')'																	
)
.

/*-------------------------------------------------------------------------
Program and Modules
-------------------------------------------------------------------------*/

SyReC										(.	std::optional<Module::ptr> module;	.)
=
Module<module>								(.	if (module.has_value()) {
													current_symbol_table_scope->add_entry(module.value());
													this->modules.emplace_back(module.value());
												}
											.)
{											(.	module.reset();	.)
	Module<module>							(.	if (module.has_value()) {
													const Module::ptr well_formed_module = module.value();
													if (current_symbol_table_scope->contains(well_formed_module)) {
														// TODO: GEN_ERROR 
														// TODO: Do not cancel parsing	
													}
													else {
														current_symbol_table_scope->add_entry(well_formed_module);
														this->modules.emplace_back(module.value());
													}
												}
											.)
}
.

/*-------------------------------------------------------------------------
Module production
-------------------------------------------------------------------------*/

Module <. std::optional<Module::ptr> &parsed_module	.>			(.	symbol_table::open_scope(current_symbol_table_scope);
																	std::optional<std::vector<Variable::ptr>> locals;	
																	bool valid_module_definition = false;
																	Statement::vec module_body {};
																.)	
=
"module" ident													(.	const std::string module_name = convert_to_uniform_text_format(t->val);	
																	Module::ptr user_defined_module = std::make_shared<syrec::Module>(syrec::Module(module_name));
																.)	
"(" [ParameterList<valid_module_definition, user_defined_module>] ")" 
{
	SignalList<locals>											(.	valid_module_definition &= locals.has_value();	.)
}														
StatementList<module_body>										(.	symbol_table::close_scope(current_symbol_table_scope);
																	if (module_body.empty()) {
																		valid_module_definition = false;
																		// TODO: GEN_ERROR
																	}

																	if (valid_module_definition) {
																		user_defined_module->variables = locals.value_or(std::vector<Variable::ptr>{});
																		for (const auto &statement : module_body) {
																			user_defined_module->addStatement(statement);
																		}
																		parsed_module.emplace(user_defined_module);
																	}
																.)
.


/*-------------------------------------------------------------------------
ParameterList production
-------------------------------------------------------------------------*/

ParameterList<bool &is_valid_module_definition, const Module::ptr &module>			(.	std::optional<Variable::ptr> parameter;	.)
=
Parameter<parameter>																(.	is_valid_module_definition = parameter.has_value();
																						if (is_valid_module_definition) {
																							module->addParameter(parameter.value());
																							current_symbol_table_scope->add_entry(parameter.value());
																						}
																					.)
{																					(.	parameter.reset();	.)
	"," Parameter<parameter>														(.	is_valid_module_definition = parameter.has_value();
																						if (is_valid_module_definition) {	
																							const Variable::ptr &well_formed_parameter = parameter.value();
																							if (!current_symbol_table_scope->contains(well_formed_parameter->name)) {
																								module->addParameter(well_formed_parameter);
																								current_symbol_table_scope->add_entry(well_formed_parameter);
																							}
																							else {
																								is_valid_module_definition = false;
																								// TODO: GEN_ERROR 
																							}
																						}
																					.)
}															
.


/*-------------------------------------------------------------------------
Parameter production
-------------------------------------------------------------------------*/

Parameter<. std::optional<Variable::ptr> &parameter .>								(.	Variable::Types parameter_type = Variable::Wire;
																						bool valid_variable_type = true;
																					.)	
= 
(
	"in"																			(.	parameter_type = Variable::In;	.)
	| "out"																			(.	parameter_type = Variable::Out;	.)
	| "inout"																		(.	parameter_type = Variable::Inout;	.)	
)																					(.	if (Variable::Wire == parameter_type) {
																							// TODO: GEN_ERROR 
																							// TODO: Do not cancel parsing
																							valid_variable_type = false;
																						}
																					.)
SignalDeclaration<parameter_type, parameter>										(.	if (!valid_variable_type) {
																							parameter.reset();
																						}
																					.)
.

/*-------------------------------------------------------------------------
SignalList production
-------------------------------------------------------------------------*/

SignalList <. std::optional<std::vector<Variable::ptr>> &signals .>	(.	Variable::Types signal_type = Variable::In;
																		std::optional<Variable::ptr> declared_signal;
																		bool valid_signal_type = true;
																		std::vector<Variable::ptr> valid_signal_declarations;
																	.)
=
(
	"wire"															(.	signal_type = Variable::Wire;		.)
	| "signal"														(.	signal_type = Variable::State;		.)
)																	(.	if (Variable::Wire != signal_type && Variable::State != signal_type) {
																			// TODO: GEN_ERROR ?
																			// TODO: Do not cancel parsing
																			valid_signal_type = false;
																		}
																	.)
SignalDeclaration<signal_type, declared_signal>						(.	if (valid_signal_type && declared_signal.has_value()) {
																			const Variable::ptr &valid_signal_declaration = declared_signal.value();
																			if (current_symbol_table_scope->contains(valid_signal_declaration->name)) {
																				// TODO: GEN_ERROR 
																				// TODO: Do not cancel parsing
																			}
																			else {
																				valid_signal_declarations.emplace_back(valid_signal_declaration);
																				current_symbol_table_scope->add_entry(valid_signal_declaration);
																			}
																		}
																	.)
{																	(.	declared_signal.reset();			.)	
	"," SignalDeclaration<signal_type, declared_signal>				(.	if (valid_signal_type && declared_signal.has_value()) {
																			const Variable::ptr &valid_signal_declaration = declared_signal.value();
																			if (current_symbol_table_scope->contains(valid_signal_declaration->name)) {
																				// TODO: GEN_ERROR 
																				// TODO: Do not cancel parsing
																			}
																			else {
																				valid_signal_declarations.emplace_back(valid_signal_declaration);
																				current_symbol_table_scope->add_entry(valid_signal_declaration);
																			}
																		}
																	.)
}																	(.	if (valid_signal_declarations.size()){
																			signals.emplace(valid_signal_declarations);
																		}
																	.)
.


/*-------------------------------------------------------------------------
SignalDeclaration production
-------------------------------------------------------------------------*/

SignalDeclaration<. Variable::Types variable_type, std::optional<Variable::ptr> &declared_signal .>			(.	std::vector<unsigned int> dimensions{};
																												// TODO: Use default bit width
																												unsigned int signal_width = 0;	
																												bool valid_declaration = true;
																											.)
=
ident																										(.	const std::string signal_ident = convert_to_uniform_text_format(t->val);	.)
{"[" 
	int																										(.	const std::optional<unsigned int> dimension = convert_token_value_to_number(*t);
																												if (!dimension.has_value()) {
																													valid_declaration = false;
																													// TODO: GEN_ERROR
																												}
																												else {
																													dimensions.emplace_back(dimension.value());	
																												}
																											.)
"]"}																									
["(" 
	int																									(.	const std::optional<unsigned int> user_defined_signal_width = convert_token_value_to_number(*t);
																											if (!user_defined_signal_width.has_value()) {
																												// TODO: GEN_ERROR
																												valid_declaration = false;
																											}
																											else {
																												signal_width = user_defined_signal_width.value();
																											}
																										.)
")"]																									(.	// TODO: What if no dimensions is specified, add default dimension entry ?
																											if (valid_declaration) {
																												declared_signal.emplace(std::make_shared<Variable>(Variable(variable_type, signal_ident, dimensions, signal_width)));
																											}
																										.)	
.

/*-------------------------------------------------------------------------
Statement variants
-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
StatementList
-------------------------------------------------------------------------*/

// TODO: Add check that every call statement has its matching counterpart, no uncall can be made before its corresponding call was called
StatementList<. Statement::vec &statements .>								(.	std::optional<Statement::ptr> user_defined_statement;	.)
=
Statement<user_defined_statement>											(.	if (user_defined_statement.has_value()) {
																					statements.emplace_back(user_defined_statement.value());
																				}
																			.)
{																			(.	user_defined_statement.reset();	.)	
	";" Statement<user_defined_statement>									(.	if (user_defined_statement.has_value()) {
																					statements.emplace_back(user_defined_statement.value());
																				}
																			.)
}
.


/*-------------------------------------------------------------------------
Statement production
-------------------------------------------------------------------------*/

Statement<. std::optional<Statement::ptr> &user_defined_statement .>
=
CallStatement<user_defined_statement>
| ForStatement<user_defined_statement>
| IfStatement<user_defined_statement>
| UnaryStatement<user_defined_statement>
| SkipStatement<user_defined_statement>
| IF (check_if_is_assign_statement()) AssignStatement<user_defined_statement>
| SwapStatement<user_defined_statement>
.


/*-------------------------------------------------------------------------
CallStatement production
-------------------------------------------------------------------------*/

// TODO: Are aliases between the formal and actual parameters necessary (i.e. in a call statement should the parameter be replaced with the actual value)
CallStatement<. std::optional<Statement::ptr> &statement .>							(.	std::optional<bool> is_call_statement;
																						std::vector<std::string> callee_arguments {};
																						bool valid_call_operation = true;
																						std::vector<std::string_view> formal_method_parameters {};
																						std::size_t num_actual_parameters = 0;
																					.)
=
(
	"call"																			(.	is_call_statement.emplace(true);	.)
	| "uncall"																		(.	is_call_statement.emplace(false);	.)
)																					(.	valid_call_operation = is_call_statement.has_value();	.)
ident																				(.	const std::string method_ident = convert_to_uniform_text_format(t->val);
																						method_call_guess::ptr guess_for_method = std::make_shared<method_call_guess>(method_call_guess(current_symbol_table_scope, method_ident));
																						if (!guess_for_method->matches_some_options()) {
																							// TODO: GEN_ERROR method not found
																							valid_call_operation = false;
																						}
																					.)
"(" 
	ident																			(.	std::string variable_ident = convert_to_uniform_text_format(t->val);
																						if (check_ident_was_declared(variable_ident)) {
																							try {
																								guess_for_method->refine(variable_ident);
																								valid_call_operation &= guess_for_method->matches_some_options();
																								if (valid_call_operation) {
																									callee_arguments.emplace_back(variable_ident);
																								}
																							}
																							catch (std::invalid_argument &ex) {
																								// TODO: GEN_ERROR
																								valid_call_operation = false;
																							}
																						}
																						else {
																							// TODO: GEN_ERROR
																						}
																						num_actual_parameters++;
																					.)
	{
		"," ident																	(.	variable_ident = convert_to_uniform_text_format(t->val);
																						if (check_ident_was_declared(variable_ident)) {
																							try {
																								guess_for_method->refine(variable_ident);
																								valid_call_operation &= guess_for_method->matches_some_options();
																								if (valid_call_operation) {
																									const Variable::ptr actual_parameter_symbol_entry = std::get<Variable::ptr>(current_symbol_table_scope->get_variable(variable_ident).value());
																									callee_arguments.emplace_back(variable_ident);
																								}
																							}
																							catch (std::invalid_argument &ex) {
																								// TODO: GEN_ERROR
																								valid_call_operation = false;
																							}
																						}
																						else {
																							// TODO: GEN_ERROR
																						}
																						num_actual_parameters++;
																					.)
	}																
")"																					(.	if (!valid_call_operation) {
																							return;		
																						}
																						if (!guess_for_method->matches_some_options()) {
																							// TODO: GEN_ERROR
																							return;
																						}

																						const std::optional<Module::ptr> possible_match_for_guess = guess_for_method->get_remaining_guess();
																						if (!possible_match_for_guess.has_value()) {
																							// TODO: GEN_ERROR
																							return;
																						}
																						else {
																							const Module::ptr &matching_module = possible_match_for_guess.value();

																							if (is_call_statement.value()) {
																								statement.emplace(std::make_shared<syrec::CallStatement>(syrec::CallStatement(matching_module, callee_arguments)));
																							}
																							else {
																								statement.emplace(std::make_shared<syrec::UncallStatement>(syrec::UncallStatement(matching_module, callee_arguments)));
																							}
																						}
																					.)
.


/*-------------------------------------------------------------------------
ForStatement production
-------------------------------------------------------------------------*/

// TODO: Currently no negative numbers are supported
ForStatement<. std::optional<Statement::ptr> &statement .>								(.	std::optional<std::string> loop_variable_ident;
																							std::optional<Number::ptr> iteration_range_start;
																							std::optional<Number::ptr> iteration_range_end;
																							std::optional<Number::ptr> custom_step_size;
																							bool negative_step_size = false;
																							Statement::vec loop_body{};
																							bool explicit_range_start_defined = false;
																							bool explicit_step_size_defined = false;
																						.)
=
"for" 
[IF (check_if_loop_iteration_range_start_is_defined()) (
	[
		IF (check_if_loop_variable_is_defined()) (
			"$" ident																	(.	const std::string &loop_var_ident = convert_to_uniform_text_format(t->val);
																							if (!check_ident_was_declared(loop_var_ident)) {
																								loop_variable_ident.emplace(convert_to_uniform_text_format(t->val));
																								symbol_table::open_scope(current_symbol_table_scope);
																								const Number::ptr loop_variable_entry = std::make_shared<syrec::Number>(syrec::Number(loop_var_ident));
																								current_symbol_table_scope->add_entry(loop_variable_entry);
																							}
																						.)
			"="
		)
	] 
	Number<iteration_range_start, false>												(.	explicit_range_start_defined = true;	.)
	"to"
)] 
Number<iteration_range_end, false>														(.	if (!explicit_range_start_defined){
																								iteration_range_start = iteration_range_end;
																							}
																						.)
["step"																					(.	explicit_step_size_defined = true;	.)
	[	"-"																				(.	negative_step_size = true;	.)
	] 
Number<custom_step_size, false>															(.	if (custom_step_size.has_value() && !custom_step_size.value()->evaluate({})) {
																								// TODO: GEN_ERROR step size cannot be zero ?
																							}
																						.)		
]																						(.	if (!explicit_step_size_defined) {
																								custom_step_size.emplace(std::make_shared<syrec::Number>(syrec::Number(1)));
																							}

																							bool valid_loop_header = loop_variable_ident.has_value() 
																															&& (explicit_range_start_defined ? iteration_range_start.has_value() : true)
																															&& iteration_range_end.has_value()
																															&& (explicit_step_size_defined ? custom_step_size.has_value() : true);
																							if (valid_loop_header) {
																								const unsigned int iteration_range_start_value = iteration_range_start.value()->evaluate({});
																								const unsigned int iteration_range_end_value = iteration_range_end.value()->evaluate({});
																								const unsigned int step_size = custom_step_size.value()->evaluate({});

																								unsigned int num_iterations;
																								if ((negative_step_size && iteration_range_end_value > iteration_range_start_value)
																									|| (!negative_step_size && iteration_range_start_value > iteration_range_end_value)
																									|| !step_size) {
																									// TODO: Either generate error or warning
																									num_iterations = 0;	
																									valid_loop_header = false;
																								}
																								else {
																									num_iterations = negative_step_size 
																										? (iteration_range_start_value - iteration_range_end_value)
																										: (iteration_range_end_value - iteration_range_start_value);
																									num_iterations = (num_iterations + 1) / step_size;
																								}
																							}
																						.)
"do" 
StatementList<loop_body>																(.	if (loop_body.empty()) {
																								// TODO: GEN_ERROR
																							}
																						.)
"rof"																					(.	if (loop_variable_ident.has_value()) {
																								symbol_table::close_scope(current_symbol_table_scope);
																							}

																							// TODO: If a statement must be generated, one could create a skip statement instead of simply returning 
																							if (!valid_loop_header || loop_body.empty()) {
																								return;
																							}

																							const std::shared_ptr<syrec::ForStatement> loop_statement = std::make_shared<syrec::ForStatement>(syrec::ForStatement());
																							loop_statement->loopVariable = loop_variable_ident.value();
																							loop_statement->range = std::pair(iteration_range_start.value(), iteration_range_end.value());
																							loop_statement->step = custom_step_size.value();
																							loop_statement->statements = loop_body;
																							statement.emplace(loop_statement);
																						.)
.

/*-------------------------------------------------------------------------
IfStatement production
-------------------------------------------------------------------------*/

IfStatement<. std::optional<Statement::ptr> &statement .>		(.	expression_evaluation_result condition;
																	expression_evaluation_result closing_condition;
																	Statement::vec true_branch{};
																	Statement::vec false_branch{};
																.)	
=
"if" Expression<condition, 1u, false> 
"then" 
StatementList<true_branch> 
"else" StatementList<false_branch>
"fi" Expression<closing_condition, 1u, false>					(.	// TODO: Add check that condition and closing_condition match
																	const bool conditional_well_formed = condition.has_value() 
																		&& closing_condition.has_value()
																		&& !true_branch.empty()
																		&& !false_branch.empty();
																	if (!conditional_well_formed) {
																		return;
																	}
															
																	const std::shared_ptr<syrec::IfStatement> &conditional = std::make_shared<syrec::IfStatement>(syrec::IfStatement());
																	conditional->condition = condition.value().convert_to_expression(1u);
																	conditional->fiCondition = closing_condition.value().convert_to_expression(1u);
																	conditional->thenStatements                    = true_branch;
																	conditional->elseStatements                    = false_branch;
																	statement.emplace(conditional);
																.)
.

/*-------------------------------------------------------------------------
UnaryStatement production
-------------------------------------------------------------------------*/

UnaryStatement<. std::optional<Statement::ptr> &statement .>			(.	signal_evaluation_result unary_stmt_operand;
																			std::optional<syrec_operation::operation> unary_operation;	
																		.)
=
(
	"~"																	(.	unary_operation.emplace(syrec_operation::operation::negate_assign);	.)
	| "++"																(.	unary_operation.emplace(syrec_operation::operation::increment_assign);	.)
	| "--"																(.	unary_operation.emplace(syrec_operation::operation::decrement_assign);	.)
) 
"=" Signal<unary_stmt_operand, false>									(.	if (!unary_operation.has_value() || !unary_stmt_operand.has_value() || nullptr == std::get<VariableAccess::ptr>(unary_stmt_operand.value())) {
																				return;
																			}

																			const VariableAccess::ptr unary_operand_variable = std::get<VariableAccess::ptr>(unary_stmt_operand.value());
																			const std::optional<unsigned int> mapped_operation = map_operation_to_unary_operation(unary_operation.value());
																			if (mapped_operation.has_value()) {
																				statement.emplace(std::make_shared<syrec::UnaryStatement>(syrec::UnaryStatement(mapped_operation.value(), unary_operand_variable)));
																			}
																		.)
.


/*-------------------------------------------------------------------------
AssignStatement production
-------------------------------------------------------------------------*/

AssignStatement<. std::optional<Statement::ptr> &statement .>	(.		signal_evaluation_result assign_stmt_lhs;
																		expression_evaluation_result assign_stmt_rhs;
																		std::optional<syrec_operation::operation> assign_operation;
																		unsigned int expression_bitwidth = 1u;

																		std::optional<VariableAccess::ptr> assigned_to_obj;
																.)
=
Signal<assign_stmt_lhs, false>									(.		if (assign_stmt_lhs.has_value() && std::holds_alternative<VariableAccess::ptr>(assign_stmt_lhs.value())) {
																			assigned_to_obj.emplace(std::get<VariableAccess::ptr>(assign_stmt_lhs.value()));
																			expression_bitwidth = assigned_to_obj.value()->bitwidth();
																		}
																.)
(
	"^"															(.		assign_operation.emplace(syrec_operation::operation::xor_assign);	.)
	| "+"														(.		assign_operation.emplace(syrec_operation::operation::add_assign);	.)
	| "-"														(.		assign_operation.emplace(syrec_operation::operation::minus_assign);	.)
)					
"=" Expression<assign_stmt_rhs, expression_bitwidth, false>		(.		if (!assigned_to_obj.has_value() || !assign_operation.has_value() || !assign_stmt_rhs.has_value()) {
																			return;
																		}
																		// TODO: To not break reversability of operation, check that expression does not contain the assigned to signal 
																		const std::optional<unsigned int> mapped_operation = map_operation_to_assign_operation(assign_operation.value());
																		if (mapped_operation.has_value()) {
																			statement.emplace(std::make_shared<syrec::AssignStatement>(syrec::AssignStatement(assigned_to_obj.value(),
																																				mapped_operation.value(),
																																				assign_stmt_rhs.value().convert_to_expression(expression_bitwidth))));
																		}
																.)		
.

/*-------------------------------------------------------------------------
SwapStatement production
-------------------------------------------------------------------------*/

SwapStatement<. std::optional<Statement::ptr> &statement .>			(.	signal_evaluation_result swap_me, swap_other;
																		bool swap_operator_specified = false;
																	.)
=
Signal<swap_me, false> 
"<=>"																(.	swap_operator_specified = true;	.)
Signal<swap_other, false>											(.	const bool lhs_operand_valid = swap_me.has_value() && std::holds_alternative<VariableAccess::ptr>(swap_me.value());
																		const bool rhs_operand_valid = swap_other.has_value() && std::holds_alternative<VariableAccess::ptr>(swap_other.value());

																		if (swap_operator_specified && lhs_operand_valid && rhs_operand_valid) {
																			const VariableAccess::ptr &lhs = std::get<VariableAccess::ptr>(swap_me.value());
																			const VariableAccess::ptr &rhs = std::get<VariableAccess::ptr>(swap_other.value());
																			statement.emplace(std::make_shared<syrec::SwapStatement>(syrec::SwapStatement(lhs, rhs)));
																		}			
																	.)
.


/*-------------------------------------------------------------------------
SkipStatement production
-------------------------------------------------------------------------*/

SkipStatement<. std::optional<Statement::ptr> &statement .>
=
"skip"															(.	statement.emplace(std::make_shared<syrec::SkipStatement>(syrec::SkipStatement()));	.)
.


/*-------------------------------------------------------------------------
Signal production
-------------------------------------------------------------------------*/

Signal<signal_evaluation_result &signal_access, bool simplify_if_possible>			(.	std::optional<Variable::ptr> signal;	
																						VariableAccess::ptr declared_signal_access;
																						bool valid_signal_access = true;
																						// TODO: Using global zero_based indexing flag to initialize default value
																						std::size_t dimension_index = 0;
																						unsigned int index_expression_bitwidth = 1u;
																					.)				
=
	ident																			(.	const std::string signal_ident = convert_to_uniform_text_format(t->val);
																						if (check_ident_was_declared(signal_ident)) {
																							const auto symbol_table_entry = current_symbol_table_scope->get_variable(signal_ident).value();
																							if (std::holds_alternative<Variable::ptr>(symbol_table_entry)) {
																								signal.emplace(std::get<Variable::ptr>(symbol_table_entry));
																								declared_signal_access = std::make_shared<VariableAccess>(VariableAccess());
																								declared_signal_access->setVar(signal.value());
																								index_expression_bitwidth = signal.value()->bitwidth;
																							}
																							else {
																								valid_signal_access = false;
																							}
																						}
																						else {
																							valid_signal_access = false;
																						}
																					.)
{"["																				(.	expression_evaluation_result index_expression;	.)
	Expression<index_expression, index_expression_bitwidth, simplify_if_possible>	(.	valid_signal_access &= index_expression.has_value();
																						if (signal.has_value() && index_expression.has_value()) {
																							const std::optional<unsigned int> &optional_dimension_access_value = get_value_if_expression_is_constant(index_expression);

																							if (optional_dimension_access_value.has_value()) {
																								const unsigned int constant_dimension_access_value = optional_dimension_access_value.value();

																								// TODO: Using global zero_based indexing flag
																								if (!range_check::is_valid_dimension_access(signal.value(), dimension_index, constant_dimension_access_value, true)) {
																									valid_signal_access = false;

																									// TODO: Using global zero_based indexing flag
																									const range_check::valid_index_access_range valid_dimension_access_range = range_check::get_valid_dimension_access_range(signal.value(), dimension_index, true).value();
																									// TODO: GEN_ERROR
																								}
																								else {
																									declared_signal_access->indexes.emplace_back(index_expression.value().convert_to_expression(index_expression_bitwidth));
																								}
																							}
																							else {
																								declared_signal_access->indexes.emplace_back(index_expression.value().get_expression());
																							}
																						}
																						dimension_index++;
																					.)
"]"
} 
[																					(.	std::optional<Number::ptr> range_start, range_end;
																						bool defined_range = false;
																					.)
	"." Number<range_start, false>									
	[
		":" Number<range_end, false>											(.	defined_range = true;	.)
	]																			(.	valid_signal_access &= range_start.has_value() && (defined_range ? range_end.has_value() : true);
																					if (valid_signal_access) {
																						const Variable::ptr &accessed_variable = signal.value();

																						const bool is_bit_access = !range_end.has_value();
																						const std::pair<Number::ptr, Number::ptr> range(range_start.value(), is_bit_access ? range_start.value() : range_end.value());
																						const std::pair<std::size_t, std::size_t> range_values(range.first->evaluate({}), range.second->evaluate({}));
																					
																						if (is_bit_access) {
																							// TODO: Check bitwidth is within range [0, bitwidth - 1]
																							// TODO: Using global zero_based indexing flag
																							if (!range_check::is_valid_bit_access(accessed_variable, range_values.first, true)) {
																								valid_signal_access = false;
																								// TODO: GEN_ERROR
																								// TODO: Using global zero_based indexing flag
																								const range_check::valid_index_access_range valid_dimension_access_range = range_check::get_valid_bit_access_range(accessed_variable, true);
																							}
																						}
																						else {
																							// TODO: Check user defined range is within [0, bitwidth - 1]
																							// TODO: Using global zero_based indexing flag
																							if (!range_check::is_valid_range_access(accessed_variable, range_values, true)){
																								valid_signal_access = false;
																								// TODO: GEN_ERROR
																								// TODO: Using global zero_based indexing flag
																								const range_check::valid_index_access_range valid_dimension_access_range = range_check::get_valid_range_access_range(accessed_variable, true);
																							}
																						}

																						if (valid_signal_access){
																							declared_signal_access->range.emplace(range);
																						}
																					}
																				.)
]																				(.	if (valid_signal_access) {
																						signal_access.emplace(declared_signal_access);
																					}
																				.)
.

/*-------------------------------------------------------------------------
Expressions variants
-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
Expression production
-------------------------------------------------------------------------*/

Expression<expression_evaluation_result &user_defined_expression, unsigned int bitwidth, bool simplify_if_possible>	(.	signal_evaluation_result signal;
																														std::optional<Number::ptr> number;
																													.)
=
(
	IF (check_if_expression_is_number()) Number<number, simplify_if_possible>										(.	if (number.has_value()) {
																															user_defined_expression.emplace(std::make_shared<NumericExpression>(NumericExpression(number.value(), bitwidth)));
																														}
																													.)
	| IF (check_if_expression_is_binary_expression()) BinaryExpression<user_defined_expression, bitwidth, simplify_if_possible>
	| ShiftExpression<user_defined_expression, bitwidth, simplify_if_possible>
)
	| Signal<signal, simplify_if_possible>																			(.	if (signal.has_value()) {
																															if (std::holds_alternative<VariableAccess::ptr>(signal.value())) {
																																const VariableAccess::ptr &var_access = std::get<VariableAccess::ptr>(signal.value());
																																user_defined_expression.emplace(std::make_shared<VariableExpression>(VariableExpression(var_access)));
																															}
																															else if (std::holds_alternative<Number::ptr>(signal.value())){
																																const Number::ptr &number_signal = std::get<Number::ptr>(signal.value());
																																user_defined_expression.emplace(std::make_shared<NumericExpression>(NumericExpression(number_signal, bitwidth)));
																															}
																														}
																													.)
	| UnaryExpression<user_defined_expression, bitwidth, simplify_if_possible>
.

/*-------------------------------------------------------------------------
BinaryExpression production
-------------------------------------------------------------------------*/

BinaryExpression<expression_evaluation_result &user_defined_binary_expression, unsigned int bitwidth, bool simplify_if_possible>	(.	expression_evaluation_result binary_expr_lhs;
																																		expression_evaluation_result binary_expr_rhs;
																																		std::optional<syrec_operation::operation> binary_operation;
																																		unsigned int operands_bitwidth = 0u;
																																	.)	
=
"(" Expression<binary_expr_lhs, bitwidth, simplify_if_possible>																		(.	if (binary_expr_lhs.has_value()) {
																																			operands_bitwidth = std::max(binary_expr_lhs->convert_to_expression(bitwidth)->bitwidth(), bitwidth);
																																		}
																																	.)
	(
		"+"																											(.	binary_operation.emplace(syrec_operation::operation::addition);	.)
		| "-"																										(.	binary_operation.emplace(syrec_operation::operation::subtraction);	.)
		| "^"																										(.	binary_operation.emplace(syrec_operation::operation::bitwise_xor);	.)
		| "*"																										(.	binary_operation.emplace(syrec_operation::operation::multiplication);	.)
		| "/"																										(.	binary_operation.emplace(syrec_operation::operation::division);	.)
		| "%"																										(.	binary_operation.emplace(syrec_operation::operation::modulo);	.)
		| "*>"																										(.	binary_operation.emplace(syrec_operation::operation::upper_bits_multiplication);	.)
		| "&&"																										(.	binary_operation.emplace(syrec_operation::operation::logical_and);	.)
		| "||"																										(.	binary_operation.emplace(syrec_operation::operation::logical_or);	.)
		| "&"																										(.	binary_operation.emplace(syrec_operation::operation::bitwise_and);	.)
		| "|"																										(.	binary_operation.emplace(syrec_operation::operation::bitwise_or);	.)
		| "<"																										(.	binary_operation.emplace(syrec_operation::operation::less_than);	.)
		| ">"																										(.	binary_operation.emplace(syrec_operation::operation::greater_than);	.)
		| "="																										(.	binary_operation.emplace(syrec_operation::operation::equals);	.)
		| "!="																										(.	binary_operation.emplace(syrec_operation::operation::not_equals);	.)
		| "<="																										(.	binary_operation.emplace(syrec_operation::operation::less_equals);	.)
		| ">="																										(.	binary_operation.emplace(syrec_operation::operation::greater_equals);	.)
	) 
	Expression<binary_expr_rhs, operands_bitwidth, simplify_if_possible>																
")"																													(.	
																														if (binary_expr_lhs.has_value() && binary_operation.has_value() && binary_expr_rhs.has_value()) {
																															const std::optional<unsigned int> mapped_operation = map_operation_to_binary_operation(binary_operation.value());
																															if (mapped_operation.has_value()) {
																																if (binary_expr_lhs->is_constant() && binary_expr_rhs->is_constant()) {
																																	const unsigned int binary_expr_lhs_value = binary_expr_lhs->get_constant_value();
																																	const unsigned int binary_expr_rhs_value = binary_expr_rhs->get_constant_value();
																																	const std::optional<unsigned int> evaluation_result = apply_binary_operation(binary_operation.value(),
																																													binary_expr_lhs_value, binary_expr_rhs_value);
																																	if (evaluation_result.has_value()) {
																																		user_defined_binary_expression.emplace(evaluation_result.value());
																																	}
																																}
																																else {
																																	const expression::ptr lhs_operand = binary_expr_lhs->convert_to_expression(operands_bitwidth);
																																	const expression::ptr rhs_operand = binary_expr_rhs->convert_to_expression(operands_bitwidth);
																																	user_defined_binary_expression.emplace(std::make_shared<syrec::BinaryExpression>(syrec::BinaryExpression(lhs_operand,
																																						mapped_operation.value(),
																																						rhs_operand)));
																																}
																															}
																														}
																													.)
.


/*-------------------------------------------------------------------------
UnaryExpression production
-------------------------------------------------------------------------*/

UnaryExpression<expression_evaluation_result &unary_expression, unsigned int bitwidth, bool simplify_if_possible>	(.	expression_evaluation_result unary_expression_operand;
																														std::optional<syrec_operation::operation> unary_operation;
																													.)
=
(
	"!"																												(.	unary_operation.emplace(syrec_operation::operation::logical_negation);	.)
	| "~"																											(.	unary_operation.emplace(syrec_operation::operation::bitwise_negation);	.)
)		
Expression<unary_expression_operand, bitwidth, simplify_if_possible>												(.	if (unary_operation.has_value() && unary_expression_operand.has_value()){
																															// TODO:
																														}

																														// TODO: Notify user (i.e. via error) that reference parser currently does not support unary statements - we will ignore them for now
																													.)	
.


/*-------------------------------------------------------------------------
ShiftExpression production
-------------------------------------------------------------------------*/

ShiftExpression<expression_evaluation_result &user_defined_shift_expression, unsigned int bitwidth, bool simplify_if_possible>	(.	expression_evaluation_result shift_expression_lhs;
																																	std::optional<Number::ptr> shift_amount;
																																	std::optional<syrec_operation::operation> shift_operation;
																																.)
=
"(" Expression<shift_expression_lhs, bitwidth, simplify_if_possible> 
(
	"<<"																														(.	shift_operation.emplace(syrec_operation::operation::shift_left);	.)
	| ">>"																														(.	shift_operation.emplace(syrec_operation::operation::shift_right);	.)
) Number<shift_amount, simplify_if_possible>																					(.	if (shift_expression_lhs.has_value() && shift_operation.has_value() && shift_amount.has_value()) {
																																		const std::optional<unsigned int> mapped_shift_operation = map_operation_to_shift_operation(shift_operation.value());
																																		const expression::ptr lhs_operand_expression = shift_expression_lhs.value().convert_to_expression(bitwidth);
																																		
																																		// One could replace the shift statement with a skip statement if the shift amount is zero 
																																		const std::optional<unsigned int> shift_amount_value_evaluated = evaluate_number_container_to_constant(shift_amount.value());
																																		if (shift_amount_value_evaluated.has_value() && shift_expression_lhs.value().is_constant()) {
																																			const unsigned int shift_operand_lhs_value = shift_expression_lhs.value().get_constant_value();
																																			const std::optional<unsigned int> shift_application_result = syrec_operation::apply(shift_operation.value(), 
																																																								shift_operand_lhs_value,
																																																								shift_amount_value_evaluated.value());
																															
																																			if (shift_application_result.has_value()) {
																																				user_defined_shift_expression.emplace(expression_or_constant(shift_application_result.value()));
																																			}
																																			else {
																																				// TODO: GEN_ERROR
																																				return;
																																			}
																																		}
																																		else {
																																			const expression::ptr lhs_operand_expression = shift_expression_lhs.value().convert_to_expression(bitwidth);
																																			user_defined_shift_expression.emplace(std::make_shared<syrec::ShiftExpression>(lhs_operand_expression,
																																																	mapped_shift_operation.value(),
																																																	shift_amount.value()));
																																		}
																																	}
																																.)
")"
.

END SyReC.